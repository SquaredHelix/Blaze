declare enum EntityCategory {
	NONE,
	UNDEAD,
	ARTHROPOD,
	ILLAGER,
	WATER,
}
namespace EntityCategory {
	function values(): EntityCategory[]
	function valueOf(arg0: String): EntityCategory
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum StructureRotation {
	NONE,
	CLOCKWISE_90,
	CLOCKWISE_180,
	COUNTERCLOCKWISE_90,
}
namespace StructureRotation {
	function values(): StructureRotation[]
	function valueOf(arg0: String): StructureRotation
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum TreeType {
	TREE,
	BIG_TREE,
	REDWOOD,
	TALL_REDWOOD,
	BIRCH,
	JUNGLE,
	SMALL_JUNGLE,
	COCOA_TREE,
	JUNGLE_BUSH,
	RED_MUSHROOM,
	BROWN_MUSHROOM,
	SWAMP,
	ACACIA,
	DARK_OAK,
	MEGA_REDWOOD,
	TALL_BIRCH,
	CHORUS_PLANT,
	CRIMSON_FUNGUS,
	WARPED_FUNGUS,
	AZALEA,
}
namespace TreeType {
	function values(): TreeType[]
	function valueOf(arg0: String): TreeType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PatternType {
	BASE,
	SQUARE_BOTTOM_LEFT,
	SQUARE_BOTTOM_RIGHT,
	SQUARE_TOP_LEFT,
	SQUARE_TOP_RIGHT,
	STRIPE_BOTTOM,
	STRIPE_TOP,
	STRIPE_LEFT,
	STRIPE_RIGHT,
	STRIPE_CENTER,
	STRIPE_MIDDLE,
	STRIPE_DOWNRIGHT,
	STRIPE_DOWNLEFT,
	STRIPE_SMALL,
	CROSS,
	STRAIGHT_CROSS,
	TRIANGLE_BOTTOM,
	TRIANGLE_TOP,
	TRIANGLES_BOTTOM,
	TRIANGLES_TOP,
	DIAGONAL_LEFT,
	DIAGONAL_RIGHT,
	DIAGONAL_LEFT_MIRROR,
	DIAGONAL_RIGHT_MIRROR,
	CIRCLE_MIDDLE,
	RHOMBUS_MIDDLE,
	HALF_VERTICAL,
	HALF_HORIZONTAL,
	HALF_VERTICAL_MIRROR,
	HALF_HORIZONTAL_MIRROR,
	BORDER,
	CURLY_BORDER,
	CREEPER,
	GRADIENT,
	GRADIENT_UP,
	BRICKS,
	SKULL,
	FLOWER,
	MOJANG,
	GLOBE,
	PIGLIN,
}
namespace PatternType {
	function getByIdentifier(arg0: String): PatternType
	function getIdentifier(): String
	function values(): PatternType[]
	function valueOf(arg0: String): PatternType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum CacheStrategy {
	CACHE_AFTER_FIRST_EVAL,
	NEVER_CACHE,
	CACHE_ETERNALLY,
}
namespace CacheStrategy {
	function values(): CacheStrategy[]
	function valueOf(arg0: String): CacheStrategy
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum TreeSpecies {
	GENERIC,
	REDWOOD,
	BIRCH,
	JUNGLE,
	ACACIA,
	DARK_OAK,
}
namespace TreeSpecies {
	function getData(): byte
	function getByData(arg0: byte): TreeSpecies
	function values(): TreeSpecies[]
	function valueOf(arg0: String): TreeSpecies
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Shape {
	NORTH_SOUTH,
	EAST_WEST,
	ASCENDING_EAST,
	ASCENDING_WEST,
	ASCENDING_NORTH,
	ASCENDING_SOUTH,
	SOUTH_EAST,
	SOUTH_WEST,
	NORTH_WEST,
	NORTH_EAST,
}
namespace Shape {
	function values(): Shape[]
	function valueOf(arg0: String): Shape
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Connection {
	UP,
	SIDE,
	NONE,
}
namespace Connection {
	function values(): Connection[]
	function valueOf(arg0: String): Connection
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum EnchantmentTarget {
	ALL,
	ARMOR,
	ARMOR_FEET,
	ARMOR_LEGS,
	ARMOR_TORSO,
	ARMOR_HEAD,
	WEAPON,
	TOOL,
	BOW,
	FISHING_ROD,
	BREAKABLE,
	WEARABLE,
	TRIDENT,
	CROSSBOW,
	VANISHABLE,
}
namespace EnchantmentTarget {
	function includes(arg0: ItemStack): boolean
	function includes(arg0: Material): boolean
	function values(): EnchantmentTarget[]
	function valueOf(arg0: String): EnchantmentTarget
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum BarColor {
	PINK,
	BLUE,
	RED,
	GREEN,
	YELLOW,
	PURPLE,
	WHITE,
}
namespace BarColor {
	function values(): BarColor[]
	function valueOf(arg0: String): BarColor
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Property {
	BREW_TIME,
	FUEL_TIME,
	BURN_TIME,
	TICKS_FOR_CURRENT_FUEL,
	COOK_TIME,
	TICKS_FOR_CURRENT_SMELTING,
	ENCHANT_BUTTON1,
	ENCHANT_BUTTON2,
	ENCHANT_BUTTON3,
	ENCHANT_XP_SEED,
	ENCHANT_ID1,
	ENCHANT_ID2,
	ENCHANT_ID3,
	ENCHANT_LEVEL1,
	ENCHANT_LEVEL2,
	ENCHANT_LEVEL3,
	LEVELS,
	PRIMARY_EFFECT,
	SECONDARY_EFFECT,
	REPAIR_COST,
	BOOK_PAGE,
}
namespace Property {
	function values(): Property[]
	function valueOf(arg0: String): Property
	function getId(): int
	function getType(): InventoryType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	BROWN,
	WHITE,
	BLACK,
	BLACK_AND_WHITE,
	GOLD,
	SALT_AND_PEPPER,
	THE_KILLER_BUNNY,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum EquipmentSlot {
	HAND,
	OFF_HAND,
	FEET,
	LEGS,
	CHEST,
	HEAD,
}
namespace EquipmentSlot {
	function values(): EquipmentSlot[]
	function valueOf(arg0: String): EquipmentSlot
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Material {
	AIR,
	STONE,
	GRANITE,
	POLISHED_GRANITE,
	DIORITE,
	POLISHED_DIORITE,
	ANDESITE,
	POLISHED_ANDESITE,
	DEEPSLATE,
	COBBLED_DEEPSLATE,
	POLISHED_DEEPSLATE,
	CALCITE,
	TUFF,
	DRIPSTONE_BLOCK,
	GRASS_BLOCK,
	DIRT,
	COARSE_DIRT,
	PODZOL,
	ROOTED_DIRT,
	CRIMSON_NYLIUM,
	WARPED_NYLIUM,
	COBBLESTONE,
	OAK_PLANKS,
	SPRUCE_PLANKS,
	BIRCH_PLANKS,
	JUNGLE_PLANKS,
	ACACIA_PLANKS,
	DARK_OAK_PLANKS,
	CRIMSON_PLANKS,
	WARPED_PLANKS,
	OAK_SAPLING,
	SPRUCE_SAPLING,
	BIRCH_SAPLING,
	JUNGLE_SAPLING,
	ACACIA_SAPLING,
	DARK_OAK_SAPLING,
	BEDROCK,
	SAND,
	RED_SAND,
	GRAVEL,
	COAL_ORE,
	DEEPSLATE_COAL_ORE,
	IRON_ORE,
	DEEPSLATE_IRON_ORE,
	COPPER_ORE,
	DEEPSLATE_COPPER_ORE,
	GOLD_ORE,
	DEEPSLATE_GOLD_ORE,
	REDSTONE_ORE,
	DEEPSLATE_REDSTONE_ORE,
	EMERALD_ORE,
	DEEPSLATE_EMERALD_ORE,
	LAPIS_ORE,
	DEEPSLATE_LAPIS_ORE,
	DIAMOND_ORE,
	DEEPSLATE_DIAMOND_ORE,
	NETHER_GOLD_ORE,
	NETHER_QUARTZ_ORE,
	ANCIENT_DEBRIS,
	COAL_BLOCK,
	RAW_IRON_BLOCK,
	RAW_COPPER_BLOCK,
	RAW_GOLD_BLOCK,
	AMETHYST_BLOCK,
	BUDDING_AMETHYST,
	IRON_BLOCK,
	COPPER_BLOCK,
	GOLD_BLOCK,
	DIAMOND_BLOCK,
	NETHERITE_BLOCK,
	EXPOSED_COPPER,
	WEATHERED_COPPER,
	OXIDIZED_COPPER,
	CUT_COPPER,
	EXPOSED_CUT_COPPER,
	WEATHERED_CUT_COPPER,
	OXIDIZED_CUT_COPPER,
	CUT_COPPER_STAIRS,
	EXPOSED_CUT_COPPER_STAIRS,
	WEATHERED_CUT_COPPER_STAIRS,
	OXIDIZED_CUT_COPPER_STAIRS,
	CUT_COPPER_SLAB,
	EXPOSED_CUT_COPPER_SLAB,
	WEATHERED_CUT_COPPER_SLAB,
	OXIDIZED_CUT_COPPER_SLAB,
	WAXED_COPPER_BLOCK,
	WAXED_EXPOSED_COPPER,
	WAXED_WEATHERED_COPPER,
	WAXED_OXIDIZED_COPPER,
	WAXED_CUT_COPPER,
	WAXED_EXPOSED_CUT_COPPER,
	WAXED_WEATHERED_CUT_COPPER,
	WAXED_OXIDIZED_CUT_COPPER,
	WAXED_CUT_COPPER_STAIRS,
	WAXED_EXPOSED_CUT_COPPER_STAIRS,
	WAXED_WEATHERED_CUT_COPPER_STAIRS,
	WAXED_OXIDIZED_CUT_COPPER_STAIRS,
	WAXED_CUT_COPPER_SLAB,
	WAXED_EXPOSED_CUT_COPPER_SLAB,
	WAXED_WEATHERED_CUT_COPPER_SLAB,
	WAXED_OXIDIZED_CUT_COPPER_SLAB,
	OAK_LOG,
	SPRUCE_LOG,
	BIRCH_LOG,
	JUNGLE_LOG,
	ACACIA_LOG,
	DARK_OAK_LOG,
	CRIMSON_STEM,
	WARPED_STEM,
	STRIPPED_OAK_LOG,
	STRIPPED_SPRUCE_LOG,
	STRIPPED_BIRCH_LOG,
	STRIPPED_JUNGLE_LOG,
	STRIPPED_ACACIA_LOG,
	STRIPPED_DARK_OAK_LOG,
	STRIPPED_CRIMSON_STEM,
	STRIPPED_WARPED_STEM,
	STRIPPED_OAK_WOOD,
	STRIPPED_SPRUCE_WOOD,
	STRIPPED_BIRCH_WOOD,
	STRIPPED_JUNGLE_WOOD,
	STRIPPED_ACACIA_WOOD,
	STRIPPED_DARK_OAK_WOOD,
	STRIPPED_CRIMSON_HYPHAE,
	STRIPPED_WARPED_HYPHAE,
	OAK_WOOD,
	SPRUCE_WOOD,
	BIRCH_WOOD,
	JUNGLE_WOOD,
	ACACIA_WOOD,
	DARK_OAK_WOOD,
	CRIMSON_HYPHAE,
	WARPED_HYPHAE,
	OAK_LEAVES,
	SPRUCE_LEAVES,
	BIRCH_LEAVES,
	JUNGLE_LEAVES,
	ACACIA_LEAVES,
	DARK_OAK_LEAVES,
	AZALEA_LEAVES,
	FLOWERING_AZALEA_LEAVES,
	SPONGE,
	WET_SPONGE,
	GLASS,
	TINTED_GLASS,
	LAPIS_BLOCK,
	SANDSTONE,
	CHISELED_SANDSTONE,
	CUT_SANDSTONE,
	COBWEB,
	GRASS,
	FERN,
	AZALEA,
	FLOWERING_AZALEA,
	DEAD_BUSH,
	SEAGRASS,
	SEA_PICKLE,
	WHITE_WOOL,
	ORANGE_WOOL,
	MAGENTA_WOOL,
	LIGHT_BLUE_WOOL,
	YELLOW_WOOL,
	LIME_WOOL,
	PINK_WOOL,
	GRAY_WOOL,
	LIGHT_GRAY_WOOL,
	CYAN_WOOL,
	PURPLE_WOOL,
	BLUE_WOOL,
	BROWN_WOOL,
	GREEN_WOOL,
	RED_WOOL,
	BLACK_WOOL,
	DANDELION,
	POPPY,
	BLUE_ORCHID,
	ALLIUM,
	AZURE_BLUET,
	RED_TULIP,
	ORANGE_TULIP,
	WHITE_TULIP,
	PINK_TULIP,
	OXEYE_DAISY,
	CORNFLOWER,
	LILY_OF_THE_VALLEY,
	WITHER_ROSE,
	SPORE_BLOSSOM,
	BROWN_MUSHROOM,
	RED_MUSHROOM,
	CRIMSON_FUNGUS,
	WARPED_FUNGUS,
	CRIMSON_ROOTS,
	WARPED_ROOTS,
	NETHER_SPROUTS,
	WEEPING_VINES,
	TWISTING_VINES,
	SUGAR_CANE,
	KELP,
	MOSS_CARPET,
	MOSS_BLOCK,
	HANGING_ROOTS,
	BIG_DRIPLEAF,
	SMALL_DRIPLEAF,
	BAMBOO,
	OAK_SLAB,
	SPRUCE_SLAB,
	BIRCH_SLAB,
	JUNGLE_SLAB,
	ACACIA_SLAB,
	DARK_OAK_SLAB,
	CRIMSON_SLAB,
	WARPED_SLAB,
	STONE_SLAB,
	SMOOTH_STONE_SLAB,
	SANDSTONE_SLAB,
	CUT_SANDSTONE_SLAB,
	PETRIFIED_OAK_SLAB,
	COBBLESTONE_SLAB,
	BRICK_SLAB,
	STONE_BRICK_SLAB,
	NETHER_BRICK_SLAB,
	QUARTZ_SLAB,
	RED_SANDSTONE_SLAB,
	CUT_RED_SANDSTONE_SLAB,
	PURPUR_SLAB,
	PRISMARINE_SLAB,
	PRISMARINE_BRICK_SLAB,
	DARK_PRISMARINE_SLAB,
	SMOOTH_QUARTZ,
	SMOOTH_RED_SANDSTONE,
	SMOOTH_SANDSTONE,
	SMOOTH_STONE,
	BRICKS,
	BOOKSHELF,
	MOSSY_COBBLESTONE,
	OBSIDIAN,
	TORCH,
	END_ROD,
	CHORUS_PLANT,
	CHORUS_FLOWER,
	PURPUR_BLOCK,
	PURPUR_PILLAR,
	PURPUR_STAIRS,
	SPAWNER,
	OAK_STAIRS,
	CHEST,
	CRAFTING_TABLE,
	FARMLAND,
	FURNACE,
	LADDER,
	COBBLESTONE_STAIRS,
	SNOW,
	ICE,
	SNOW_BLOCK,
	CACTUS,
	CLAY,
	JUKEBOX,
	OAK_FENCE,
	SPRUCE_FENCE,
	BIRCH_FENCE,
	JUNGLE_FENCE,
	ACACIA_FENCE,
	DARK_OAK_FENCE,
	CRIMSON_FENCE,
	WARPED_FENCE,
	PUMPKIN,
	CARVED_PUMPKIN,
	JACK_O_LANTERN,
	NETHERRACK,
	SOUL_SAND,
	SOUL_SOIL,
	BASALT,
	POLISHED_BASALT,
	SMOOTH_BASALT,
	SOUL_TORCH,
	GLOWSTONE,
	INFESTED_STONE,
	INFESTED_COBBLESTONE,
	INFESTED_STONE_BRICKS,
	INFESTED_MOSSY_STONE_BRICKS,
	INFESTED_CRACKED_STONE_BRICKS,
	INFESTED_CHISELED_STONE_BRICKS,
	INFESTED_DEEPSLATE,
	STONE_BRICKS,
	MOSSY_STONE_BRICKS,
	CRACKED_STONE_BRICKS,
	CHISELED_STONE_BRICKS,
	DEEPSLATE_BRICKS,
	CRACKED_DEEPSLATE_BRICKS,
	DEEPSLATE_TILES,
	CRACKED_DEEPSLATE_TILES,
	CHISELED_DEEPSLATE,
	BROWN_MUSHROOM_BLOCK,
	RED_MUSHROOM_BLOCK,
	MUSHROOM_STEM,
	IRON_BARS,
	CHAIN,
	GLASS_PANE,
	MELON,
	VINE,
	GLOW_LICHEN,
	BRICK_STAIRS,
	STONE_BRICK_STAIRS,
	MYCELIUM,
	LILY_PAD,
	NETHER_BRICKS,
	CRACKED_NETHER_BRICKS,
	CHISELED_NETHER_BRICKS,
	NETHER_BRICK_FENCE,
	NETHER_BRICK_STAIRS,
	ENCHANTING_TABLE,
	END_PORTAL_FRAME,
	END_STONE,
	END_STONE_BRICKS,
	DRAGON_EGG,
	SANDSTONE_STAIRS,
	ENDER_CHEST,
	EMERALD_BLOCK,
	SPRUCE_STAIRS,
	BIRCH_STAIRS,
	JUNGLE_STAIRS,
	CRIMSON_STAIRS,
	WARPED_STAIRS,
	COMMAND_BLOCK,
	BEACON,
	COBBLESTONE_WALL,
	MOSSY_COBBLESTONE_WALL,
	BRICK_WALL,
	PRISMARINE_WALL,
	RED_SANDSTONE_WALL,
	MOSSY_STONE_BRICK_WALL,
	GRANITE_WALL,
	STONE_BRICK_WALL,
	NETHER_BRICK_WALL,
	ANDESITE_WALL,
	RED_NETHER_BRICK_WALL,
	SANDSTONE_WALL,
	END_STONE_BRICK_WALL,
	DIORITE_WALL,
	BLACKSTONE_WALL,
	POLISHED_BLACKSTONE_WALL,
	POLISHED_BLACKSTONE_BRICK_WALL,
	COBBLED_DEEPSLATE_WALL,
	POLISHED_DEEPSLATE_WALL,
	DEEPSLATE_BRICK_WALL,
	DEEPSLATE_TILE_WALL,
	ANVIL,
	CHIPPED_ANVIL,
	DAMAGED_ANVIL,
	CHISELED_QUARTZ_BLOCK,
	QUARTZ_BLOCK,
	QUARTZ_BRICKS,
	QUARTZ_PILLAR,
	QUARTZ_STAIRS,
	WHITE_TERRACOTTA,
	ORANGE_TERRACOTTA,
	MAGENTA_TERRACOTTA,
	LIGHT_BLUE_TERRACOTTA,
	YELLOW_TERRACOTTA,
	LIME_TERRACOTTA,
	PINK_TERRACOTTA,
	GRAY_TERRACOTTA,
	LIGHT_GRAY_TERRACOTTA,
	CYAN_TERRACOTTA,
	PURPLE_TERRACOTTA,
	BLUE_TERRACOTTA,
	BROWN_TERRACOTTA,
	GREEN_TERRACOTTA,
	RED_TERRACOTTA,
	BLACK_TERRACOTTA,
	BARRIER,
	LIGHT,
	HAY_BLOCK,
	WHITE_CARPET,
	ORANGE_CARPET,
	MAGENTA_CARPET,
	LIGHT_BLUE_CARPET,
	YELLOW_CARPET,
	LIME_CARPET,
	PINK_CARPET,
	GRAY_CARPET,
	LIGHT_GRAY_CARPET,
	CYAN_CARPET,
	PURPLE_CARPET,
	BLUE_CARPET,
	BROWN_CARPET,
	GREEN_CARPET,
	RED_CARPET,
	BLACK_CARPET,
	TERRACOTTA,
	PACKED_ICE,
	ACACIA_STAIRS,
	DARK_OAK_STAIRS,
	DIRT_PATH,
	SUNFLOWER,
	LILAC,
	ROSE_BUSH,
	PEONY,
	TALL_GRASS,
	LARGE_FERN,
	WHITE_STAINED_GLASS,
	ORANGE_STAINED_GLASS,
	MAGENTA_STAINED_GLASS,
	LIGHT_BLUE_STAINED_GLASS,
	YELLOW_STAINED_GLASS,
	LIME_STAINED_GLASS,
	PINK_STAINED_GLASS,
	GRAY_STAINED_GLASS,
	LIGHT_GRAY_STAINED_GLASS,
	CYAN_STAINED_GLASS,
	PURPLE_STAINED_GLASS,
	BLUE_STAINED_GLASS,
	BROWN_STAINED_GLASS,
	GREEN_STAINED_GLASS,
	RED_STAINED_GLASS,
	BLACK_STAINED_GLASS,
	WHITE_STAINED_GLASS_PANE,
	ORANGE_STAINED_GLASS_PANE,
	MAGENTA_STAINED_GLASS_PANE,
	LIGHT_BLUE_STAINED_GLASS_PANE,
	YELLOW_STAINED_GLASS_PANE,
	LIME_STAINED_GLASS_PANE,
	PINK_STAINED_GLASS_PANE,
	GRAY_STAINED_GLASS_PANE,
	LIGHT_GRAY_STAINED_GLASS_PANE,
	CYAN_STAINED_GLASS_PANE,
	PURPLE_STAINED_GLASS_PANE,
	BLUE_STAINED_GLASS_PANE,
	BROWN_STAINED_GLASS_PANE,
	GREEN_STAINED_GLASS_PANE,
	RED_STAINED_GLASS_PANE,
	BLACK_STAINED_GLASS_PANE,
	PRISMARINE,
	PRISMARINE_BRICKS,
	DARK_PRISMARINE,
	PRISMARINE_STAIRS,
	PRISMARINE_BRICK_STAIRS,
	DARK_PRISMARINE_STAIRS,
	SEA_LANTERN,
	RED_SANDSTONE,
	CHISELED_RED_SANDSTONE,
	CUT_RED_SANDSTONE,
	RED_SANDSTONE_STAIRS,
	REPEATING_COMMAND_BLOCK,
	CHAIN_COMMAND_BLOCK,
	MAGMA_BLOCK,
	NETHER_WART_BLOCK,
	WARPED_WART_BLOCK,
	RED_NETHER_BRICKS,
	BONE_BLOCK,
	STRUCTURE_VOID,
	SHULKER_BOX,
	WHITE_SHULKER_BOX,
	ORANGE_SHULKER_BOX,
	MAGENTA_SHULKER_BOX,
	LIGHT_BLUE_SHULKER_BOX,
	YELLOW_SHULKER_BOX,
	LIME_SHULKER_BOX,
	PINK_SHULKER_BOX,
	GRAY_SHULKER_BOX,
	LIGHT_GRAY_SHULKER_BOX,
	CYAN_SHULKER_BOX,
	PURPLE_SHULKER_BOX,
	BLUE_SHULKER_BOX,
	BROWN_SHULKER_BOX,
	GREEN_SHULKER_BOX,
	RED_SHULKER_BOX,
	BLACK_SHULKER_BOX,
	WHITE_GLAZED_TERRACOTTA,
	ORANGE_GLAZED_TERRACOTTA,
	MAGENTA_GLAZED_TERRACOTTA,
	LIGHT_BLUE_GLAZED_TERRACOTTA,
	YELLOW_GLAZED_TERRACOTTA,
	LIME_GLAZED_TERRACOTTA,
	PINK_GLAZED_TERRACOTTA,
	GRAY_GLAZED_TERRACOTTA,
	LIGHT_GRAY_GLAZED_TERRACOTTA,
	CYAN_GLAZED_TERRACOTTA,
	PURPLE_GLAZED_TERRACOTTA,
	BLUE_GLAZED_TERRACOTTA,
	BROWN_GLAZED_TERRACOTTA,
	GREEN_GLAZED_TERRACOTTA,
	RED_GLAZED_TERRACOTTA,
	BLACK_GLAZED_TERRACOTTA,
	WHITE_CONCRETE,
	ORANGE_CONCRETE,
	MAGENTA_CONCRETE,
	LIGHT_BLUE_CONCRETE,
	YELLOW_CONCRETE,
	LIME_CONCRETE,
	PINK_CONCRETE,
	GRAY_CONCRETE,
	LIGHT_GRAY_CONCRETE,
	CYAN_CONCRETE,
	PURPLE_CONCRETE,
	BLUE_CONCRETE,
	BROWN_CONCRETE,
	GREEN_CONCRETE,
	RED_CONCRETE,
	BLACK_CONCRETE,
	WHITE_CONCRETE_POWDER,
	ORANGE_CONCRETE_POWDER,
	MAGENTA_CONCRETE_POWDER,
	LIGHT_BLUE_CONCRETE_POWDER,
	YELLOW_CONCRETE_POWDER,
	LIME_CONCRETE_POWDER,
	PINK_CONCRETE_POWDER,
	GRAY_CONCRETE_POWDER,
	LIGHT_GRAY_CONCRETE_POWDER,
	CYAN_CONCRETE_POWDER,
	PURPLE_CONCRETE_POWDER,
	BLUE_CONCRETE_POWDER,
	BROWN_CONCRETE_POWDER,
	GREEN_CONCRETE_POWDER,
	RED_CONCRETE_POWDER,
	BLACK_CONCRETE_POWDER,
	TURTLE_EGG,
	DEAD_TUBE_CORAL_BLOCK,
	DEAD_BRAIN_CORAL_BLOCK,
	DEAD_BUBBLE_CORAL_BLOCK,
	DEAD_FIRE_CORAL_BLOCK,
	DEAD_HORN_CORAL_BLOCK,
	TUBE_CORAL_BLOCK,
	BRAIN_CORAL_BLOCK,
	BUBBLE_CORAL_BLOCK,
	FIRE_CORAL_BLOCK,
	HORN_CORAL_BLOCK,
	TUBE_CORAL,
	BRAIN_CORAL,
	BUBBLE_CORAL,
	FIRE_CORAL,
	HORN_CORAL,
	DEAD_BRAIN_CORAL,
	DEAD_BUBBLE_CORAL,
	DEAD_FIRE_CORAL,
	DEAD_HORN_CORAL,
	DEAD_TUBE_CORAL,
	TUBE_CORAL_FAN,
	BRAIN_CORAL_FAN,
	BUBBLE_CORAL_FAN,
	FIRE_CORAL_FAN,
	HORN_CORAL_FAN,
	DEAD_TUBE_CORAL_FAN,
	DEAD_BRAIN_CORAL_FAN,
	DEAD_BUBBLE_CORAL_FAN,
	DEAD_FIRE_CORAL_FAN,
	DEAD_HORN_CORAL_FAN,
	BLUE_ICE,
	CONDUIT,
	POLISHED_GRANITE_STAIRS,
	SMOOTH_RED_SANDSTONE_STAIRS,
	MOSSY_STONE_BRICK_STAIRS,
	POLISHED_DIORITE_STAIRS,
	MOSSY_COBBLESTONE_STAIRS,
	END_STONE_BRICK_STAIRS,
	STONE_STAIRS,
	SMOOTH_SANDSTONE_STAIRS,
	SMOOTH_QUARTZ_STAIRS,
	GRANITE_STAIRS,
	ANDESITE_STAIRS,
	RED_NETHER_BRICK_STAIRS,
	POLISHED_ANDESITE_STAIRS,
	DIORITE_STAIRS,
	COBBLED_DEEPSLATE_STAIRS,
	POLISHED_DEEPSLATE_STAIRS,
	DEEPSLATE_BRICK_STAIRS,
	DEEPSLATE_TILE_STAIRS,
	POLISHED_GRANITE_SLAB,
	SMOOTH_RED_SANDSTONE_SLAB,
	MOSSY_STONE_BRICK_SLAB,
	POLISHED_DIORITE_SLAB,
	MOSSY_COBBLESTONE_SLAB,
	END_STONE_BRICK_SLAB,
	SMOOTH_SANDSTONE_SLAB,
	SMOOTH_QUARTZ_SLAB,
	GRANITE_SLAB,
	ANDESITE_SLAB,
	RED_NETHER_BRICK_SLAB,
	POLISHED_ANDESITE_SLAB,
	DIORITE_SLAB,
	COBBLED_DEEPSLATE_SLAB,
	POLISHED_DEEPSLATE_SLAB,
	DEEPSLATE_BRICK_SLAB,
	DEEPSLATE_TILE_SLAB,
	SCAFFOLDING,
	REDSTONE,
	REDSTONE_TORCH,
	REDSTONE_BLOCK,
	REPEATER,
	COMPARATOR,
	PISTON,
	STICKY_PISTON,
	SLIME_BLOCK,
	HONEY_BLOCK,
	OBSERVER,
	HOPPER,
	DISPENSER,
	DROPPER,
	LECTERN,
	TARGET,
	LEVER,
	LIGHTNING_ROD,
	DAYLIGHT_DETECTOR,
	SCULK_SENSOR,
	TRIPWIRE_HOOK,
	TRAPPED_CHEST,
	TNT,
	REDSTONE_LAMP,
	NOTE_BLOCK,
	STONE_BUTTON,
	POLISHED_BLACKSTONE_BUTTON,
	OAK_BUTTON,
	SPRUCE_BUTTON,
	BIRCH_BUTTON,
	JUNGLE_BUTTON,
	ACACIA_BUTTON,
	DARK_OAK_BUTTON,
	CRIMSON_BUTTON,
	WARPED_BUTTON,
	STONE_PRESSURE_PLATE,
	POLISHED_BLACKSTONE_PRESSURE_PLATE,
	LIGHT_WEIGHTED_PRESSURE_PLATE,
	HEAVY_WEIGHTED_PRESSURE_PLATE,
	OAK_PRESSURE_PLATE,
	SPRUCE_PRESSURE_PLATE,
	BIRCH_PRESSURE_PLATE,
	JUNGLE_PRESSURE_PLATE,
	ACACIA_PRESSURE_PLATE,
	DARK_OAK_PRESSURE_PLATE,
	CRIMSON_PRESSURE_PLATE,
	WARPED_PRESSURE_PLATE,
	IRON_DOOR,
	OAK_DOOR,
	SPRUCE_DOOR,
	BIRCH_DOOR,
	JUNGLE_DOOR,
	ACACIA_DOOR,
	DARK_OAK_DOOR,
	CRIMSON_DOOR,
	WARPED_DOOR,
	IRON_TRAPDOOR,
	OAK_TRAPDOOR,
	SPRUCE_TRAPDOOR,
	BIRCH_TRAPDOOR,
	JUNGLE_TRAPDOOR,
	ACACIA_TRAPDOOR,
	DARK_OAK_TRAPDOOR,
	CRIMSON_TRAPDOOR,
	WARPED_TRAPDOOR,
	OAK_FENCE_GATE,
	SPRUCE_FENCE_GATE,
	BIRCH_FENCE_GATE,
	JUNGLE_FENCE_GATE,
	ACACIA_FENCE_GATE,
	DARK_OAK_FENCE_GATE,
	CRIMSON_FENCE_GATE,
	WARPED_FENCE_GATE,
	POWERED_RAIL,
	DETECTOR_RAIL,
	RAIL,
	ACTIVATOR_RAIL,
	SADDLE,
	MINECART,
	CHEST_MINECART,
	FURNACE_MINECART,
	TNT_MINECART,
	HOPPER_MINECART,
	CARROT_ON_A_STICK,
	WARPED_FUNGUS_ON_A_STICK,
	ELYTRA,
	OAK_BOAT,
	SPRUCE_BOAT,
	BIRCH_BOAT,
	JUNGLE_BOAT,
	ACACIA_BOAT,
	DARK_OAK_BOAT,
	STRUCTURE_BLOCK,
	JIGSAW,
	TURTLE_HELMET,
	SCUTE,
	FLINT_AND_STEEL,
	APPLE,
	BOW,
	ARROW,
	COAL,
	CHARCOAL,
	DIAMOND,
	EMERALD,
	LAPIS_LAZULI,
	QUARTZ,
	AMETHYST_SHARD,
	RAW_IRON,
	IRON_INGOT,
	RAW_COPPER,
	COPPER_INGOT,
	RAW_GOLD,
	GOLD_INGOT,
	NETHERITE_INGOT,
	NETHERITE_SCRAP,
	WOODEN_SWORD,
	WOODEN_SHOVEL,
	WOODEN_PICKAXE,
	WOODEN_AXE,
	WOODEN_HOE,
	STONE_SWORD,
	STONE_SHOVEL,
	STONE_PICKAXE,
	STONE_AXE,
	STONE_HOE,
	GOLDEN_SWORD,
	GOLDEN_SHOVEL,
	GOLDEN_PICKAXE,
	GOLDEN_AXE,
	GOLDEN_HOE,
	IRON_SWORD,
	IRON_SHOVEL,
	IRON_PICKAXE,
	IRON_AXE,
	IRON_HOE,
	DIAMOND_SWORD,
	DIAMOND_SHOVEL,
	DIAMOND_PICKAXE,
	DIAMOND_AXE,
	DIAMOND_HOE,
	NETHERITE_SWORD,
	NETHERITE_SHOVEL,
	NETHERITE_PICKAXE,
	NETHERITE_AXE,
	NETHERITE_HOE,
	STICK,
	BOWL,
	MUSHROOM_STEW,
	STRING,
	FEATHER,
	GUNPOWDER,
	WHEAT_SEEDS,
	WHEAT,
	BREAD,
	LEATHER_HELMET,
	LEATHER_CHESTPLATE,
	LEATHER_LEGGINGS,
	LEATHER_BOOTS,
	CHAINMAIL_HELMET,
	CHAINMAIL_CHESTPLATE,
	CHAINMAIL_LEGGINGS,
	CHAINMAIL_BOOTS,
	IRON_HELMET,
	IRON_CHESTPLATE,
	IRON_LEGGINGS,
	IRON_BOOTS,
	DIAMOND_HELMET,
	DIAMOND_CHESTPLATE,
	DIAMOND_LEGGINGS,
	DIAMOND_BOOTS,
	GOLDEN_HELMET,
	GOLDEN_CHESTPLATE,
	GOLDEN_LEGGINGS,
	GOLDEN_BOOTS,
	NETHERITE_HELMET,
	NETHERITE_CHESTPLATE,
	NETHERITE_LEGGINGS,
	NETHERITE_BOOTS,
	FLINT,
	PORKCHOP,
	COOKED_PORKCHOP,
	PAINTING,
	GOLDEN_APPLE,
	ENCHANTED_GOLDEN_APPLE,
	OAK_SIGN,
	SPRUCE_SIGN,
	BIRCH_SIGN,
	JUNGLE_SIGN,
	ACACIA_SIGN,
	DARK_OAK_SIGN,
	CRIMSON_SIGN,
	WARPED_SIGN,
	BUCKET,
	WATER_BUCKET,
	LAVA_BUCKET,
	POWDER_SNOW_BUCKET,
	SNOWBALL,
	LEATHER,
	MILK_BUCKET,
	PUFFERFISH_BUCKET,
	SALMON_BUCKET,
	COD_BUCKET,
	TROPICAL_FISH_BUCKET,
	AXOLOTL_BUCKET,
	BRICK,
	CLAY_BALL,
	DRIED_KELP_BLOCK,
	PAPER,
	BOOK,
	SLIME_BALL,
	EGG,
	COMPASS,
	BUNDLE,
	FISHING_ROD,
	CLOCK,
	SPYGLASS,
	GLOWSTONE_DUST,
	COD,
	SALMON,
	TROPICAL_FISH,
	PUFFERFISH,
	COOKED_COD,
	COOKED_SALMON,
	INK_SAC,
	GLOW_INK_SAC,
	COCOA_BEANS,
	WHITE_DYE,
	ORANGE_DYE,
	MAGENTA_DYE,
	LIGHT_BLUE_DYE,
	YELLOW_DYE,
	LIME_DYE,
	PINK_DYE,
	GRAY_DYE,
	LIGHT_GRAY_DYE,
	CYAN_DYE,
	PURPLE_DYE,
	BLUE_DYE,
	BROWN_DYE,
	GREEN_DYE,
	RED_DYE,
	BLACK_DYE,
	BONE_MEAL,
	BONE,
	SUGAR,
	CAKE,
	WHITE_BED,
	ORANGE_BED,
	MAGENTA_BED,
	LIGHT_BLUE_BED,
	YELLOW_BED,
	LIME_BED,
	PINK_BED,
	GRAY_BED,
	LIGHT_GRAY_BED,
	CYAN_BED,
	PURPLE_BED,
	BLUE_BED,
	BROWN_BED,
	GREEN_BED,
	RED_BED,
	BLACK_BED,
	COOKIE,
	FILLED_MAP,
	SHEARS,
	MELON_SLICE,
	DRIED_KELP,
	PUMPKIN_SEEDS,
	MELON_SEEDS,
	BEEF,
	COOKED_BEEF,
	CHICKEN,
	COOKED_CHICKEN,
	ROTTEN_FLESH,
	ENDER_PEARL,
	BLAZE_ROD,
	GHAST_TEAR,
	GOLD_NUGGET,
	NETHER_WART,
	POTION,
	GLASS_BOTTLE,
	SPIDER_EYE,
	FERMENTED_SPIDER_EYE,
	BLAZE_POWDER,
	MAGMA_CREAM,
	BREWING_STAND,
	CAULDRON,
	ENDER_EYE,
	GLISTERING_MELON_SLICE,
	AXOLOTL_SPAWN_EGG,
	BAT_SPAWN_EGG,
	BEE_SPAWN_EGG,
	BLAZE_SPAWN_EGG,
	CAT_SPAWN_EGG,
	CAVE_SPIDER_SPAWN_EGG,
	CHICKEN_SPAWN_EGG,
	COD_SPAWN_EGG,
	COW_SPAWN_EGG,
	CREEPER_SPAWN_EGG,
	DOLPHIN_SPAWN_EGG,
	DONKEY_SPAWN_EGG,
	DROWNED_SPAWN_EGG,
	ELDER_GUARDIAN_SPAWN_EGG,
	ENDERMAN_SPAWN_EGG,
	ENDERMITE_SPAWN_EGG,
	EVOKER_SPAWN_EGG,
	FOX_SPAWN_EGG,
	GHAST_SPAWN_EGG,
	GLOW_SQUID_SPAWN_EGG,
	GOAT_SPAWN_EGG,
	GUARDIAN_SPAWN_EGG,
	HOGLIN_SPAWN_EGG,
	HORSE_SPAWN_EGG,
	HUSK_SPAWN_EGG,
	LLAMA_SPAWN_EGG,
	MAGMA_CUBE_SPAWN_EGG,
	MOOSHROOM_SPAWN_EGG,
	MULE_SPAWN_EGG,
	OCELOT_SPAWN_EGG,
	PANDA_SPAWN_EGG,
	PARROT_SPAWN_EGG,
	PHANTOM_SPAWN_EGG,
	PIG_SPAWN_EGG,
	PIGLIN_SPAWN_EGG,
	PIGLIN_BRUTE_SPAWN_EGG,
	PILLAGER_SPAWN_EGG,
	POLAR_BEAR_SPAWN_EGG,
	PUFFERFISH_SPAWN_EGG,
	RABBIT_SPAWN_EGG,
	RAVAGER_SPAWN_EGG,
	SALMON_SPAWN_EGG,
	SHEEP_SPAWN_EGG,
	SHULKER_SPAWN_EGG,
	SILVERFISH_SPAWN_EGG,
	SKELETON_SPAWN_EGG,
	SKELETON_HORSE_SPAWN_EGG,
	SLIME_SPAWN_EGG,
	SPIDER_SPAWN_EGG,
	SQUID_SPAWN_EGG,
	STRAY_SPAWN_EGG,
	STRIDER_SPAWN_EGG,
	TRADER_LLAMA_SPAWN_EGG,
	TROPICAL_FISH_SPAWN_EGG,
	TURTLE_SPAWN_EGG,
	VEX_SPAWN_EGG,
	VILLAGER_SPAWN_EGG,
	VINDICATOR_SPAWN_EGG,
	WANDERING_TRADER_SPAWN_EGG,
	WITCH_SPAWN_EGG,
	WITHER_SKELETON_SPAWN_EGG,
	WOLF_SPAWN_EGG,
	ZOGLIN_SPAWN_EGG,
	ZOMBIE_SPAWN_EGG,
	ZOMBIE_HORSE_SPAWN_EGG,
	ZOMBIE_VILLAGER_SPAWN_EGG,
	ZOMBIFIED_PIGLIN_SPAWN_EGG,
	EXPERIENCE_BOTTLE,
	FIRE_CHARGE,
	WRITABLE_BOOK,
	WRITTEN_BOOK,
	ITEM_FRAME,
	GLOW_ITEM_FRAME,
	FLOWER_POT,
	CARROT,
	POTATO,
	BAKED_POTATO,
	POISONOUS_POTATO,
	MAP,
	GOLDEN_CARROT,
	SKELETON_SKULL,
	WITHER_SKELETON_SKULL,
	PLAYER_HEAD,
	ZOMBIE_HEAD,
	CREEPER_HEAD,
	DRAGON_HEAD,
	NETHER_STAR,
	PUMPKIN_PIE,
	FIREWORK_ROCKET,
	FIREWORK_STAR,
	ENCHANTED_BOOK,
	NETHER_BRICK,
	PRISMARINE_SHARD,
	PRISMARINE_CRYSTALS,
	RABBIT,
	COOKED_RABBIT,
	RABBIT_STEW,
	RABBIT_FOOT,
	RABBIT_HIDE,
	ARMOR_STAND,
	IRON_HORSE_ARMOR,
	GOLDEN_HORSE_ARMOR,
	DIAMOND_HORSE_ARMOR,
	LEATHER_HORSE_ARMOR,
	LEAD,
	NAME_TAG,
	COMMAND_BLOCK_MINECART,
	MUTTON,
	COOKED_MUTTON,
	WHITE_BANNER,
	ORANGE_BANNER,
	MAGENTA_BANNER,
	LIGHT_BLUE_BANNER,
	YELLOW_BANNER,
	LIME_BANNER,
	PINK_BANNER,
	GRAY_BANNER,
	LIGHT_GRAY_BANNER,
	CYAN_BANNER,
	PURPLE_BANNER,
	BLUE_BANNER,
	BROWN_BANNER,
	GREEN_BANNER,
	RED_BANNER,
	BLACK_BANNER,
	END_CRYSTAL,
	CHORUS_FRUIT,
	POPPED_CHORUS_FRUIT,
	BEETROOT,
	BEETROOT_SEEDS,
	BEETROOT_SOUP,
	DRAGON_BREATH,
	SPLASH_POTION,
	SPECTRAL_ARROW,
	TIPPED_ARROW,
	LINGERING_POTION,
	SHIELD,
	TOTEM_OF_UNDYING,
	SHULKER_SHELL,
	IRON_NUGGET,
	KNOWLEDGE_BOOK,
	DEBUG_STICK,
	MUSIC_DISC_13,
	MUSIC_DISC_CAT,
	MUSIC_DISC_BLOCKS,
	MUSIC_DISC_CHIRP,
	MUSIC_DISC_FAR,
	MUSIC_DISC_MALL,
	MUSIC_DISC_MELLOHI,
	MUSIC_DISC_STAL,
	MUSIC_DISC_STRAD,
	MUSIC_DISC_WARD,
	MUSIC_DISC_11,
	MUSIC_DISC_WAIT,
	MUSIC_DISC_PIGSTEP,
	TRIDENT,
	PHANTOM_MEMBRANE,
	NAUTILUS_SHELL,
	HEART_OF_THE_SEA,
	CROSSBOW,
	SUSPICIOUS_STEW,
	LOOM,
	FLOWER_BANNER_PATTERN,
	CREEPER_BANNER_PATTERN,
	SKULL_BANNER_PATTERN,
	MOJANG_BANNER_PATTERN,
	GLOBE_BANNER_PATTERN,
	PIGLIN_BANNER_PATTERN,
	COMPOSTER,
	BARREL,
	SMOKER,
	BLAST_FURNACE,
	CARTOGRAPHY_TABLE,
	FLETCHING_TABLE,
	GRINDSTONE,
	SMITHING_TABLE,
	STONECUTTER,
	BELL,
	LANTERN,
	SOUL_LANTERN,
	SWEET_BERRIES,
	GLOW_BERRIES,
	CAMPFIRE,
	SOUL_CAMPFIRE,
	SHROOMLIGHT,
	HONEYCOMB,
	BEE_NEST,
	BEEHIVE,
	HONEY_BOTTLE,
	HONEYCOMB_BLOCK,
	LODESTONE,
	CRYING_OBSIDIAN,
	BLACKSTONE,
	BLACKSTONE_SLAB,
	BLACKSTONE_STAIRS,
	GILDED_BLACKSTONE,
	POLISHED_BLACKSTONE,
	POLISHED_BLACKSTONE_SLAB,
	POLISHED_BLACKSTONE_STAIRS,
	CHISELED_POLISHED_BLACKSTONE,
	POLISHED_BLACKSTONE_BRICKS,
	POLISHED_BLACKSTONE_BRICK_SLAB,
	POLISHED_BLACKSTONE_BRICK_STAIRS,
	CRACKED_POLISHED_BLACKSTONE_BRICKS,
	RESPAWN_ANCHOR,
	CANDLE,
	WHITE_CANDLE,
	ORANGE_CANDLE,
	MAGENTA_CANDLE,
	LIGHT_BLUE_CANDLE,
	YELLOW_CANDLE,
	LIME_CANDLE,
	PINK_CANDLE,
	GRAY_CANDLE,
	LIGHT_GRAY_CANDLE,
	CYAN_CANDLE,
	PURPLE_CANDLE,
	BLUE_CANDLE,
	BROWN_CANDLE,
	GREEN_CANDLE,
	RED_CANDLE,
	BLACK_CANDLE,
	SMALL_AMETHYST_BUD,
	MEDIUM_AMETHYST_BUD,
	LARGE_AMETHYST_BUD,
	AMETHYST_CLUSTER,
	POINTED_DRIPSTONE,
	WATER,
	LAVA,
	TALL_SEAGRASS,
	PISTON_HEAD,
	MOVING_PISTON,
	WALL_TORCH,
	FIRE,
	SOUL_FIRE,
	REDSTONE_WIRE,
	OAK_WALL_SIGN,
	SPRUCE_WALL_SIGN,
	BIRCH_WALL_SIGN,
	ACACIA_WALL_SIGN,
	JUNGLE_WALL_SIGN,
	DARK_OAK_WALL_SIGN,
	REDSTONE_WALL_TORCH,
	SOUL_WALL_TORCH,
	NETHER_PORTAL,
	ATTACHED_PUMPKIN_STEM,
	ATTACHED_MELON_STEM,
	PUMPKIN_STEM,
	MELON_STEM,
	WATER_CAULDRON,
	LAVA_CAULDRON,
	POWDER_SNOW_CAULDRON,
	END_PORTAL,
	COCOA,
	TRIPWIRE,
	POTTED_OAK_SAPLING,
	POTTED_SPRUCE_SAPLING,
	POTTED_BIRCH_SAPLING,
	POTTED_JUNGLE_SAPLING,
	POTTED_ACACIA_SAPLING,
	POTTED_DARK_OAK_SAPLING,
	POTTED_FERN,
	POTTED_DANDELION,
	POTTED_POPPY,
	POTTED_BLUE_ORCHID,
	POTTED_ALLIUM,
	POTTED_AZURE_BLUET,
	POTTED_RED_TULIP,
	POTTED_ORANGE_TULIP,
	POTTED_WHITE_TULIP,
	POTTED_PINK_TULIP,
	POTTED_OXEYE_DAISY,
	POTTED_CORNFLOWER,
	POTTED_LILY_OF_THE_VALLEY,
	POTTED_WITHER_ROSE,
	POTTED_RED_MUSHROOM,
	POTTED_BROWN_MUSHROOM,
	POTTED_DEAD_BUSH,
	POTTED_CACTUS,
	CARROTS,
	POTATOES,
	SKELETON_WALL_SKULL,
	WITHER_SKELETON_WALL_SKULL,
	ZOMBIE_WALL_HEAD,
	PLAYER_WALL_HEAD,
	CREEPER_WALL_HEAD,
	DRAGON_WALL_HEAD,
	WHITE_WALL_BANNER,
	ORANGE_WALL_BANNER,
	MAGENTA_WALL_BANNER,
	LIGHT_BLUE_WALL_BANNER,
	YELLOW_WALL_BANNER,
	LIME_WALL_BANNER,
	PINK_WALL_BANNER,
	GRAY_WALL_BANNER,
	LIGHT_GRAY_WALL_BANNER,
	CYAN_WALL_BANNER,
	PURPLE_WALL_BANNER,
	BLUE_WALL_BANNER,
	BROWN_WALL_BANNER,
	GREEN_WALL_BANNER,
	RED_WALL_BANNER,
	BLACK_WALL_BANNER,
	BEETROOTS,
	END_GATEWAY,
	FROSTED_ICE,
	KELP_PLANT,
	DEAD_TUBE_CORAL_WALL_FAN,
	DEAD_BRAIN_CORAL_WALL_FAN,
	DEAD_BUBBLE_CORAL_WALL_FAN,
	DEAD_FIRE_CORAL_WALL_FAN,
	DEAD_HORN_CORAL_WALL_FAN,
	TUBE_CORAL_WALL_FAN,
	BRAIN_CORAL_WALL_FAN,
	BUBBLE_CORAL_WALL_FAN,
	FIRE_CORAL_WALL_FAN,
	HORN_CORAL_WALL_FAN,
	BAMBOO_SAPLING,
	POTTED_BAMBOO,
	VOID_AIR,
	CAVE_AIR,
	BUBBLE_COLUMN,
	SWEET_BERRY_BUSH,
	WEEPING_VINES_PLANT,
	TWISTING_VINES_PLANT,
	CRIMSON_WALL_SIGN,
	WARPED_WALL_SIGN,
	POTTED_CRIMSON_FUNGUS,
	POTTED_WARPED_FUNGUS,
	POTTED_CRIMSON_ROOTS,
	POTTED_WARPED_ROOTS,
	CANDLE_CAKE,
	WHITE_CANDLE_CAKE,
	ORANGE_CANDLE_CAKE,
	MAGENTA_CANDLE_CAKE,
	LIGHT_BLUE_CANDLE_CAKE,
	YELLOW_CANDLE_CAKE,
	LIME_CANDLE_CAKE,
	PINK_CANDLE_CAKE,
	GRAY_CANDLE_CAKE,
	LIGHT_GRAY_CANDLE_CAKE,
	CYAN_CANDLE_CAKE,
	PURPLE_CANDLE_CAKE,
	BLUE_CANDLE_CAKE,
	BROWN_CANDLE_CAKE,
	GREEN_CANDLE_CAKE,
	RED_CANDLE_CAKE,
	BLACK_CANDLE_CAKE,
	POWDER_SNOW,
	CAVE_VINES,
	CAVE_VINES_PLANT,
	BIG_DRIPLEAF_STEM,
	POTTED_AZALEA_BUSH,
	POTTED_FLOWERING_AZALEA_BUSH,
	LEGACY_AIR,
	LEGACY_STONE,
	LEGACY_GRASS,
	LEGACY_DIRT,
	LEGACY_COBBLESTONE,
	LEGACY_WOOD,
	LEGACY_SAPLING,
	LEGACY_BEDROCK,
	LEGACY_WATER,
	LEGACY_STATIONARY_WATER,
	LEGACY_LAVA,
	LEGACY_STATIONARY_LAVA,
	LEGACY_SAND,
	LEGACY_GRAVEL,
	LEGACY_GOLD_ORE,
	LEGACY_IRON_ORE,
	LEGACY_COAL_ORE,
	LEGACY_LOG,
	LEGACY_LEAVES,
	LEGACY_SPONGE,
	LEGACY_GLASS,
	LEGACY_LAPIS_ORE,
	LEGACY_LAPIS_BLOCK,
	LEGACY_DISPENSER,
	LEGACY_SANDSTONE,
	LEGACY_NOTE_BLOCK,
	LEGACY_BED_BLOCK,
	LEGACY_POWERED_RAIL,
	LEGACY_DETECTOR_RAIL,
	LEGACY_PISTON_STICKY_BASE,
	LEGACY_WEB,
	LEGACY_LONG_GRASS,
	LEGACY_DEAD_BUSH,
	LEGACY_PISTON_BASE,
	LEGACY_PISTON_EXTENSION,
	LEGACY_WOOL,
	LEGACY_PISTON_MOVING_PIECE,
	LEGACY_YELLOW_FLOWER,
	LEGACY_RED_ROSE,
	LEGACY_BROWN_MUSHROOM,
	LEGACY_RED_MUSHROOM,
	LEGACY_GOLD_BLOCK,
	LEGACY_IRON_BLOCK,
	LEGACY_DOUBLE_STEP,
	LEGACY_STEP,
	LEGACY_BRICK,
	LEGACY_TNT,
	LEGACY_BOOKSHELF,
	LEGACY_MOSSY_COBBLESTONE,
	LEGACY_OBSIDIAN,
	LEGACY_TORCH,
	LEGACY_FIRE,
	LEGACY_MOB_SPAWNER,
	LEGACY_WOOD_STAIRS,
	LEGACY_CHEST,
	LEGACY_REDSTONE_WIRE,
	LEGACY_DIAMOND_ORE,
	LEGACY_DIAMOND_BLOCK,
	LEGACY_WORKBENCH,
	LEGACY_CROPS,
	LEGACY_SOIL,
	LEGACY_FURNACE,
	LEGACY_BURNING_FURNACE,
	LEGACY_SIGN_POST,
	LEGACY_WOODEN_DOOR,
	LEGACY_LADDER,
	LEGACY_RAILS,
	LEGACY_COBBLESTONE_STAIRS,
	LEGACY_WALL_SIGN,
	LEGACY_LEVER,
	LEGACY_STONE_PLATE,
	LEGACY_IRON_DOOR_BLOCK,
	LEGACY_WOOD_PLATE,
	LEGACY_REDSTONE_ORE,
	LEGACY_GLOWING_REDSTONE_ORE,
	LEGACY_REDSTONE_TORCH_OFF,
	LEGACY_REDSTONE_TORCH_ON,
	LEGACY_STONE_BUTTON,
	LEGACY_SNOW,
	LEGACY_ICE,
	LEGACY_SNOW_BLOCK,
	LEGACY_CACTUS,
	LEGACY_CLAY,
	LEGACY_SUGAR_CANE_BLOCK,
	LEGACY_JUKEBOX,
	LEGACY_FENCE,
	LEGACY_PUMPKIN,
	LEGACY_NETHERRACK,
	LEGACY_SOUL_SAND,
	LEGACY_GLOWSTONE,
	LEGACY_PORTAL,
	LEGACY_JACK_O_LANTERN,
	LEGACY_CAKE_BLOCK,
	LEGACY_DIODE_BLOCK_OFF,
	LEGACY_DIODE_BLOCK_ON,
	LEGACY_STAINED_GLASS,
	LEGACY_TRAP_DOOR,
	LEGACY_MONSTER_EGGS,
	LEGACY_SMOOTH_BRICK,
	LEGACY_HUGE_MUSHROOM_1,
	LEGACY_HUGE_MUSHROOM_2,
	LEGACY_IRON_FENCE,
	LEGACY_THIN_GLASS,
	LEGACY_MELON_BLOCK,
	LEGACY_PUMPKIN_STEM,
	LEGACY_MELON_STEM,
	LEGACY_VINE,
	LEGACY_FENCE_GATE,
	LEGACY_BRICK_STAIRS,
	LEGACY_SMOOTH_STAIRS,
	LEGACY_MYCEL,
	LEGACY_WATER_LILY,
	LEGACY_NETHER_BRICK,
	LEGACY_NETHER_FENCE,
	LEGACY_NETHER_BRICK_STAIRS,
	LEGACY_NETHER_WARTS,
	LEGACY_ENCHANTMENT_TABLE,
	LEGACY_BREWING_STAND,
	LEGACY_CAULDRON,
	LEGACY_ENDER_PORTAL,
	LEGACY_ENDER_PORTAL_FRAME,
	LEGACY_ENDER_STONE,
	LEGACY_DRAGON_EGG,
	LEGACY_REDSTONE_LAMP_OFF,
	LEGACY_REDSTONE_LAMP_ON,
	LEGACY_WOOD_DOUBLE_STEP,
	LEGACY_WOOD_STEP,
	LEGACY_COCOA,
	LEGACY_SANDSTONE_STAIRS,
	LEGACY_EMERALD_ORE,
	LEGACY_ENDER_CHEST,
	LEGACY_TRIPWIRE_HOOK,
	LEGACY_TRIPWIRE,
	LEGACY_EMERALD_BLOCK,
	LEGACY_SPRUCE_WOOD_STAIRS,
	LEGACY_BIRCH_WOOD_STAIRS,
	LEGACY_JUNGLE_WOOD_STAIRS,
	LEGACY_COMMAND,
	LEGACY_BEACON,
	LEGACY_COBBLE_WALL,
	LEGACY_FLOWER_POT,
	LEGACY_CARROT,
	LEGACY_POTATO,
	LEGACY_WOOD_BUTTON,
	LEGACY_SKULL,
	LEGACY_ANVIL,
	LEGACY_TRAPPED_CHEST,
	LEGACY_GOLD_PLATE,
	LEGACY_IRON_PLATE,
	LEGACY_REDSTONE_COMPARATOR_OFF,
	LEGACY_REDSTONE_COMPARATOR_ON,
	LEGACY_DAYLIGHT_DETECTOR,
	LEGACY_REDSTONE_BLOCK,
	LEGACY_QUARTZ_ORE,
	LEGACY_HOPPER,
	LEGACY_QUARTZ_BLOCK,
	LEGACY_QUARTZ_STAIRS,
	LEGACY_ACTIVATOR_RAIL,
	LEGACY_DROPPER,
	LEGACY_STAINED_CLAY,
	LEGACY_STAINED_GLASS_PANE,
	LEGACY_LEAVES_2,
	LEGACY_LOG_2,
	LEGACY_ACACIA_STAIRS,
	LEGACY_DARK_OAK_STAIRS,
	LEGACY_SLIME_BLOCK,
	LEGACY_BARRIER,
	LEGACY_IRON_TRAPDOOR,
	LEGACY_PRISMARINE,
	LEGACY_SEA_LANTERN,
	LEGACY_HAY_BLOCK,
	LEGACY_CARPET,
	LEGACY_HARD_CLAY,
	LEGACY_COAL_BLOCK,
	LEGACY_PACKED_ICE,
	LEGACY_DOUBLE_PLANT,
	LEGACY_STANDING_BANNER,
	LEGACY_WALL_BANNER,
	LEGACY_DAYLIGHT_DETECTOR_INVERTED,
	LEGACY_RED_SANDSTONE,
	LEGACY_RED_SANDSTONE_STAIRS,
	LEGACY_DOUBLE_STONE_SLAB2,
	LEGACY_STONE_SLAB2,
	LEGACY_SPRUCE_FENCE_GATE,
	LEGACY_BIRCH_FENCE_GATE,
	LEGACY_JUNGLE_FENCE_GATE,
	LEGACY_DARK_OAK_FENCE_GATE,
	LEGACY_ACACIA_FENCE_GATE,
	LEGACY_SPRUCE_FENCE,
	LEGACY_BIRCH_FENCE,
	LEGACY_JUNGLE_FENCE,
	LEGACY_DARK_OAK_FENCE,
	LEGACY_ACACIA_FENCE,
	LEGACY_SPRUCE_DOOR,
	LEGACY_BIRCH_DOOR,
	LEGACY_JUNGLE_DOOR,
	LEGACY_ACACIA_DOOR,
	LEGACY_DARK_OAK_DOOR,
	LEGACY_END_ROD,
	LEGACY_CHORUS_PLANT,
	LEGACY_CHORUS_FLOWER,
	LEGACY_PURPUR_BLOCK,
	LEGACY_PURPUR_PILLAR,
	LEGACY_PURPUR_STAIRS,
	LEGACY_PURPUR_DOUBLE_SLAB,
	LEGACY_PURPUR_SLAB,
	LEGACY_END_BRICKS,
	LEGACY_BEETROOT_BLOCK,
	LEGACY_GRASS_PATH,
	LEGACY_END_GATEWAY,
	LEGACY_COMMAND_REPEATING,
	LEGACY_COMMAND_CHAIN,
	LEGACY_FROSTED_ICE,
	LEGACY_MAGMA,
	LEGACY_NETHER_WART_BLOCK,
	LEGACY_RED_NETHER_BRICK,
	LEGACY_BONE_BLOCK,
	LEGACY_STRUCTURE_VOID,
	LEGACY_OBSERVER,
	LEGACY_WHITE_SHULKER_BOX,
	LEGACY_ORANGE_SHULKER_BOX,
	LEGACY_MAGENTA_SHULKER_BOX,
	LEGACY_LIGHT_BLUE_SHULKER_BOX,
	LEGACY_YELLOW_SHULKER_BOX,
	LEGACY_LIME_SHULKER_BOX,
	LEGACY_PINK_SHULKER_BOX,
	LEGACY_GRAY_SHULKER_BOX,
	LEGACY_SILVER_SHULKER_BOX,
	LEGACY_CYAN_SHULKER_BOX,
	LEGACY_PURPLE_SHULKER_BOX,
	LEGACY_BLUE_SHULKER_BOX,
	LEGACY_BROWN_SHULKER_BOX,
	LEGACY_GREEN_SHULKER_BOX,
	LEGACY_RED_SHULKER_BOX,
	LEGACY_BLACK_SHULKER_BOX,
	LEGACY_WHITE_GLAZED_TERRACOTTA,
	LEGACY_ORANGE_GLAZED_TERRACOTTA,
	LEGACY_MAGENTA_GLAZED_TERRACOTTA,
	LEGACY_LIGHT_BLUE_GLAZED_TERRACOTTA,
	LEGACY_YELLOW_GLAZED_TERRACOTTA,
	LEGACY_LIME_GLAZED_TERRACOTTA,
	LEGACY_PINK_GLAZED_TERRACOTTA,
	LEGACY_GRAY_GLAZED_TERRACOTTA,
	LEGACY_SILVER_GLAZED_TERRACOTTA,
	LEGACY_CYAN_GLAZED_TERRACOTTA,
	LEGACY_PURPLE_GLAZED_TERRACOTTA,
	LEGACY_BLUE_GLAZED_TERRACOTTA,
	LEGACY_BROWN_GLAZED_TERRACOTTA,
	LEGACY_GREEN_GLAZED_TERRACOTTA,
	LEGACY_RED_GLAZED_TERRACOTTA,
	LEGACY_BLACK_GLAZED_TERRACOTTA,
	LEGACY_CONCRETE,
	LEGACY_CONCRETE_POWDER,
	LEGACY_STRUCTURE_BLOCK,
	LEGACY_IRON_SPADE,
	LEGACY_IRON_PICKAXE,
	LEGACY_IRON_AXE,
	LEGACY_FLINT_AND_STEEL,
	LEGACY_APPLE,
	LEGACY_BOW,
	LEGACY_ARROW,
	LEGACY_COAL,
	LEGACY_DIAMOND,
	LEGACY_IRON_INGOT,
	LEGACY_GOLD_INGOT,
	LEGACY_IRON_SWORD,
	LEGACY_WOOD_SWORD,
	LEGACY_WOOD_SPADE,
	LEGACY_WOOD_PICKAXE,
	LEGACY_WOOD_AXE,
	LEGACY_STONE_SWORD,
	LEGACY_STONE_SPADE,
	LEGACY_STONE_PICKAXE,
	LEGACY_STONE_AXE,
	LEGACY_DIAMOND_SWORD,
	LEGACY_DIAMOND_SPADE,
	LEGACY_DIAMOND_PICKAXE,
	LEGACY_DIAMOND_AXE,
	LEGACY_STICK,
	LEGACY_BOWL,
	LEGACY_MUSHROOM_SOUP,
	LEGACY_GOLD_SWORD,
	LEGACY_GOLD_SPADE,
	LEGACY_GOLD_PICKAXE,
	LEGACY_GOLD_AXE,
	LEGACY_STRING,
	LEGACY_FEATHER,
	LEGACY_SULPHUR,
	LEGACY_WOOD_HOE,
	LEGACY_STONE_HOE,
	LEGACY_IRON_HOE,
	LEGACY_DIAMOND_HOE,
	LEGACY_GOLD_HOE,
	LEGACY_SEEDS,
	LEGACY_WHEAT,
	LEGACY_BREAD,
	LEGACY_LEATHER_HELMET,
	LEGACY_LEATHER_CHESTPLATE,
	LEGACY_LEATHER_LEGGINGS,
	LEGACY_LEATHER_BOOTS,
	LEGACY_CHAINMAIL_HELMET,
	LEGACY_CHAINMAIL_CHESTPLATE,
	LEGACY_CHAINMAIL_LEGGINGS,
	LEGACY_CHAINMAIL_BOOTS,
	LEGACY_IRON_HELMET,
	LEGACY_IRON_CHESTPLATE,
	LEGACY_IRON_LEGGINGS,
	LEGACY_IRON_BOOTS,
	LEGACY_DIAMOND_HELMET,
	LEGACY_DIAMOND_CHESTPLATE,
	LEGACY_DIAMOND_LEGGINGS,
	LEGACY_DIAMOND_BOOTS,
	LEGACY_GOLD_HELMET,
	LEGACY_GOLD_CHESTPLATE,
	LEGACY_GOLD_LEGGINGS,
	LEGACY_GOLD_BOOTS,
	LEGACY_FLINT,
	LEGACY_PORK,
	LEGACY_GRILLED_PORK,
	LEGACY_PAINTING,
	LEGACY_GOLDEN_APPLE,
	LEGACY_SIGN,
	LEGACY_WOOD_DOOR,
	LEGACY_BUCKET,
	LEGACY_WATER_BUCKET,
	LEGACY_LAVA_BUCKET,
	LEGACY_MINECART,
	LEGACY_SADDLE,
	LEGACY_IRON_DOOR,
	LEGACY_REDSTONE,
	LEGACY_SNOW_BALL,
	LEGACY_BOAT,
	LEGACY_LEATHER,
	LEGACY_MILK_BUCKET,
	LEGACY_CLAY_BRICK,
	LEGACY_CLAY_BALL,
	LEGACY_SUGAR_CANE,
	LEGACY_PAPER,
	LEGACY_BOOK,
	LEGACY_SLIME_BALL,
	LEGACY_STORAGE_MINECART,
	LEGACY_POWERED_MINECART,
	LEGACY_EGG,
	LEGACY_COMPASS,
	LEGACY_FISHING_ROD,
	LEGACY_WATCH,
	LEGACY_GLOWSTONE_DUST,
	LEGACY_RAW_FISH,
	LEGACY_COOKED_FISH,
	LEGACY_INK_SACK,
	LEGACY_BONE,
	LEGACY_SUGAR,
	LEGACY_CAKE,
	LEGACY_BED,
	LEGACY_DIODE,
	LEGACY_COOKIE,
	LEGACY_MAP,
	LEGACY_SHEARS,
	LEGACY_MELON,
	LEGACY_PUMPKIN_SEEDS,
	LEGACY_MELON_SEEDS,
	LEGACY_RAW_BEEF,
	LEGACY_COOKED_BEEF,
	LEGACY_RAW_CHICKEN,
	LEGACY_COOKED_CHICKEN,
	LEGACY_ROTTEN_FLESH,
	LEGACY_ENDER_PEARL,
	LEGACY_BLAZE_ROD,
	LEGACY_GHAST_TEAR,
	LEGACY_GOLD_NUGGET,
	LEGACY_NETHER_STALK,
	LEGACY_POTION,
	LEGACY_GLASS_BOTTLE,
	LEGACY_SPIDER_EYE,
	LEGACY_FERMENTED_SPIDER_EYE,
	LEGACY_BLAZE_POWDER,
	LEGACY_MAGMA_CREAM,
	LEGACY_BREWING_STAND_ITEM,
	LEGACY_CAULDRON_ITEM,
	LEGACY_EYE_OF_ENDER,
	LEGACY_SPECKLED_MELON,
	LEGACY_MONSTER_EGG,
	LEGACY_EXP_BOTTLE,
	LEGACY_FIREBALL,
	LEGACY_BOOK_AND_QUILL,
	LEGACY_WRITTEN_BOOK,
	LEGACY_EMERALD,
	LEGACY_ITEM_FRAME,
	LEGACY_FLOWER_POT_ITEM,
	LEGACY_CARROT_ITEM,
	LEGACY_POTATO_ITEM,
	LEGACY_BAKED_POTATO,
	LEGACY_POISONOUS_POTATO,
	LEGACY_EMPTY_MAP,
	LEGACY_GOLDEN_CARROT,
	LEGACY_SKULL_ITEM,
	LEGACY_CARROT_STICK,
	LEGACY_NETHER_STAR,
	LEGACY_PUMPKIN_PIE,
	LEGACY_FIREWORK,
	LEGACY_FIREWORK_CHARGE,
	LEGACY_ENCHANTED_BOOK,
	LEGACY_REDSTONE_COMPARATOR,
	LEGACY_NETHER_BRICK_ITEM,
	LEGACY_QUARTZ,
	LEGACY_EXPLOSIVE_MINECART,
	LEGACY_HOPPER_MINECART,
	LEGACY_PRISMARINE_SHARD,
	LEGACY_PRISMARINE_CRYSTALS,
	LEGACY_RABBIT,
	LEGACY_COOKED_RABBIT,
	LEGACY_RABBIT_STEW,
	LEGACY_RABBIT_FOOT,
	LEGACY_RABBIT_HIDE,
	LEGACY_ARMOR_STAND,
	LEGACY_IRON_BARDING,
	LEGACY_GOLD_BARDING,
	LEGACY_DIAMOND_BARDING,
	LEGACY_LEASH,
	LEGACY_NAME_TAG,
	LEGACY_COMMAND_MINECART,
	LEGACY_MUTTON,
	LEGACY_COOKED_MUTTON,
	LEGACY_BANNER,
	LEGACY_END_CRYSTAL,
	LEGACY_SPRUCE_DOOR_ITEM,
	LEGACY_BIRCH_DOOR_ITEM,
	LEGACY_JUNGLE_DOOR_ITEM,
	LEGACY_ACACIA_DOOR_ITEM,
	LEGACY_DARK_OAK_DOOR_ITEM,
	LEGACY_CHORUS_FRUIT,
	LEGACY_CHORUS_FRUIT_POPPED,
	LEGACY_BEETROOT,
	LEGACY_BEETROOT_SEEDS,
	LEGACY_BEETROOT_SOUP,
	LEGACY_DRAGONS_BREATH,
	LEGACY_SPLASH_POTION,
	LEGACY_SPECTRAL_ARROW,
	LEGACY_TIPPED_ARROW,
	LEGACY_LINGERING_POTION,
	LEGACY_SHIELD,
	LEGACY_ELYTRA,
	LEGACY_BOAT_SPRUCE,
	LEGACY_BOAT_BIRCH,
	LEGACY_BOAT_JUNGLE,
	LEGACY_BOAT_ACACIA,
	LEGACY_BOAT_DARK_OAK,
	LEGACY_TOTEM,
	LEGACY_SHULKER_SHELL,
	LEGACY_IRON_NUGGET,
	LEGACY_KNOWLEDGE_BOOK,
	LEGACY_GOLD_RECORD,
	LEGACY_GREEN_RECORD,
	LEGACY_RECORD_3,
	LEGACY_RECORD_4,
	LEGACY_RECORD_5,
	LEGACY_RECORD_6,
	LEGACY_RECORD_7,
	LEGACY_RECORD_8,
	LEGACY_RECORD_9,
	LEGACY_RECORD_10,
	LEGACY_RECORD_11,
	LEGACY_RECORD_12,
}
namespace Material {
	function getMaxStackSize(): int
	function getMaxDurability(): short
	function matchMaterial(arg0: String, arg1: boolean): Material
	function matchMaterial(arg0: String): Material
	function isTransparent(): boolean
	function isFlammable(): boolean
	function isOccluding(): boolean
	function isInteractable(): boolean
	function getHardness(): float
	function getBlastResistance(): float
	function getSlipperiness(): float
	function getCraftingRemainingItem(): Material
	function getEquipmentSlot(): EquipmentSlot
	function getMaterial(arg0: String): Material
	function getMaterial(arg0: String, arg1: boolean): Material
	function createBlockData(arg0: Consumer): BlockData
	function createBlockData(arg0: String): BlockData
	function createBlockData(): BlockData
	function hasGravity(): boolean
	function getData(): Class
	function isLegacy(): boolean
	function getNewData(arg0: byte): MaterialData
	function isBlock(): boolean
	function isEdible(): boolean
	function isSolid(): boolean
	function isAir(): boolean
	function isBurnable(): boolean
	function isFuel(): boolean
	function isItem(): boolean
	function values(): Material[]
	function valueOf(arg0: String): Material
	function isRecord(): boolean
	function getKey(): NamespacedKey
	function getId(): int
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum RegainReason {
	REGEN,
	SATIATED,
	EATING,
	ENDER_CRYSTAL,
	MAGIC,
	MAGIC_REGEN,
	WITHER_SPAWN,
	WITHER,
	CUSTOM,
}
namespace RegainReason {
	function values(): RegainReason[]
	function valueOf(arg0: String): RegainReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Tilt {
	NONE,
	UNSTABLE,
	PARTIAL,
	FULL,
}
namespace Tilt {
	function values(): Tilt[]
	function valueOf(arg0: String): Tilt
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Axis {
	X,
	Y,
	Z,
}
namespace Axis {
	function values(): Axis[]
	function valueOf(arg0: String): Axis
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum MushroomBlockTexture {
	ALL_PORES,
	CAP_NORTH_WEST,
	CAP_NORTH,
	CAP_NORTH_EAST,
	CAP_WEST,
	CAP_TOP,
	CAP_EAST,
	CAP_SOUTH_WEST,
	CAP_SOUTH,
	CAP_SOUTH_EAST,
	STEM_SIDES,
	ALL_CAP,
	ALL_STEM,
}
namespace MushroomBlockTexture {
	function getCapByFace(arg0: BlockFace): MushroomBlockTexture
	function getData(): byte
	function getByData(arg0: byte): MushroomBlockTexture
	function getCapFace(): BlockFace
	function values(): MushroomBlockTexture[]
	function valueOf(arg0: String): MushroomBlockTexture
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PistonMoveReaction {
	MOVE,
	BREAK,
	BLOCK,
	IGNORE,
	PUSH_ONLY,
}
namespace PistonMoveReaction {
	function getById(arg0: int): PistonMoveReaction
	function values(): PistonMoveReaction[]
	function valueOf(arg0: String): PistonMoveReaction
	function getId(): int
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum SkullType {
	SKELETON,
	WITHER,
	ZOMBIE,
	PLAYER,
	CREEPER,
	DRAGON,
}
namespace SkullType {
	function values(): SkullType[]
	function valueOf(arg0: String): SkullType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum IgniteCause {
	LAVA,
	FLINT_AND_STEEL,
	SPREAD,
	LIGHTNING,
	FIREBALL,
	ENDER_CRYSTAL,
	EXPLOSION,
	ARROW,
}
namespace IgniteCause {
	function values(): IgniteCause[]
	function valueOf(arg0: String): IgniteCause
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum NameTagVisibility {
	ALWAYS,
	NEVER,
	HIDE_FOR_OTHER_TEAMS,
	HIDE_FOR_OWN_TEAM,
}
namespace NameTagVisibility {
	function values(): NameTagVisibility[]
	function valueOf(arg0: String): NameTagVisibility
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum MainHand {
	LEFT,
	RIGHT,
}
namespace MainHand {
	function values(): MainHand[]
	function valueOf(arg0: String): MainHand
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Fluid {
	WATER,
	FLOWING_WATER,
	LAVA,
	FLOWING_LAVA,
}
namespace Fluid {
	function values(): Fluid[]
	function valueOf(arg0: String): Fluid
	function getKey(): NamespacedKey
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum LoadType {
	STARTUP,
	RELOAD,
}
namespace LoadType {
	function values(): LoadType[]
	function valueOf(arg0: String): LoadType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	NAME,
	IP,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Flags {
	UTF8,
}
namespace Flags {
	function values(): Flags[]
	function valueOf(arg0: String): Flags
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum BarFlag {
	DARKEN_SKY,
	PLAY_BOSS_MUSIC,
	CREATE_FOG,
}
namespace BarFlag {
	function values(): BarFlag[]
	function valueOf(arg0: String): BarFlag
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Option {
	NAME_TAG_VISIBILITY,
	DEATH_MESSAGE_VISIBILITY,
	COLLISION_RULE,
}
namespace Option {
	function values(): Option[]
	function valueOf(arg0: String): Option
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum RenderType {
	INTEGER,
	HEARTS,
}
namespace RenderType {
	function values(): RenderType[]
	function valueOf(arg0: String): RenderType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum WarningState {
	ON,
	OFF,
	DEFAULT,
}
namespace WarningState {
	function printFor(arg0: Warning): boolean
	function value(arg0: String): WarningState
	function values(): WarningState[]
	function valueOf(arg0: String): WarningState
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Thickness {
	TIP_MERGE,
	TIP,
	FRUSTUM,
	MIDDLE,
	BASE,
}
namespace Thickness {
	function values(): Thickness[]
	function valueOf(arg0: String): Thickness
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Shape {
	STRAIGHT,
	INNER_LEFT,
	INNER_RIGHT,
	OUTER_LEFT,
	OUTER_RIGHT,
}
namespace Shape {
	function values(): Shape[]
	function valueOf(arg0: String): Shape
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Color {
	CREAMY,
	WHITE,
	BROWN,
	GRAY,
}
namespace Color {
	function values(): Color[]
	function valueOf(arg0: String): Color
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum TeleportCause {
	ENDER_PEARL,
	COMMAND,
	PLUGIN,
	NETHER_PORTAL,
	END_PORTAL,
	SPECTATE,
	END_GATEWAY,
	CHORUS_FRUIT,
	UNKNOWN,
}
namespace TeleportCause {
	function values(): TeleportCause[]
	function valueOf(arg0: String): TeleportCause
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Scale {
	CLOSEST,
	CLOSE,
	NORMAL,
	FAR,
	FARTHEST,
}
namespace Scale {
	function values(): Scale[]
	function valueOf(arg0: String): Scale
	function valueOf(arg0: byte): Scale
	function getValue(): byte
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Pattern {
	KOB,
	SUNSTREAK,
	SNOOPER,
	DASHER,
	BRINELY,
	SPOTTY,
	FLOPPER,
	STRIPEY,
	GLITTER,
	BLOCKFISH,
	BETTY,
	CLAYFISH,
}
namespace Pattern {
	function values(): Pattern[]
	function valueOf(arg0: String): Pattern
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum SkeletonType {
	NORMAL,
	WITHER,
	STRAY,
}
namespace SkeletonType {
	function values(): SkeletonType[]
	function valueOf(arg0: String): SkeletonType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Mode {
	SAVE,
	LOAD,
	CORNER,
	DATA,
}
namespace Mode {
	function values(): Mode[]
	function valueOf(arg0: String): Mode
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Profession {
	NONE,
	ARMORER,
	BUTCHER,
	CARTOGRAPHER,
	CLERIC,
	FARMER,
	FISHERMAN,
	FLETCHER,
	LEATHERWORKER,
	LIBRARIAN,
	MASON,
	NITWIT,
	SHEPHERD,
	TOOLSMITH,
	WEAPONSMITH,
}
namespace Profession {
	function values(): Profession[]
	function valueOf(arg0: String): Profession
	function getKey(): NamespacedKey
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Result {
	ALLOWED,
	KICK_FULL,
	KICK_BANNED,
	KICK_WHITELIST,
	KICK_OTHER,
}
namespace Result {
	function values(): Result[]
	function valueOf(arg0: String): Result
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum SlotType {
	RESULT,
	CRAFTING,
	ARMOR,
	CONTAINER,
	QUICKBAR,
	OUTSIDE,
	FUEL,
}
namespace SlotType {
	function values(): SlotType[]
	function valueOf(arg0: String): SlotType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Variant {
	HORSE,
	DONKEY,
	MULE,
	UNDEAD_HORSE,
	SKELETON_HORSE,
	LLAMA,
}
namespace Variant {
	function values(): Variant[]
	function valueOf(arg0: String): Variant
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum SoundCategory {
	MASTER,
	MUSIC,
	RECORDS,
	WEATHER,
	BLOCKS,
	HOSTILE,
	NEUTRAL,
	PLAYERS,
	AMBIENT,
	VOICE,
}
namespace SoundCategory {
	function values(): SoundCategory[]
	function valueOf(arg0: String): SoundCategory
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	TOP,
	BOTTOM,
	DOUBLE,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum AttachedFace {
	FLOOR,
	WALL,
	CEILING,
}
namespace AttachedFace {
	function values(): AttachedFace[]
	function valueOf(arg0: String): AttachedFace
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Status {
	SUCCESSFULLY_LOADED,
	DECLINED,
	FAILED_DOWNLOAD,
	ACCEPTED,
}
namespace Status {
	function values(): Status[]
	function valueOf(arg0: String): Status
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum TargetReason {
	TARGET_DIED,
	CLOSEST_PLAYER,
	TARGET_ATTACKED_ENTITY,
	PIG_ZOMBIE_TARGET,
	FORGOT_TARGET,
	TARGET_ATTACKED_OWNER,
	OWNER_ATTACKED_TARGET,
	RANDOM_TARGET,
	DEFEND_VILLAGE,
	TARGET_ATTACKED_NEARBY_ENTITY,
	REINFORCEMENT_TARGET,
	COLLISION,
	CUSTOM,
	CLOSEST_ENTITY,
	FOLLOW_LEADER,
	TEMPT,
	UNKNOWN,
}
namespace TargetReason {
	function values(): TargetReason[]
	function valueOf(arg0: String): TargetReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum HeightMap {
	MOTION_BLOCKING,
	MOTION_BLOCKING_NO_LEAVES,
	OCEAN_FLOOR,
	OCEAN_FLOOR_WG,
	WORLD_SURFACE,
	WORLD_SURFACE_WG,
}
namespace HeightMap {
	function values(): HeightMap[]
	function valueOf(arg0: String): HeightMap
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	UNTYPED,
	ITEM,
	BLOCK,
	ENTITY,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum CocoaPlantSize {
	SMALL,
	MEDIUM,
	LARGE,
}
namespace CocoaPlantSize {
	function values(): CocoaPlantSize[]
	function valueOf(arg0: String): CocoaPlantSize
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Gene {
	NORMAL,
	LAZY,
	WORRIED,
	PLAYFUL,
	BROWN,
	WEAK,
	AGGRESSIVE,
}
namespace Gene {
	function isRecessive(): boolean
	function values(): Gene[]
	function valueOf(arg0: String): Gene
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Spell {
	NONE,
	SUMMON,
	FANGS,
	WOLOLO,
	DISAPPEAR,
	BLINDNESS,
}
namespace Spell {
	function values(): Spell[]
	function valueOf(arg0: String): Spell
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum BedEnterResult {
	OK,
	NOT_POSSIBLE_HERE,
	NOT_POSSIBLE_NOW,
	TOO_FAR_AWAY,
	NOT_SAFE,
	OTHER_PROBLEM,
}
namespace BedEnterResult {
	function values(): BedEnterResult[]
	function valueOf(arg0: String): BedEnterResult
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum LockType {
	ADDING_OR_CHANGING,
	REMOVING_OR_CHANGING,
	ADDING,
}
namespace LockType {
	function values(): LockType[]
	function valueOf(arg0: String): LockType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum EventPriority {
	LOWEST,
	LOW,
	NORMAL,
	HIGH,
	HIGHEST,
	MONITOR,
}
namespace EventPriority {
	function values(): EventPriority[]
	function valueOf(arg0: String): EventPriority
	function getSlot(): int
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum UsageMode {
	SAVE,
	LOAD,
	CORNER,
	DATA,
}
namespace UsageMode {
	function values(): UsageMode[]
	function valueOf(arg0: String): UsageMode
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Pose {
	STANDING,
	FALL_FLYING,
	SLEEPING,
	SWIMMING,
	SPIN_ATTACK,
	SNEAKING,
	LONG_JUMPING,
	DYING,
}
namespace Pose {
	function values(): Pose[]
	function valueOf(arg0: String): Pose
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	SOUND,
	VISUAL,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum UnleashReason {
	HOLDER_GONE,
	PLAYER_UNLEASH,
	DISTANCE,
	UNKNOWN,
}
namespace UnleashReason {
	function values(): UnleashReason[]
	function valueOf(arg0: String): UnleashReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum DyeColor {
	WHITE,
	ORANGE,
	MAGENTA,
	LIGHT_BLUE,
	YELLOW,
	LIME,
	PINK,
	GRAY,
	LIGHT_GRAY,
	CYAN,
	PURPLE,
	BLUE,
	BROWN,
	GREEN,
	RED,
	BLACK,
}
namespace DyeColor {
	function getByWoolData(arg0: byte): DyeColor
	function getWoolData(): byte
	function getByDyeData(arg0: byte): DyeColor
	function legacyValueOf(arg0: String): DyeColor
	function getFireworkColor(): Color
	function getByFireworkColor(arg0: Color): DyeColor
	function getColor(): Color
	function getDyeData(): byte
	function getByColor(arg0: Color): DyeColor
	function values(): DyeColor[]
	function valueOf(arg0: String): DyeColor
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ItemFlag {
	HIDE_ENCHANTS,
	HIDE_ATTRIBUTES,
	HIDE_UNBREAKABLE,
	HIDE_DESTROYS,
	HIDE_PLACED_ON,
	HIDE_POTION_EFFECTS,
	HIDE_DYE,
}
namespace ItemFlag {
	function values(): ItemFlag[]
	function valueOf(arg0: String): ItemFlag
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PortalType {
	NETHER,
	ENDER,
	CUSTOM,
}
namespace PortalType {
	function values(): PortalType[]
	function valueOf(arg0: String): PortalType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum EntityEffect {
	ARROW_PARTICLES,
	RABBIT_JUMP,
	HURT,
	DEATH,
	WOLF_SMOKE,
	WOLF_HEARTS,
	WOLF_SHAKE,
	SHEEP_EAT,
	IRON_GOLEM_ROSE,
	VILLAGER_HEART,
	VILLAGER_ANGRY,
	VILLAGER_HAPPY,
	WITCH_MAGIC,
	ZOMBIE_TRANSFORM,
	FIREWORK_EXPLODE,
	LOVE_HEARTS,
	SQUID_ROTATE,
	ENTITY_POOF,
	GUARDIAN_TARGET,
	SHIELD_BLOCK,
	SHIELD_BREAK,
	ARMOR_STAND_HIT,
	THORNS_HURT,
	IRON_GOLEM_SHEATH,
	TOTEM_RESURRECT,
	HURT_DROWN,
	HURT_EXPLOSION,
	DOLPHIN_FED,
	RAVAGER_STUNNED,
	CAT_TAME_FAIL,
	CAT_TAME_SUCCESS,
	VILLAGER_SPLASH,
	PLAYER_BAD_OMEN_RAID,
	HURT_BERRY_BUSH,
	FOX_CHEW,
	TELEPORT_ENDER,
	BREAK_EQUIPMENT_MAIN_HAND,
	BREAK_EQUIPMENT_OFF_HAND,
	BREAK_EQUIPMENT_HELMET,
	BREAK_EQUIPMENT_CHESTPLATE,
	BREAK_EQUIPMENT_LEGGINGS,
	BREAK_EQUIPMENT_BOOTS,
}
namespace EntityEffect {
	function getApplicable(): Class
	function getData(): byte
	function values(): EntityEffect[]
	function valueOf(arg0: String): EntityEffect
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Hinge {
	LEFT,
	RIGHT,
}
namespace Hinge {
	function values(): Hinge[]
	function valueOf(arg0: String): Hinge
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PluginChannelDirection {
	INCOMING,
	OUTGOING,
}
namespace PluginChannelDirection {
	function values(): PluginChannelDirection[]
	function valueOf(arg0: String): PluginChannelDirection
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ConversationState {
	UNSTARTED,
	STARTED,
	ABANDONED,
}
namespace ConversationState {
	function values(): ConversationState[]
	function valueOf(arg0: String): ConversationState
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Half {
	TOP,
	BOTTOM,
}
namespace Half {
	function values(): Half[]
	function valueOf(arg0: String): Half
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Statistic {
	DAMAGE_DEALT,
	DAMAGE_TAKEN,
	DEATHS,
	MOB_KILLS,
	PLAYER_KILLS,
	FISH_CAUGHT,
	ANIMALS_BRED,
	LEAVE_GAME,
	JUMP,
	DROP_COUNT,
	DROP,
	PICKUP,
	PLAY_ONE_MINUTE,
	TOTAL_WORLD_TIME,
	WALK_ONE_CM,
	WALK_ON_WATER_ONE_CM,
	FALL_ONE_CM,
	SNEAK_TIME,
	CLIMB_ONE_CM,
	FLY_ONE_CM,
	WALK_UNDER_WATER_ONE_CM,
	MINECART_ONE_CM,
	BOAT_ONE_CM,
	PIG_ONE_CM,
	HORSE_ONE_CM,
	SPRINT_ONE_CM,
	CROUCH_ONE_CM,
	AVIATE_ONE_CM,
	MINE_BLOCK,
	USE_ITEM,
	BREAK_ITEM,
	CRAFT_ITEM,
	KILL_ENTITY,
	ENTITY_KILLED_BY,
	TIME_SINCE_DEATH,
	TALKED_TO_VILLAGER,
	TRADED_WITH_VILLAGER,
	CAKE_SLICES_EATEN,
	CAULDRON_FILLED,
	CAULDRON_USED,
	ARMOR_CLEANED,
	BANNER_CLEANED,
	BREWINGSTAND_INTERACTION,
	BEACON_INTERACTION,
	DROPPER_INSPECTED,
	HOPPER_INSPECTED,
	DISPENSER_INSPECTED,
	NOTEBLOCK_PLAYED,
	NOTEBLOCK_TUNED,
	FLOWER_POTTED,
	TRAPPED_CHEST_TRIGGERED,
	ENDERCHEST_OPENED,
	ITEM_ENCHANTED,
	RECORD_PLAYED,
	FURNACE_INTERACTION,
	CRAFTING_TABLE_INTERACTION,
	CHEST_OPENED,
	SLEEP_IN_BED,
	SHULKER_BOX_OPENED,
	TIME_SINCE_REST,
	SWIM_ONE_CM,
	DAMAGE_DEALT_ABSORBED,
	DAMAGE_DEALT_RESISTED,
	DAMAGE_BLOCKED_BY_SHIELD,
	DAMAGE_ABSORBED,
	DAMAGE_RESISTED,
	CLEAN_SHULKER_BOX,
	OPEN_BARREL,
	INTERACT_WITH_BLAST_FURNACE,
	INTERACT_WITH_SMOKER,
	INTERACT_WITH_LECTERN,
	INTERACT_WITH_CAMPFIRE,
	INTERACT_WITH_CARTOGRAPHY_TABLE,
	INTERACT_WITH_LOOM,
	INTERACT_WITH_STONECUTTER,
	BELL_RING,
	RAID_TRIGGER,
	RAID_WIN,
	INTERACT_WITH_ANVIL,
	INTERACT_WITH_GRINDSTONE,
	TARGET_HIT,
	INTERACT_WITH_SMITHING_TABLE,
	STRIDER_ONE_CM,
}
namespace Statistic {
	function isSubstatistic(): boolean
	function isBlock(): boolean
	function values(): Statistic[]
	function valueOf(arg0: String): Statistic
	function getKey(): NamespacedKey
	function getType(): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum NetherWartsState {
	SEEDED,
	STAGE_ONE,
	STAGE_TWO,
	RIPE,
}
namespace NetherWartsState {
	function values(): NetherWartsState[]
	function valueOf(arg0: String): NetherWartsState
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum CropState {
	SEEDED,
	GERMINATED,
	VERY_SMALL,
	SMALL,
	MEDIUM,
	TALL,
	VERY_TALL,
	RIPE,
}
namespace CropState {
	function getData(): byte
	function getByData(arg0: byte): CropState
	function values(): CropState[]
	function valueOf(arg0: String): CropState
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Environment {
	NORMAL,
	NETHER,
	THE_END,
	CUSTOM,
}
namespace Environment {
	function getEnvironment(arg0: int): Environment
	function values(): Environment[]
	function valueOf(arg0: String): Environment
	function getId(): int
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Spell {
	NONE,
	SUMMON_VEX,
	FANGS,
	WOLOLO,
	DISAPPEAR,
	BLINDNESS,
}
namespace Spell {
	function values(): Spell[]
	function valueOf(arg0: String): Spell
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Art {
	KEBAB,
	AZTEC,
	ALBAN,
	AZTEC2,
	BOMB,
	PLANT,
	WASTELAND,
	POOL,
	COURBET,
	SEA,
	SUNSET,
	CREEBET,
	WANDERER,
	GRAHAM,
	MATCH,
	BUST,
	STAGE,
	VOID,
	SKULL_AND_ROSES,
	WITHER,
	FIGHTERS,
	POINTER,
	PIGSCENE,
	BURNING_SKULL,
	SKELETON,
	DONKEY_KONG,
}
namespace Art {
	function getBlockWidth(): int
	function getBlockHeight(): int
	function getById(arg0: int): Art
	function values(): Art[]
	function valueOf(arg0: String): Art
	function getKey(): NamespacedKey
	function getId(): int
	function getByName(arg0: String): Art
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum BlockFace {
	NORTH,
	EAST,
	SOUTH,
	WEST,
	UP,
	DOWN,
	NORTH_EAST,
	NORTH_WEST,
	SOUTH_EAST,
	SOUTH_WEST,
	WEST_NORTH_WEST,
	NORTH_NORTH_WEST,
	NORTH_NORTH_EAST,
	EAST_NORTH_EAST,
	EAST_SOUTH_EAST,
	SOUTH_SOUTH_EAST,
	SOUTH_SOUTH_WEST,
	WEST_SOUTH_WEST,
	SELF,
}
namespace BlockFace {
	function getDirection(): Vector
	function getOppositeFace(): BlockFace
	function isCartesian(): boolean
	function getModX(): int
	function getModY(): int
	function getModZ(): int
	function values(): BlockFace[]
	function valueOf(arg0: String): BlockFace
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PlayerAnimationType {
	ARM_SWING,
}
namespace PlayerAnimationType {
	function values(): PlayerAnimationType[]
	function valueOf(arg0: String): PlayerAnimationType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PluginLoadOrder {
	STARTUP,
	POSTWORLD,
}
namespace PluginLoadOrder {
	function values(): PluginLoadOrder[]
	function valueOf(arg0: String): PluginLoadOrder
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PowerCause {
	LIGHTNING,
	SET_ON,
	SET_OFF,
}
namespace PowerCause {
	function values(): PowerCause[]
	function valueOf(arg0: String): PowerCause
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Biome {
	OCEAN,
	PLAINS,
	DESERT,
	MOUNTAINS,
	FOREST,
	TAIGA,
	SWAMP,
	RIVER,
	NETHER_WASTES,
	THE_END,
	FROZEN_OCEAN,
	FROZEN_RIVER,
	SNOWY_TUNDRA,
	SNOWY_MOUNTAINS,
	MUSHROOM_FIELDS,
	MUSHROOM_FIELD_SHORE,
	BEACH,
	DESERT_HILLS,
	WOODED_HILLS,
	TAIGA_HILLS,
	MOUNTAIN_EDGE,
	JUNGLE,
	JUNGLE_HILLS,
	JUNGLE_EDGE,
	DEEP_OCEAN,
	STONE_SHORE,
	SNOWY_BEACH,
	BIRCH_FOREST,
	BIRCH_FOREST_HILLS,
	DARK_FOREST,
	SNOWY_TAIGA,
	SNOWY_TAIGA_HILLS,
	GIANT_TREE_TAIGA,
	GIANT_TREE_TAIGA_HILLS,
	WOODED_MOUNTAINS,
	SAVANNA,
	SAVANNA_PLATEAU,
	BADLANDS,
	WOODED_BADLANDS_PLATEAU,
	BADLANDS_PLATEAU,
	SMALL_END_ISLANDS,
	END_MIDLANDS,
	END_HIGHLANDS,
	END_BARRENS,
	WARM_OCEAN,
	LUKEWARM_OCEAN,
	COLD_OCEAN,
	DEEP_WARM_OCEAN,
	DEEP_LUKEWARM_OCEAN,
	DEEP_COLD_OCEAN,
	DEEP_FROZEN_OCEAN,
	THE_VOID,
	SUNFLOWER_PLAINS,
	DESERT_LAKES,
	GRAVELLY_MOUNTAINS,
	FLOWER_FOREST,
	TAIGA_MOUNTAINS,
	SWAMP_HILLS,
	ICE_SPIKES,
	MODIFIED_JUNGLE,
	MODIFIED_JUNGLE_EDGE,
	TALL_BIRCH_FOREST,
	TALL_BIRCH_HILLS,
	DARK_FOREST_HILLS,
	SNOWY_TAIGA_MOUNTAINS,
	GIANT_SPRUCE_TAIGA,
	GIANT_SPRUCE_TAIGA_HILLS,
	MODIFIED_GRAVELLY_MOUNTAINS,
	SHATTERED_SAVANNA,
	SHATTERED_SAVANNA_PLATEAU,
	ERODED_BADLANDS,
	MODIFIED_WOODED_BADLANDS_PLATEAU,
	MODIFIED_BADLANDS_PLATEAU,
	BAMBOO_JUNGLE,
	BAMBOO_JUNGLE_HILLS,
	SOUL_SAND_VALLEY,
	CRIMSON_FOREST,
	WARPED_FOREST,
	BASALT_DELTAS,
	DRIPSTONE_CAVES,
	LUSH_CAVES,
	CUSTOM,
}
namespace Biome {
	function values(): Biome[]
	function valueOf(arg0: String): Biome
	function getKey(): NamespacedKey
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum CoalType {
	COAL,
	CHARCOAL,
}
namespace CoalType {
	function getData(): byte
	function getByData(arg0: byte): CoalType
	function values(): CoalType[]
	function valueOf(arg0: String): CoalType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Phase {
	CIRCLING,
	STRAFING,
	FLY_TO_PORTAL,
	LAND_ON_PORTAL,
	LEAVE_PORTAL,
	BREATH_ATTACK,
	SEARCH_FOR_BREATH_ATTACK_TARGET,
	ROAR_BEFORE_ATTACK,
	CHARGE_PLAYER,
	DYING,
	HOVER,
}
namespace Phase {
	function values(): Phase[]
	function valueOf(arg0: String): Phase
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PickupStatus {
	DISALLOWED,
	ALLOWED,
	CREATIVE_ONLY,
}
namespace PickupStatus {
	function values(): PickupStatus[]
	function valueOf(arg0: String): PickupStatus
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum RespawnPhase {
	START,
	PREPARING_TO_SUMMON_PILLARS,
	SUMMONING_PILLARS,
	SUMMONING_DRAGON,
	END,
	NONE,
}
namespace RespawnPhase {
	function values(): RespawnPhase[]
	function valueOf(arg0: String): RespawnPhase
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	SINGLE,
	LEFT,
	RIGHT,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Difficulty {
	PEACEFUL,
	EASY,
	NORMAL,
	HARD,
}
namespace Difficulty {
	function getByValue(arg0: int): Difficulty
	function values(): Difficulty[]
	function valueOf(arg0: String): Difficulty
	function getValue(): int
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	NORMAL,
	STICKY,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	DESERT,
	JUNGLE,
	PLAINS,
	SAVANNA,
	SNOW,
	SWAMP,
	TAIGA,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function getKey(): NamespacedKey
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Instrument {
	PIANO,
	BASS_DRUM,
	SNARE_DRUM,
	STICKS,
	BASS_GUITAR,
	FLUTE,
	BELL,
	GUITAR,
	CHIME,
	XYLOPHONE,
	IRON_XYLOPHONE,
	COW_BELL,
	DIDGERIDOO,
	BIT,
	BANJO,
	PLING,
}
namespace Instrument {
	function getByType(arg0: byte): Instrument
	function values(): Instrument[]
	function valueOf(arg0: String): Instrument
	function getType(): byte
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum CreateReason {
	FIRE,
	NETHER_PAIR,
	END_PLATFORM,
}
namespace CreateReason {
	function values(): CreateReason[]
	function valueOf(arg0: String): CreateReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Reason {
	PEACE,
	TIMEOUT,
	FINISHED,
	UNSPAWNABLE,
	NOT_IN_VILLAGE,
}
namespace Reason {
	function values(): Reason[]
	function valueOf(arg0: String): Reason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Part {
	HEAD,
	FOOT,
}
namespace Part {
	function values(): Part[]
	function valueOf(arg0: String): Part
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum TransformReason {
	CURED,
	INFECTION,
	DROWNED,
	SHEARED,
	LIGHTNING,
	SPLIT,
	PIGLIN_ZOMBIFIED,
	UNKNOWN,
}
namespace TransformReason {
	function values(): TransformReason[]
	function valueOf(arg0: String): TransformReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum LootTables {
	EMPTY,
	ABANDONED_MINESHAFT,
	BURIED_TREASURE,
	DESERT_PYRAMID,
	END_CITY_TREASURE,
	IGLOO_CHEST,
	JUNGLE_TEMPLE,
	JUNGLE_TEMPLE_DISPENSER,
	NETHER_BRIDGE,
	PILLAGER_OUTPOST,
	BASTION_TREASURE,
	BASTION_OTHER,
	BASTION_BRIDGE,
	BASTION_HOGLIN_STABLE,
	RUINED_PORTAL,
	SHIPWRECK_MAP,
	SHIPWRECK_SUPPLY,
	SHIPWRECK_TREASURE,
	SIMPLE_DUNGEON,
	SPAWN_BONUS_CHEST,
	STRONGHOLD_CORRIDOR,
	STRONGHOLD_CROSSING,
	STRONGHOLD_LIBRARY,
	UNDERWATER_RUIN_BIG,
	UNDERWATER_RUIN_SMALL,
	VILLAGE_ARMORER,
	VILLAGE_BUTCHER,
	VILLAGE_CARTOGRAPHER,
	VILLAGE_DESERT_HOUSE,
	VILLAGE_FISHER,
	VILLAGE_FLETCHER,
	VILLAGE_MASON,
	VILLAGE_PLAINS_HOUSE,
	VILLAGE_SAVANNA_HOUSE,
	VILLAGE_SHEPHERD,
	VILLAGE_SNOWY_HOUSE,
	VILLAGE_TAIGA_HOUSE,
	VILLAGE_TANNERY,
	VILLAGE_TEMPLE,
	VILLAGE_TOOLSMITH,
	VILLAGE_WEAPONSMITH,
	WOODLAND_MANSION,
	ARMOR_STAND,
	AXOLOTL,
	BAT,
	BEE,
	BLAZE,
	CAT,
	CAVE_SPIDER,
	CHICKEN,
	COD,
	COW,
	CREEPER,
	DOLPHIN,
	DONKEY,
	DROWNED,
	ELDER_GUARDIAN,
	ENDER_DRAGON,
	ENDERMAN,
	ENDERMITE,
	EVOKER,
	FOX,
	GHAST,
	GIANT,
	GLOW_SQUID,
	GOAT,
	GUARDIAN,
	HOGLIN,
	HORSE,
	HUSK,
	ILLUSIONER,
	IRON_GOLEM,
	LLAMA,
	MAGMA_CUBE,
	MOOSHROOM,
	MULE,
	OCELOT,
	PANDA,
	PARROT,
	PHANTOM,
	PIG,
	PIGLIN,
	PIGLIN_BRUTE,
	PILLAGER,
	PLAYER,
	POLAR_BEAR,
	PUFFERFISH,
	RABBIT,
	RAVAGER,
	SALMON,
	SHULKER,
	SILVERFISH,
	SKELETON,
	SKELETON_HORSE,
	SLIME,
	SNOW_GOLEM,
	SPIDER,
	SQUID,
	STRAY,
	STRIDER,
	TRADER_LLAMA,
	TROPICAL_FISH,
	TURTLE,
	VEX,
	VILLAGER,
	VINDICATOR,
	WANDERING_TRADER,
	WITCH,
	WITHER,
	WITHER_SKELETON,
	WOLF,
	ZOGLIN,
	ZOMBIE,
	ZOMBIE_HORSE,
	ZOMBIE_VILLAGER,
	ZOMBIFIED_PIGLIN,
	ARMORER_GIFT,
	BUTCHER_GIFT,
	CARTOGRAPHER_GIFT,
	CAT_MORNING_GIFT,
	CLERIC_GIFT,
	FARMER_GIFT,
	FISHERMAN_GIFT,
	FISHING,
	FISHING_FISH,
	FISHING_JUNK,
	FISHING_TREASURE,
	FLETCHER_GIFT,
	LEATHERWORKER_GIFT,
	LIBRARIAN_GIFT,
	MASON_GIFT,
	SHEPHERD_GIFT,
	TOOLSMITH_GIFT,
	WEAPONSMITH_GIFT,
	PIGLIN_BARTERING,
	SHEEP,
	SHEEP_BLACK,
	SHEEP_BLUE,
	SHEEP_BROWN,
	SHEEP_CYAN,
	SHEEP_GRAY,
	SHEEP_GREEN,
	SHEEP_LIGHT_BLUE,
	SHEEP_LIGHT_GRAY,
	SHEEP_LIME,
	SHEEP_MAGENTA,
	SHEEP_ORANGE,
	SHEEP_PINK,
	SHEEP_PURPLE,
	SHEEP_RED,
	SHEEP_WHITE,
	SHEEP_YELLOW,
}
namespace LootTables {
	function getLootTable(): LootTable
	function values(): LootTables[]
	function valueOf(arg0: String): LootTables
	function getKey(): NamespacedKey
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum DamageCause {
	CONTACT,
	ENTITY_ATTACK,
	ENTITY_SWEEP_ATTACK,
	PROJECTILE,
	SUFFOCATION,
	FALL,
	FIRE,
	FIRE_TICK,
	MELTING,
	LAVA,
	DROWNING,
	BLOCK_EXPLOSION,
	ENTITY_EXPLOSION,
	VOID,
	LIGHTNING,
	SUICIDE,
	STARVATION,
	POISON,
	MAGIC,
	WITHER,
	FALLING_BLOCK,
	THORNS,
	DRAGON_BREATH,
	CUSTOM,
	FLY_INTO_WALL,
	HOT_FLOOR,
	CRAMMING,
	DRYOUT,
	FREEZE,
}
namespace DamageCause {
	function values(): DamageCause[]
	function valueOf(arg0: String): DamageCause
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum SpawnReason {
	NATURAL,
	JOCKEY,
	CHUNK_GEN,
	SPAWNER,
	EGG,
	SPAWNER_EGG,
	LIGHTNING,
	BUILD_SNOWMAN,
	BUILD_IRONGOLEM,
	BUILD_WITHER,
	VILLAGE_DEFENSE,
	VILLAGE_INVASION,
	BREEDING,
	SLIME_SPLIT,
	REINFORCEMENTS,
	NETHER_PORTAL,
	DISPENSE_EGG,
	INFECTION,
	CURED,
	OCELOT_BABY,
	SILVERFISH_BLOCK,
	MOUNT,
	TRAP,
	ENDER_PEARL,
	SHOULDER_ENTITY,
	DROWNED,
	SHEARED,
	EXPLOSION,
	RAID,
	PATROL,
	BEEHIVE,
	PIGLIN_ZOMBIFIED,
	COMMAND,
	CUSTOM,
	DEFAULT,
}
namespace SpawnReason {
	function values(): SpawnReason[]
	function valueOf(arg0: String): SpawnReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ServicePriority {
	Lowest,
	Low,
	Normal,
	High,
	Highest,
}
namespace ServicePriority {
	function values(): ServicePriority[]
	function valueOf(arg0: String): ServicePriority
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Phase {
	INACTIVE,
	ACTIVE,
	COOLDOWN,
}
namespace Phase {
	function values(): Phase[]
	function valueOf(arg0: String): Phase
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ExhaustionReason {
	BLOCK_MINED,
	HUNGER_EFFECT,
	DAMAGED,
	ATTACK,
	JUMP_SPRINT,
	JUMP,
	SWIM,
	WALK_UNDERWATER,
	WALK_ON_WATER,
	SPRINT,
	CROUCH,
	WALK,
	REGEN,
	UNKNOWN,
}
namespace ExhaustionReason {
	function values(): ExhaustionReason[]
	function valueOf(arg0: String): ExhaustionReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PotionType {
	UNCRAFTABLE,
	WATER,
	MUNDANE,
	THICK,
	AWKWARD,
	NIGHT_VISION,
	INVISIBILITY,
	JUMP,
	FIRE_RESISTANCE,
	SPEED,
	SLOWNESS,
	WATER_BREATHING,
	INSTANT_HEAL,
	INSTANT_DAMAGE,
	POISON,
	REGEN,
	STRENGTH,
	WEAKNESS,
	LUCK,
	TURTLE_MASTER,
	SLOW_FALLING,
}
namespace PotionType {
	function getMaxLevel(): int
	function isUpgradeable(): boolean
	function isExtendable(): boolean
	function getByEffect(arg0: PotionEffectType): PotionType
	function getEffectType(): PotionEffectType
	function isInstant(): boolean
	function values(): PotionType[]
	function valueOf(arg0: String): PotionType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum GrassSpecies {
	DEAD,
	NORMAL,
	FERN_LIKE,
}
namespace GrassSpecies {
	function getData(): byte
	function getByData(arg0: byte): GrassSpecies
	function values(): GrassSpecies[]
	function valueOf(arg0: String): GrassSpecies
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum PermissionDefault {
	TRUE,
	FALSE,
	OP,
	NOT_OP,
}
namespace PermissionDefault {
	function toString(): String
	function values(): PermissionDefault[]
	function valueOf(arg0: String): PermissionDefault
	function getValue(arg0: boolean): boolean
	function getByName(arg0: String): PermissionDefault
	function name(): String
	function equals(arg0: Object): boolean
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Sound {
	AMBIENT_BASALT_DELTAS_ADDITIONS,
	AMBIENT_BASALT_DELTAS_LOOP,
	AMBIENT_BASALT_DELTAS_MOOD,
	AMBIENT_CAVE,
	AMBIENT_CRIMSON_FOREST_ADDITIONS,
	AMBIENT_CRIMSON_FOREST_LOOP,
	AMBIENT_CRIMSON_FOREST_MOOD,
	AMBIENT_NETHER_WASTES_ADDITIONS,
	AMBIENT_NETHER_WASTES_LOOP,
	AMBIENT_NETHER_WASTES_MOOD,
	AMBIENT_SOUL_SAND_VALLEY_ADDITIONS,
	AMBIENT_SOUL_SAND_VALLEY_LOOP,
	AMBIENT_SOUL_SAND_VALLEY_MOOD,
	AMBIENT_UNDERWATER_ENTER,
	AMBIENT_UNDERWATER_EXIT,
	AMBIENT_UNDERWATER_LOOP,
	AMBIENT_UNDERWATER_LOOP_ADDITIONS,
	AMBIENT_UNDERWATER_LOOP_ADDITIONS_RARE,
	AMBIENT_UNDERWATER_LOOP_ADDITIONS_ULTRA_RARE,
	AMBIENT_WARPED_FOREST_ADDITIONS,
	AMBIENT_WARPED_FOREST_LOOP,
	AMBIENT_WARPED_FOREST_MOOD,
	BLOCK_AMETHYST_BLOCK_BREAK,
	BLOCK_AMETHYST_BLOCK_CHIME,
	BLOCK_AMETHYST_BLOCK_FALL,
	BLOCK_AMETHYST_BLOCK_HIT,
	BLOCK_AMETHYST_BLOCK_PLACE,
	BLOCK_AMETHYST_BLOCK_STEP,
	BLOCK_AMETHYST_CLUSTER_BREAK,
	BLOCK_AMETHYST_CLUSTER_FALL,
	BLOCK_AMETHYST_CLUSTER_HIT,
	BLOCK_AMETHYST_CLUSTER_PLACE,
	BLOCK_AMETHYST_CLUSTER_STEP,
	BLOCK_ANCIENT_DEBRIS_BREAK,
	BLOCK_ANCIENT_DEBRIS_FALL,
	BLOCK_ANCIENT_DEBRIS_HIT,
	BLOCK_ANCIENT_DEBRIS_PLACE,
	BLOCK_ANCIENT_DEBRIS_STEP,
	BLOCK_ANVIL_BREAK,
	BLOCK_ANVIL_DESTROY,
	BLOCK_ANVIL_FALL,
	BLOCK_ANVIL_HIT,
	BLOCK_ANVIL_LAND,
	BLOCK_ANVIL_PLACE,
	BLOCK_ANVIL_STEP,
	BLOCK_ANVIL_USE,
	BLOCK_AZALEA_BREAK,
	BLOCK_AZALEA_FALL,
	BLOCK_AZALEA_HIT,
	BLOCK_AZALEA_LEAVES_BREAK,
	BLOCK_AZALEA_LEAVES_FALL,
	BLOCK_AZALEA_LEAVES_HIT,
	BLOCK_AZALEA_LEAVES_PLACE,
	BLOCK_AZALEA_LEAVES_STEP,
	BLOCK_AZALEA_PLACE,
	BLOCK_AZALEA_STEP,
	BLOCK_BAMBOO_BREAK,
	BLOCK_BAMBOO_FALL,
	BLOCK_BAMBOO_HIT,
	BLOCK_BAMBOO_PLACE,
	BLOCK_BAMBOO_SAPLING_BREAK,
	BLOCK_BAMBOO_SAPLING_HIT,
	BLOCK_BAMBOO_SAPLING_PLACE,
	BLOCK_BAMBOO_STEP,
	BLOCK_BARREL_CLOSE,
	BLOCK_BARREL_OPEN,
	BLOCK_BASALT_BREAK,
	BLOCK_BASALT_FALL,
	BLOCK_BASALT_HIT,
	BLOCK_BASALT_PLACE,
	BLOCK_BASALT_STEP,
	BLOCK_BEACON_ACTIVATE,
	BLOCK_BEACON_AMBIENT,
	BLOCK_BEACON_DEACTIVATE,
	BLOCK_BEACON_POWER_SELECT,
	BLOCK_BEEHIVE_DRIP,
	BLOCK_BEEHIVE_ENTER,
	BLOCK_BEEHIVE_EXIT,
	BLOCK_BEEHIVE_SHEAR,
	BLOCK_BEEHIVE_WORK,
	BLOCK_BELL_RESONATE,
	BLOCK_BELL_USE,
	BLOCK_BIG_DRIPLEAF_BREAK,
	BLOCK_BIG_DRIPLEAF_FALL,
	BLOCK_BIG_DRIPLEAF_HIT,
	BLOCK_BIG_DRIPLEAF_PLACE,
	BLOCK_BIG_DRIPLEAF_STEP,
	BLOCK_BIG_DRIPLEAF_TILT_DOWN,
	BLOCK_BIG_DRIPLEAF_TILT_UP,
	BLOCK_BLASTFURNACE_FIRE_CRACKLE,
	BLOCK_BONE_BLOCK_BREAK,
	BLOCK_BONE_BLOCK_FALL,
	BLOCK_BONE_BLOCK_HIT,
	BLOCK_BONE_BLOCK_PLACE,
	BLOCK_BONE_BLOCK_STEP,
	BLOCK_BREWING_STAND_BREW,
	BLOCK_BUBBLE_COLUMN_BUBBLE_POP,
	BLOCK_BUBBLE_COLUMN_UPWARDS_AMBIENT,
	BLOCK_BUBBLE_COLUMN_UPWARDS_INSIDE,
	BLOCK_BUBBLE_COLUMN_WHIRLPOOL_AMBIENT,
	BLOCK_BUBBLE_COLUMN_WHIRLPOOL_INSIDE,
	BLOCK_CAKE_ADD_CANDLE,
	BLOCK_CALCITE_BREAK,
	BLOCK_CALCITE_FALL,
	BLOCK_CALCITE_HIT,
	BLOCK_CALCITE_PLACE,
	BLOCK_CALCITE_STEP,
	BLOCK_CAMPFIRE_CRACKLE,
	BLOCK_CANDLE_AMBIENT,
	BLOCK_CANDLE_BREAK,
	BLOCK_CANDLE_EXTINGUISH,
	BLOCK_CANDLE_FALL,
	BLOCK_CANDLE_HIT,
	BLOCK_CANDLE_PLACE,
	BLOCK_CANDLE_STEP,
	BLOCK_CAVE_VINES_BREAK,
	BLOCK_CAVE_VINES_FALL,
	BLOCK_CAVE_VINES_HIT,
	BLOCK_CAVE_VINES_PICK_BERRIES,
	BLOCK_CAVE_VINES_PLACE,
	BLOCK_CAVE_VINES_STEP,
	BLOCK_CHAIN_BREAK,
	BLOCK_CHAIN_FALL,
	BLOCK_CHAIN_HIT,
	BLOCK_CHAIN_PLACE,
	BLOCK_CHAIN_STEP,
	BLOCK_CHEST_CLOSE,
	BLOCK_CHEST_LOCKED,
	BLOCK_CHEST_OPEN,
	BLOCK_CHORUS_FLOWER_DEATH,
	BLOCK_CHORUS_FLOWER_GROW,
	BLOCK_COMPARATOR_CLICK,
	BLOCK_COMPOSTER_EMPTY,
	BLOCK_COMPOSTER_FILL,
	BLOCK_COMPOSTER_FILL_SUCCESS,
	BLOCK_COMPOSTER_READY,
	BLOCK_CONDUIT_ACTIVATE,
	BLOCK_CONDUIT_AMBIENT,
	BLOCK_CONDUIT_AMBIENT_SHORT,
	BLOCK_CONDUIT_ATTACK_TARGET,
	BLOCK_CONDUIT_DEACTIVATE,
	BLOCK_COPPER_BREAK,
	BLOCK_COPPER_FALL,
	BLOCK_COPPER_HIT,
	BLOCK_COPPER_PLACE,
	BLOCK_COPPER_STEP,
	BLOCK_CORAL_BLOCK_BREAK,
	BLOCK_CORAL_BLOCK_FALL,
	BLOCK_CORAL_BLOCK_HIT,
	BLOCK_CORAL_BLOCK_PLACE,
	BLOCK_CORAL_BLOCK_STEP,
	BLOCK_CROP_BREAK,
	BLOCK_DEEPSLATE_BREAK,
	BLOCK_DEEPSLATE_BRICKS_BREAK,
	BLOCK_DEEPSLATE_BRICKS_FALL,
	BLOCK_DEEPSLATE_BRICKS_HIT,
	BLOCK_DEEPSLATE_BRICKS_PLACE,
	BLOCK_DEEPSLATE_BRICKS_STEP,
	BLOCK_DEEPSLATE_FALL,
	BLOCK_DEEPSLATE_HIT,
	BLOCK_DEEPSLATE_PLACE,
	BLOCK_DEEPSLATE_STEP,
	BLOCK_DEEPSLATE_TILES_BREAK,
	BLOCK_DEEPSLATE_TILES_FALL,
	BLOCK_DEEPSLATE_TILES_HIT,
	BLOCK_DEEPSLATE_TILES_PLACE,
	BLOCK_DEEPSLATE_TILES_STEP,
	BLOCK_DISPENSER_DISPENSE,
	BLOCK_DISPENSER_FAIL,
	BLOCK_DISPENSER_LAUNCH,
	BLOCK_DRIPSTONE_BLOCK_BREAK,
	BLOCK_DRIPSTONE_BLOCK_FALL,
	BLOCK_DRIPSTONE_BLOCK_HIT,
	BLOCK_DRIPSTONE_BLOCK_PLACE,
	BLOCK_DRIPSTONE_BLOCK_STEP,
	BLOCK_ENCHANTMENT_TABLE_USE,
	BLOCK_ENDER_CHEST_CLOSE,
	BLOCK_ENDER_CHEST_OPEN,
	BLOCK_END_GATEWAY_SPAWN,
	BLOCK_END_PORTAL_FRAME_FILL,
	BLOCK_END_PORTAL_SPAWN,
	BLOCK_FENCE_GATE_CLOSE,
	BLOCK_FENCE_GATE_OPEN,
	BLOCK_FIRE_AMBIENT,
	BLOCK_FIRE_EXTINGUISH,
	BLOCK_FLOWERING_AZALEA_BREAK,
	BLOCK_FLOWERING_AZALEA_FALL,
	BLOCK_FLOWERING_AZALEA_HIT,
	BLOCK_FLOWERING_AZALEA_PLACE,
	BLOCK_FLOWERING_AZALEA_STEP,
	BLOCK_FUNGUS_BREAK,
	BLOCK_FUNGUS_FALL,
	BLOCK_FUNGUS_HIT,
	BLOCK_FUNGUS_PLACE,
	BLOCK_FUNGUS_STEP,
	BLOCK_FURNACE_FIRE_CRACKLE,
	BLOCK_GILDED_BLACKSTONE_BREAK,
	BLOCK_GILDED_BLACKSTONE_FALL,
	BLOCK_GILDED_BLACKSTONE_HIT,
	BLOCK_GILDED_BLACKSTONE_PLACE,
	BLOCK_GILDED_BLACKSTONE_STEP,
	BLOCK_GLASS_BREAK,
	BLOCK_GLASS_FALL,
	BLOCK_GLASS_HIT,
	BLOCK_GLASS_PLACE,
	BLOCK_GLASS_STEP,
	BLOCK_GRASS_BREAK,
	BLOCK_GRASS_FALL,
	BLOCK_GRASS_HIT,
	BLOCK_GRASS_PLACE,
	BLOCK_GRASS_STEP,
	BLOCK_GRAVEL_BREAK,
	BLOCK_GRAVEL_FALL,
	BLOCK_GRAVEL_HIT,
	BLOCK_GRAVEL_PLACE,
	BLOCK_GRAVEL_STEP,
	BLOCK_GRINDSTONE_USE,
	BLOCK_HANGING_ROOTS_BREAK,
	BLOCK_HANGING_ROOTS_FALL,
	BLOCK_HANGING_ROOTS_HIT,
	BLOCK_HANGING_ROOTS_PLACE,
	BLOCK_HANGING_ROOTS_STEP,
	BLOCK_HONEY_BLOCK_BREAK,
	BLOCK_HONEY_BLOCK_FALL,
	BLOCK_HONEY_BLOCK_HIT,
	BLOCK_HONEY_BLOCK_PLACE,
	BLOCK_HONEY_BLOCK_SLIDE,
	BLOCK_HONEY_BLOCK_STEP,
	BLOCK_IRON_DOOR_CLOSE,
	BLOCK_IRON_DOOR_OPEN,
	BLOCK_IRON_TRAPDOOR_CLOSE,
	BLOCK_IRON_TRAPDOOR_OPEN,
	BLOCK_LADDER_BREAK,
	BLOCK_LADDER_FALL,
	BLOCK_LADDER_HIT,
	BLOCK_LADDER_PLACE,
	BLOCK_LADDER_STEP,
	BLOCK_LANTERN_BREAK,
	BLOCK_LANTERN_FALL,
	BLOCK_LANTERN_HIT,
	BLOCK_LANTERN_PLACE,
	BLOCK_LANTERN_STEP,
	BLOCK_LARGE_AMETHYST_BUD_BREAK,
	BLOCK_LARGE_AMETHYST_BUD_PLACE,
	BLOCK_LAVA_AMBIENT,
	BLOCK_LAVA_EXTINGUISH,
	BLOCK_LAVA_POP,
	BLOCK_LEVER_CLICK,
	BLOCK_LILY_PAD_PLACE,
	BLOCK_LODESTONE_BREAK,
	BLOCK_LODESTONE_FALL,
	BLOCK_LODESTONE_HIT,
	BLOCK_LODESTONE_PLACE,
	BLOCK_LODESTONE_STEP,
	BLOCK_MEDIUM_AMETHYST_BUD_BREAK,
	BLOCK_MEDIUM_AMETHYST_BUD_PLACE,
	BLOCK_METAL_BREAK,
	BLOCK_METAL_FALL,
	BLOCK_METAL_HIT,
	BLOCK_METAL_PLACE,
	BLOCK_METAL_PRESSURE_PLATE_CLICK_OFF,
	BLOCK_METAL_PRESSURE_PLATE_CLICK_ON,
	BLOCK_METAL_STEP,
	BLOCK_MOSS_BREAK,
	BLOCK_MOSS_CARPET_BREAK,
	BLOCK_MOSS_CARPET_FALL,
	BLOCK_MOSS_CARPET_HIT,
	BLOCK_MOSS_CARPET_PLACE,
	BLOCK_MOSS_CARPET_STEP,
	BLOCK_MOSS_FALL,
	BLOCK_MOSS_HIT,
	BLOCK_MOSS_PLACE,
	BLOCK_MOSS_STEP,
	BLOCK_NETHERITE_BLOCK_BREAK,
	BLOCK_NETHERITE_BLOCK_FALL,
	BLOCK_NETHERITE_BLOCK_HIT,
	BLOCK_NETHERITE_BLOCK_PLACE,
	BLOCK_NETHERITE_BLOCK_STEP,
	BLOCK_NETHERRACK_BREAK,
	BLOCK_NETHERRACK_FALL,
	BLOCK_NETHERRACK_HIT,
	BLOCK_NETHERRACK_PLACE,
	BLOCK_NETHERRACK_STEP,
	BLOCK_NETHER_BRICKS_BREAK,
	BLOCK_NETHER_BRICKS_FALL,
	BLOCK_NETHER_BRICKS_HIT,
	BLOCK_NETHER_BRICKS_PLACE,
	BLOCK_NETHER_BRICKS_STEP,
	BLOCK_NETHER_GOLD_ORE_BREAK,
	BLOCK_NETHER_GOLD_ORE_FALL,
	BLOCK_NETHER_GOLD_ORE_HIT,
	BLOCK_NETHER_GOLD_ORE_PLACE,
	BLOCK_NETHER_GOLD_ORE_STEP,
	BLOCK_NETHER_ORE_BREAK,
	BLOCK_NETHER_ORE_FALL,
	BLOCK_NETHER_ORE_HIT,
	BLOCK_NETHER_ORE_PLACE,
	BLOCK_NETHER_ORE_STEP,
	BLOCK_NETHER_SPROUTS_BREAK,
	BLOCK_NETHER_SPROUTS_FALL,
	BLOCK_NETHER_SPROUTS_HIT,
	BLOCK_NETHER_SPROUTS_PLACE,
	BLOCK_NETHER_SPROUTS_STEP,
	BLOCK_NETHER_WART_BREAK,
	BLOCK_NOTE_BLOCK_BANJO,
	BLOCK_NOTE_BLOCK_BASEDRUM,
	BLOCK_NOTE_BLOCK_BASS,
	BLOCK_NOTE_BLOCK_BELL,
	BLOCK_NOTE_BLOCK_BIT,
	BLOCK_NOTE_BLOCK_CHIME,
	BLOCK_NOTE_BLOCK_COW_BELL,
	BLOCK_NOTE_BLOCK_DIDGERIDOO,
	BLOCK_NOTE_BLOCK_FLUTE,
	BLOCK_NOTE_BLOCK_GUITAR,
	BLOCK_NOTE_BLOCK_HARP,
	BLOCK_NOTE_BLOCK_HAT,
	BLOCK_NOTE_BLOCK_IRON_XYLOPHONE,
	BLOCK_NOTE_BLOCK_PLING,
	BLOCK_NOTE_BLOCK_SNARE,
	BLOCK_NOTE_BLOCK_XYLOPHONE,
	BLOCK_NYLIUM_BREAK,
	BLOCK_NYLIUM_FALL,
	BLOCK_NYLIUM_HIT,
	BLOCK_NYLIUM_PLACE,
	BLOCK_NYLIUM_STEP,
	BLOCK_PISTON_CONTRACT,
	BLOCK_PISTON_EXTEND,
	BLOCK_POINTED_DRIPSTONE_BREAK,
	BLOCK_POINTED_DRIPSTONE_DRIP_LAVA,
	BLOCK_POINTED_DRIPSTONE_DRIP_LAVA_INTO_CAULDRON,
	BLOCK_POINTED_DRIPSTONE_DRIP_WATER,
	BLOCK_POINTED_DRIPSTONE_DRIP_WATER_INTO_CAULDRON,
	BLOCK_POINTED_DRIPSTONE_FALL,
	BLOCK_POINTED_DRIPSTONE_HIT,
	BLOCK_POINTED_DRIPSTONE_LAND,
	BLOCK_POINTED_DRIPSTONE_PLACE,
	BLOCK_POINTED_DRIPSTONE_STEP,
	BLOCK_POLISHED_DEEPSLATE_BREAK,
	BLOCK_POLISHED_DEEPSLATE_FALL,
	BLOCK_POLISHED_DEEPSLATE_HIT,
	BLOCK_POLISHED_DEEPSLATE_PLACE,
	BLOCK_POLISHED_DEEPSLATE_STEP,
	BLOCK_PORTAL_AMBIENT,
	BLOCK_PORTAL_TRAVEL,
	BLOCK_PORTAL_TRIGGER,
	BLOCK_POWDER_SNOW_BREAK,
	BLOCK_POWDER_SNOW_FALL,
	BLOCK_POWDER_SNOW_HIT,
	BLOCK_POWDER_SNOW_PLACE,
	BLOCK_POWDER_SNOW_STEP,
	BLOCK_PUMPKIN_CARVE,
	BLOCK_REDSTONE_TORCH_BURNOUT,
	BLOCK_RESPAWN_ANCHOR_AMBIENT,
	BLOCK_RESPAWN_ANCHOR_CHARGE,
	BLOCK_RESPAWN_ANCHOR_DEPLETE,
	BLOCK_RESPAWN_ANCHOR_SET_SPAWN,
	BLOCK_ROOTED_DIRT_BREAK,
	BLOCK_ROOTED_DIRT_FALL,
	BLOCK_ROOTED_DIRT_HIT,
	BLOCK_ROOTED_DIRT_PLACE,
	BLOCK_ROOTED_DIRT_STEP,
	BLOCK_ROOTS_BREAK,
	BLOCK_ROOTS_FALL,
	BLOCK_ROOTS_HIT,
	BLOCK_ROOTS_PLACE,
	BLOCK_ROOTS_STEP,
	BLOCK_SAND_BREAK,
	BLOCK_SAND_FALL,
	BLOCK_SAND_HIT,
	BLOCK_SAND_PLACE,
	BLOCK_SAND_STEP,
	BLOCK_SCAFFOLDING_BREAK,
	BLOCK_SCAFFOLDING_FALL,
	BLOCK_SCAFFOLDING_HIT,
	BLOCK_SCAFFOLDING_PLACE,
	BLOCK_SCAFFOLDING_STEP,
	BLOCK_SCULK_SENSOR_BREAK,
	BLOCK_SCULK_SENSOR_CLICKING,
	BLOCK_SCULK_SENSOR_CLICKING_STOP,
	BLOCK_SCULK_SENSOR_FALL,
	BLOCK_SCULK_SENSOR_HIT,
	BLOCK_SCULK_SENSOR_PLACE,
	BLOCK_SCULK_SENSOR_STEP,
	BLOCK_SHROOMLIGHT_BREAK,
	BLOCK_SHROOMLIGHT_FALL,
	BLOCK_SHROOMLIGHT_HIT,
	BLOCK_SHROOMLIGHT_PLACE,
	BLOCK_SHROOMLIGHT_STEP,
	BLOCK_SHULKER_BOX_CLOSE,
	BLOCK_SHULKER_BOX_OPEN,
	BLOCK_SLIME_BLOCK_BREAK,
	BLOCK_SLIME_BLOCK_FALL,
	BLOCK_SLIME_BLOCK_HIT,
	BLOCK_SLIME_BLOCK_PLACE,
	BLOCK_SLIME_BLOCK_STEP,
	BLOCK_SMALL_AMETHYST_BUD_BREAK,
	BLOCK_SMALL_AMETHYST_BUD_PLACE,
	BLOCK_SMALL_DRIPLEAF_BREAK,
	BLOCK_SMALL_DRIPLEAF_FALL,
	BLOCK_SMALL_DRIPLEAF_HIT,
	BLOCK_SMALL_DRIPLEAF_PLACE,
	BLOCK_SMALL_DRIPLEAF_STEP,
	BLOCK_SMITHING_TABLE_USE,
	BLOCK_SMOKER_SMOKE,
	BLOCK_SNOW_BREAK,
	BLOCK_SNOW_FALL,
	BLOCK_SNOW_HIT,
	BLOCK_SNOW_PLACE,
	BLOCK_SNOW_STEP,
	BLOCK_SOUL_SAND_BREAK,
	BLOCK_SOUL_SAND_FALL,
	BLOCK_SOUL_SAND_HIT,
	BLOCK_SOUL_SAND_PLACE,
	BLOCK_SOUL_SAND_STEP,
	BLOCK_SOUL_SOIL_BREAK,
	BLOCK_SOUL_SOIL_FALL,
	BLOCK_SOUL_SOIL_HIT,
	BLOCK_SOUL_SOIL_PLACE,
	BLOCK_SOUL_SOIL_STEP,
	BLOCK_SPORE_BLOSSOM_BREAK,
	BLOCK_SPORE_BLOSSOM_FALL,
	BLOCK_SPORE_BLOSSOM_HIT,
	BLOCK_SPORE_BLOSSOM_PLACE,
	BLOCK_SPORE_BLOSSOM_STEP,
	BLOCK_STEM_BREAK,
	BLOCK_STEM_FALL,
	BLOCK_STEM_HIT,
	BLOCK_STEM_PLACE,
	BLOCK_STEM_STEP,
	BLOCK_STONE_BREAK,
	BLOCK_STONE_BUTTON_CLICK_OFF,
	BLOCK_STONE_BUTTON_CLICK_ON,
	BLOCK_STONE_FALL,
	BLOCK_STONE_HIT,
	BLOCK_STONE_PLACE,
	BLOCK_STONE_PRESSURE_PLATE_CLICK_OFF,
	BLOCK_STONE_PRESSURE_PLATE_CLICK_ON,
	BLOCK_STONE_STEP,
	BLOCK_SWEET_BERRY_BUSH_BREAK,
	BLOCK_SWEET_BERRY_BUSH_PICK_BERRIES,
	BLOCK_SWEET_BERRY_BUSH_PLACE,
	BLOCK_TRIPWIRE_ATTACH,
	BLOCK_TRIPWIRE_CLICK_OFF,
	BLOCK_TRIPWIRE_CLICK_ON,
	BLOCK_TRIPWIRE_DETACH,
	BLOCK_TUFF_BREAK,
	BLOCK_TUFF_FALL,
	BLOCK_TUFF_HIT,
	BLOCK_TUFF_PLACE,
	BLOCK_TUFF_STEP,
	BLOCK_VINE_BREAK,
	BLOCK_VINE_FALL,
	BLOCK_VINE_HIT,
	BLOCK_VINE_PLACE,
	BLOCK_VINE_STEP,
	BLOCK_WART_BLOCK_BREAK,
	BLOCK_WART_BLOCK_FALL,
	BLOCK_WART_BLOCK_HIT,
	BLOCK_WART_BLOCK_PLACE,
	BLOCK_WART_BLOCK_STEP,
	BLOCK_WATER_AMBIENT,
	BLOCK_WEEPING_VINES_BREAK,
	BLOCK_WEEPING_VINES_FALL,
	BLOCK_WEEPING_VINES_HIT,
	BLOCK_WEEPING_VINES_PLACE,
	BLOCK_WEEPING_VINES_STEP,
	BLOCK_WET_GRASS_BREAK,
	BLOCK_WET_GRASS_FALL,
	BLOCK_WET_GRASS_HIT,
	BLOCK_WET_GRASS_PLACE,
	BLOCK_WET_GRASS_STEP,
	BLOCK_WOODEN_BUTTON_CLICK_OFF,
	BLOCK_WOODEN_BUTTON_CLICK_ON,
	BLOCK_WOODEN_DOOR_CLOSE,
	BLOCK_WOODEN_DOOR_OPEN,
	BLOCK_WOODEN_PRESSURE_PLATE_CLICK_OFF,
	BLOCK_WOODEN_PRESSURE_PLATE_CLICK_ON,
	BLOCK_WOODEN_TRAPDOOR_CLOSE,
	BLOCK_WOODEN_TRAPDOOR_OPEN,
	BLOCK_WOOD_BREAK,
	BLOCK_WOOD_FALL,
	BLOCK_WOOD_HIT,
	BLOCK_WOOD_PLACE,
	BLOCK_WOOD_STEP,
	BLOCK_WOOL_BREAK,
	BLOCK_WOOL_FALL,
	BLOCK_WOOL_HIT,
	BLOCK_WOOL_PLACE,
	BLOCK_WOOL_STEP,
	ENCHANT_THORNS_HIT,
	ENTITY_ARMOR_STAND_BREAK,
	ENTITY_ARMOR_STAND_FALL,
	ENTITY_ARMOR_STAND_HIT,
	ENTITY_ARMOR_STAND_PLACE,
	ENTITY_ARROW_HIT,
	ENTITY_ARROW_HIT_PLAYER,
	ENTITY_ARROW_SHOOT,
	ENTITY_AXOLOTL_ATTACK,
	ENTITY_AXOLOTL_DEATH,
	ENTITY_AXOLOTL_HURT,
	ENTITY_AXOLOTL_IDLE_AIR,
	ENTITY_AXOLOTL_IDLE_WATER,
	ENTITY_AXOLOTL_SPLASH,
	ENTITY_AXOLOTL_SWIM,
	ENTITY_BAT_AMBIENT,
	ENTITY_BAT_DEATH,
	ENTITY_BAT_HURT,
	ENTITY_BAT_LOOP,
	ENTITY_BAT_TAKEOFF,
	ENTITY_BEE_DEATH,
	ENTITY_BEE_HURT,
	ENTITY_BEE_LOOP,
	ENTITY_BEE_LOOP_AGGRESSIVE,
	ENTITY_BEE_POLLINATE,
	ENTITY_BEE_STING,
	ENTITY_BLAZE_AMBIENT,
	ENTITY_BLAZE_BURN,
	ENTITY_BLAZE_DEATH,
	ENTITY_BLAZE_HURT,
	ENTITY_BLAZE_SHOOT,
	ENTITY_BOAT_PADDLE_LAND,
	ENTITY_BOAT_PADDLE_WATER,
	ENTITY_CAT_AMBIENT,
	ENTITY_CAT_BEG_FOR_FOOD,
	ENTITY_CAT_DEATH,
	ENTITY_CAT_EAT,
	ENTITY_CAT_HISS,
	ENTITY_CAT_HURT,
	ENTITY_CAT_PURR,
	ENTITY_CAT_PURREOW,
	ENTITY_CAT_STRAY_AMBIENT,
	ENTITY_CHICKEN_AMBIENT,
	ENTITY_CHICKEN_DEATH,
	ENTITY_CHICKEN_EGG,
	ENTITY_CHICKEN_HURT,
	ENTITY_CHICKEN_STEP,
	ENTITY_COD_AMBIENT,
	ENTITY_COD_DEATH,
	ENTITY_COD_FLOP,
	ENTITY_COD_HURT,
	ENTITY_COW_AMBIENT,
	ENTITY_COW_DEATH,
	ENTITY_COW_HURT,
	ENTITY_COW_MILK,
	ENTITY_COW_STEP,
	ENTITY_CREEPER_DEATH,
	ENTITY_CREEPER_HURT,
	ENTITY_CREEPER_PRIMED,
	ENTITY_DOLPHIN_AMBIENT,
	ENTITY_DOLPHIN_AMBIENT_WATER,
	ENTITY_DOLPHIN_ATTACK,
	ENTITY_DOLPHIN_DEATH,
	ENTITY_DOLPHIN_EAT,
	ENTITY_DOLPHIN_HURT,
	ENTITY_DOLPHIN_JUMP,
	ENTITY_DOLPHIN_PLAY,
	ENTITY_DOLPHIN_SPLASH,
	ENTITY_DOLPHIN_SWIM,
	ENTITY_DONKEY_AMBIENT,
	ENTITY_DONKEY_ANGRY,
	ENTITY_DONKEY_CHEST,
	ENTITY_DONKEY_DEATH,
	ENTITY_DONKEY_EAT,
	ENTITY_DONKEY_HURT,
	ENTITY_DRAGON_FIREBALL_EXPLODE,
	ENTITY_DROWNED_AMBIENT,
	ENTITY_DROWNED_AMBIENT_WATER,
	ENTITY_DROWNED_DEATH,
	ENTITY_DROWNED_DEATH_WATER,
	ENTITY_DROWNED_HURT,
	ENTITY_DROWNED_HURT_WATER,
	ENTITY_DROWNED_SHOOT,
	ENTITY_DROWNED_STEP,
	ENTITY_DROWNED_SWIM,
	ENTITY_EGG_THROW,
	ENTITY_ELDER_GUARDIAN_AMBIENT,
	ENTITY_ELDER_GUARDIAN_AMBIENT_LAND,
	ENTITY_ELDER_GUARDIAN_CURSE,
	ENTITY_ELDER_GUARDIAN_DEATH,
	ENTITY_ELDER_GUARDIAN_DEATH_LAND,
	ENTITY_ELDER_GUARDIAN_FLOP,
	ENTITY_ELDER_GUARDIAN_HURT,
	ENTITY_ELDER_GUARDIAN_HURT_LAND,
	ENTITY_ENDERMAN_AMBIENT,
	ENTITY_ENDERMAN_DEATH,
	ENTITY_ENDERMAN_HURT,
	ENTITY_ENDERMAN_SCREAM,
	ENTITY_ENDERMAN_STARE,
	ENTITY_ENDERMAN_TELEPORT,
	ENTITY_ENDERMITE_AMBIENT,
	ENTITY_ENDERMITE_DEATH,
	ENTITY_ENDERMITE_HURT,
	ENTITY_ENDERMITE_STEP,
	ENTITY_ENDER_DRAGON_AMBIENT,
	ENTITY_ENDER_DRAGON_DEATH,
	ENTITY_ENDER_DRAGON_FLAP,
	ENTITY_ENDER_DRAGON_GROWL,
	ENTITY_ENDER_DRAGON_HURT,
	ENTITY_ENDER_DRAGON_SHOOT,
	ENTITY_ENDER_EYE_DEATH,
	ENTITY_ENDER_EYE_LAUNCH,
	ENTITY_ENDER_PEARL_THROW,
	ENTITY_EVOKER_AMBIENT,
	ENTITY_EVOKER_CAST_SPELL,
	ENTITY_EVOKER_CELEBRATE,
	ENTITY_EVOKER_DEATH,
	ENTITY_EVOKER_FANGS_ATTACK,
	ENTITY_EVOKER_HURT,
	ENTITY_EVOKER_PREPARE_ATTACK,
	ENTITY_EVOKER_PREPARE_SUMMON,
	ENTITY_EVOKER_PREPARE_WOLOLO,
	ENTITY_EXPERIENCE_BOTTLE_THROW,
	ENTITY_EXPERIENCE_ORB_PICKUP,
	ENTITY_FIREWORK_ROCKET_BLAST,
	ENTITY_FIREWORK_ROCKET_BLAST_FAR,
	ENTITY_FIREWORK_ROCKET_LARGE_BLAST,
	ENTITY_FIREWORK_ROCKET_LARGE_BLAST_FAR,
	ENTITY_FIREWORK_ROCKET_LAUNCH,
	ENTITY_FIREWORK_ROCKET_SHOOT,
	ENTITY_FIREWORK_ROCKET_TWINKLE,
	ENTITY_FIREWORK_ROCKET_TWINKLE_FAR,
	ENTITY_FISHING_BOBBER_RETRIEVE,
	ENTITY_FISHING_BOBBER_SPLASH,
	ENTITY_FISHING_BOBBER_THROW,
	ENTITY_FISH_SWIM,
	ENTITY_FOX_AGGRO,
	ENTITY_FOX_AMBIENT,
	ENTITY_FOX_BITE,
	ENTITY_FOX_DEATH,
	ENTITY_FOX_EAT,
	ENTITY_FOX_HURT,
	ENTITY_FOX_SCREECH,
	ENTITY_FOX_SLEEP,
	ENTITY_FOX_SNIFF,
	ENTITY_FOX_SPIT,
	ENTITY_FOX_TELEPORT,
	ENTITY_GENERIC_BIG_FALL,
	ENTITY_GENERIC_BURN,
	ENTITY_GENERIC_DEATH,
	ENTITY_GENERIC_DRINK,
	ENTITY_GENERIC_EAT,
	ENTITY_GENERIC_EXPLODE,
	ENTITY_GENERIC_EXTINGUISH_FIRE,
	ENTITY_GENERIC_HURT,
	ENTITY_GENERIC_SMALL_FALL,
	ENTITY_GENERIC_SPLASH,
	ENTITY_GENERIC_SWIM,
	ENTITY_GHAST_AMBIENT,
	ENTITY_GHAST_DEATH,
	ENTITY_GHAST_HURT,
	ENTITY_GHAST_SCREAM,
	ENTITY_GHAST_SHOOT,
	ENTITY_GHAST_WARN,
	ENTITY_GLOW_ITEM_FRAME_ADD_ITEM,
	ENTITY_GLOW_ITEM_FRAME_BREAK,
	ENTITY_GLOW_ITEM_FRAME_PLACE,
	ENTITY_GLOW_ITEM_FRAME_REMOVE_ITEM,
	ENTITY_GLOW_ITEM_FRAME_ROTATE_ITEM,
	ENTITY_GLOW_SQUID_AMBIENT,
	ENTITY_GLOW_SQUID_DEATH,
	ENTITY_GLOW_SQUID_HURT,
	ENTITY_GLOW_SQUID_SQUIRT,
	ENTITY_GOAT_AMBIENT,
	ENTITY_GOAT_DEATH,
	ENTITY_GOAT_EAT,
	ENTITY_GOAT_HURT,
	ENTITY_GOAT_LONG_JUMP,
	ENTITY_GOAT_MILK,
	ENTITY_GOAT_PREPARE_RAM,
	ENTITY_GOAT_RAM_IMPACT,
	ENTITY_GOAT_SCREAMING_AMBIENT,
	ENTITY_GOAT_SCREAMING_DEATH,
	ENTITY_GOAT_SCREAMING_EAT,
	ENTITY_GOAT_SCREAMING_HURT,
	ENTITY_GOAT_SCREAMING_LONG_JUMP,
	ENTITY_GOAT_SCREAMING_MILK,
	ENTITY_GOAT_SCREAMING_PREPARE_RAM,
	ENTITY_GOAT_SCREAMING_RAM_IMPACT,
	ENTITY_GOAT_STEP,
	ENTITY_GUARDIAN_AMBIENT,
	ENTITY_GUARDIAN_AMBIENT_LAND,
	ENTITY_GUARDIAN_ATTACK,
	ENTITY_GUARDIAN_DEATH,
	ENTITY_GUARDIAN_DEATH_LAND,
	ENTITY_GUARDIAN_FLOP,
	ENTITY_GUARDIAN_HURT,
	ENTITY_GUARDIAN_HURT_LAND,
	ENTITY_HOGLIN_AMBIENT,
	ENTITY_HOGLIN_ANGRY,
	ENTITY_HOGLIN_ATTACK,
	ENTITY_HOGLIN_CONVERTED_TO_ZOMBIFIED,
	ENTITY_HOGLIN_DEATH,
	ENTITY_HOGLIN_HURT,
	ENTITY_HOGLIN_RETREAT,
	ENTITY_HOGLIN_STEP,
	ENTITY_HORSE_AMBIENT,
	ENTITY_HORSE_ANGRY,
	ENTITY_HORSE_ARMOR,
	ENTITY_HORSE_BREATHE,
	ENTITY_HORSE_DEATH,
	ENTITY_HORSE_EAT,
	ENTITY_HORSE_GALLOP,
	ENTITY_HORSE_HURT,
	ENTITY_HORSE_JUMP,
	ENTITY_HORSE_LAND,
	ENTITY_HORSE_SADDLE,
	ENTITY_HORSE_STEP,
	ENTITY_HORSE_STEP_WOOD,
	ENTITY_HOSTILE_BIG_FALL,
	ENTITY_HOSTILE_DEATH,
	ENTITY_HOSTILE_HURT,
	ENTITY_HOSTILE_SMALL_FALL,
	ENTITY_HOSTILE_SPLASH,
	ENTITY_HOSTILE_SWIM,
	ENTITY_HUSK_AMBIENT,
	ENTITY_HUSK_CONVERTED_TO_ZOMBIE,
	ENTITY_HUSK_DEATH,
	ENTITY_HUSK_HURT,
	ENTITY_HUSK_STEP,
	ENTITY_ILLUSIONER_AMBIENT,
	ENTITY_ILLUSIONER_CAST_SPELL,
	ENTITY_ILLUSIONER_DEATH,
	ENTITY_ILLUSIONER_HURT,
	ENTITY_ILLUSIONER_MIRROR_MOVE,
	ENTITY_ILLUSIONER_PREPARE_BLINDNESS,
	ENTITY_ILLUSIONER_PREPARE_MIRROR,
	ENTITY_IRON_GOLEM_ATTACK,
	ENTITY_IRON_GOLEM_DAMAGE,
	ENTITY_IRON_GOLEM_DEATH,
	ENTITY_IRON_GOLEM_HURT,
	ENTITY_IRON_GOLEM_REPAIR,
	ENTITY_IRON_GOLEM_STEP,
	ENTITY_ITEM_BREAK,
	ENTITY_ITEM_FRAME_ADD_ITEM,
	ENTITY_ITEM_FRAME_BREAK,
	ENTITY_ITEM_FRAME_PLACE,
	ENTITY_ITEM_FRAME_REMOVE_ITEM,
	ENTITY_ITEM_FRAME_ROTATE_ITEM,
	ENTITY_ITEM_PICKUP,
	ENTITY_LEASH_KNOT_BREAK,
	ENTITY_LEASH_KNOT_PLACE,
	ENTITY_LIGHTNING_BOLT_IMPACT,
	ENTITY_LIGHTNING_BOLT_THUNDER,
	ENTITY_LINGERING_POTION_THROW,
	ENTITY_LLAMA_AMBIENT,
	ENTITY_LLAMA_ANGRY,
	ENTITY_LLAMA_CHEST,
	ENTITY_LLAMA_DEATH,
	ENTITY_LLAMA_EAT,
	ENTITY_LLAMA_HURT,
	ENTITY_LLAMA_SPIT,
	ENTITY_LLAMA_STEP,
	ENTITY_LLAMA_SWAG,
	ENTITY_MAGMA_CUBE_DEATH,
	ENTITY_MAGMA_CUBE_DEATH_SMALL,
	ENTITY_MAGMA_CUBE_HURT,
	ENTITY_MAGMA_CUBE_HURT_SMALL,
	ENTITY_MAGMA_CUBE_JUMP,
	ENTITY_MAGMA_CUBE_SQUISH,
	ENTITY_MAGMA_CUBE_SQUISH_SMALL,
	ENTITY_MINECART_INSIDE,
	ENTITY_MINECART_INSIDE_UNDERWATER,
	ENTITY_MINECART_RIDING,
	ENTITY_MOOSHROOM_CONVERT,
	ENTITY_MOOSHROOM_EAT,
	ENTITY_MOOSHROOM_MILK,
	ENTITY_MOOSHROOM_SHEAR,
	ENTITY_MOOSHROOM_SUSPICIOUS_MILK,
	ENTITY_MULE_AMBIENT,
	ENTITY_MULE_ANGRY,
	ENTITY_MULE_CHEST,
	ENTITY_MULE_DEATH,
	ENTITY_MULE_EAT,
	ENTITY_MULE_HURT,
	ENTITY_OCELOT_AMBIENT,
	ENTITY_OCELOT_DEATH,
	ENTITY_OCELOT_HURT,
	ENTITY_PAINTING_BREAK,
	ENTITY_PAINTING_PLACE,
	ENTITY_PANDA_AGGRESSIVE_AMBIENT,
	ENTITY_PANDA_AMBIENT,
	ENTITY_PANDA_BITE,
	ENTITY_PANDA_CANT_BREED,
	ENTITY_PANDA_DEATH,
	ENTITY_PANDA_EAT,
	ENTITY_PANDA_HURT,
	ENTITY_PANDA_PRE_SNEEZE,
	ENTITY_PANDA_SNEEZE,
	ENTITY_PANDA_STEP,
	ENTITY_PANDA_WORRIED_AMBIENT,
	ENTITY_PARROT_AMBIENT,
	ENTITY_PARROT_DEATH,
	ENTITY_PARROT_EAT,
	ENTITY_PARROT_FLY,
	ENTITY_PARROT_HURT,
	ENTITY_PARROT_IMITATE_BLAZE,
	ENTITY_PARROT_IMITATE_CREEPER,
	ENTITY_PARROT_IMITATE_DROWNED,
	ENTITY_PARROT_IMITATE_ELDER_GUARDIAN,
	ENTITY_PARROT_IMITATE_ENDERMITE,
	ENTITY_PARROT_IMITATE_ENDER_DRAGON,
	ENTITY_PARROT_IMITATE_EVOKER,
	ENTITY_PARROT_IMITATE_GHAST,
	ENTITY_PARROT_IMITATE_GUARDIAN,
	ENTITY_PARROT_IMITATE_HOGLIN,
	ENTITY_PARROT_IMITATE_HUSK,
	ENTITY_PARROT_IMITATE_ILLUSIONER,
	ENTITY_PARROT_IMITATE_MAGMA_CUBE,
	ENTITY_PARROT_IMITATE_PHANTOM,
	ENTITY_PARROT_IMITATE_PIGLIN,
	ENTITY_PARROT_IMITATE_PIGLIN_BRUTE,
	ENTITY_PARROT_IMITATE_PILLAGER,
	ENTITY_PARROT_IMITATE_RAVAGER,
	ENTITY_PARROT_IMITATE_SHULKER,
	ENTITY_PARROT_IMITATE_SILVERFISH,
	ENTITY_PARROT_IMITATE_SKELETON,
	ENTITY_PARROT_IMITATE_SLIME,
	ENTITY_PARROT_IMITATE_SPIDER,
	ENTITY_PARROT_IMITATE_STRAY,
	ENTITY_PARROT_IMITATE_VEX,
	ENTITY_PARROT_IMITATE_VINDICATOR,
	ENTITY_PARROT_IMITATE_WITCH,
	ENTITY_PARROT_IMITATE_WITHER,
	ENTITY_PARROT_IMITATE_WITHER_SKELETON,
	ENTITY_PARROT_IMITATE_ZOGLIN,
	ENTITY_PARROT_IMITATE_ZOMBIE,
	ENTITY_PARROT_IMITATE_ZOMBIE_VILLAGER,
	ENTITY_PARROT_STEP,
	ENTITY_PHANTOM_AMBIENT,
	ENTITY_PHANTOM_BITE,
	ENTITY_PHANTOM_DEATH,
	ENTITY_PHANTOM_FLAP,
	ENTITY_PHANTOM_HURT,
	ENTITY_PHANTOM_SWOOP,
	ENTITY_PIGLIN_ADMIRING_ITEM,
	ENTITY_PIGLIN_AMBIENT,
	ENTITY_PIGLIN_ANGRY,
	ENTITY_PIGLIN_BRUTE_AMBIENT,
	ENTITY_PIGLIN_BRUTE_ANGRY,
	ENTITY_PIGLIN_BRUTE_CONVERTED_TO_ZOMBIFIED,
	ENTITY_PIGLIN_BRUTE_DEATH,
	ENTITY_PIGLIN_BRUTE_HURT,
	ENTITY_PIGLIN_BRUTE_STEP,
	ENTITY_PIGLIN_CELEBRATE,
	ENTITY_PIGLIN_CONVERTED_TO_ZOMBIFIED,
	ENTITY_PIGLIN_DEATH,
	ENTITY_PIGLIN_HURT,
	ENTITY_PIGLIN_JEALOUS,
	ENTITY_PIGLIN_RETREAT,
	ENTITY_PIGLIN_STEP,
	ENTITY_PIG_AMBIENT,
	ENTITY_PIG_DEATH,
	ENTITY_PIG_HURT,
	ENTITY_PIG_SADDLE,
	ENTITY_PIG_STEP,
	ENTITY_PILLAGER_AMBIENT,
	ENTITY_PILLAGER_CELEBRATE,
	ENTITY_PILLAGER_DEATH,
	ENTITY_PILLAGER_HURT,
	ENTITY_PLAYER_ATTACK_CRIT,
	ENTITY_PLAYER_ATTACK_KNOCKBACK,
	ENTITY_PLAYER_ATTACK_NODAMAGE,
	ENTITY_PLAYER_ATTACK_STRONG,
	ENTITY_PLAYER_ATTACK_SWEEP,
	ENTITY_PLAYER_ATTACK_WEAK,
	ENTITY_PLAYER_BIG_FALL,
	ENTITY_PLAYER_BREATH,
	ENTITY_PLAYER_BURP,
	ENTITY_PLAYER_DEATH,
	ENTITY_PLAYER_HURT,
	ENTITY_PLAYER_HURT_DROWN,
	ENTITY_PLAYER_HURT_FREEZE,
	ENTITY_PLAYER_HURT_ON_FIRE,
	ENTITY_PLAYER_HURT_SWEET_BERRY_BUSH,
	ENTITY_PLAYER_LEVELUP,
	ENTITY_PLAYER_SMALL_FALL,
	ENTITY_PLAYER_SPLASH,
	ENTITY_PLAYER_SPLASH_HIGH_SPEED,
	ENTITY_PLAYER_SWIM,
	ENTITY_POLAR_BEAR_AMBIENT,
	ENTITY_POLAR_BEAR_AMBIENT_BABY,
	ENTITY_POLAR_BEAR_DEATH,
	ENTITY_POLAR_BEAR_HURT,
	ENTITY_POLAR_BEAR_STEP,
	ENTITY_POLAR_BEAR_WARNING,
	ENTITY_PUFFER_FISH_AMBIENT,
	ENTITY_PUFFER_FISH_BLOW_OUT,
	ENTITY_PUFFER_FISH_BLOW_UP,
	ENTITY_PUFFER_FISH_DEATH,
	ENTITY_PUFFER_FISH_FLOP,
	ENTITY_PUFFER_FISH_HURT,
	ENTITY_PUFFER_FISH_STING,
	ENTITY_RABBIT_AMBIENT,
	ENTITY_RABBIT_ATTACK,
	ENTITY_RABBIT_DEATH,
	ENTITY_RABBIT_HURT,
	ENTITY_RABBIT_JUMP,
	ENTITY_RAVAGER_AMBIENT,
	ENTITY_RAVAGER_ATTACK,
	ENTITY_RAVAGER_CELEBRATE,
	ENTITY_RAVAGER_DEATH,
	ENTITY_RAVAGER_HURT,
	ENTITY_RAVAGER_ROAR,
	ENTITY_RAVAGER_STEP,
	ENTITY_RAVAGER_STUNNED,
	ENTITY_SALMON_AMBIENT,
	ENTITY_SALMON_DEATH,
	ENTITY_SALMON_FLOP,
	ENTITY_SALMON_HURT,
	ENTITY_SHEEP_AMBIENT,
	ENTITY_SHEEP_DEATH,
	ENTITY_SHEEP_HURT,
	ENTITY_SHEEP_SHEAR,
	ENTITY_SHEEP_STEP,
	ENTITY_SHULKER_AMBIENT,
	ENTITY_SHULKER_BULLET_HIT,
	ENTITY_SHULKER_BULLET_HURT,
	ENTITY_SHULKER_CLOSE,
	ENTITY_SHULKER_DEATH,
	ENTITY_SHULKER_HURT,
	ENTITY_SHULKER_HURT_CLOSED,
	ENTITY_SHULKER_OPEN,
	ENTITY_SHULKER_SHOOT,
	ENTITY_SHULKER_TELEPORT,
	ENTITY_SILVERFISH_AMBIENT,
	ENTITY_SILVERFISH_DEATH,
	ENTITY_SILVERFISH_HURT,
	ENTITY_SILVERFISH_STEP,
	ENTITY_SKELETON_AMBIENT,
	ENTITY_SKELETON_CONVERTED_TO_STRAY,
	ENTITY_SKELETON_DEATH,
	ENTITY_SKELETON_HORSE_AMBIENT,
	ENTITY_SKELETON_HORSE_AMBIENT_WATER,
	ENTITY_SKELETON_HORSE_DEATH,
	ENTITY_SKELETON_HORSE_GALLOP_WATER,
	ENTITY_SKELETON_HORSE_HURT,
	ENTITY_SKELETON_HORSE_JUMP_WATER,
	ENTITY_SKELETON_HORSE_STEP_WATER,
	ENTITY_SKELETON_HORSE_SWIM,
	ENTITY_SKELETON_HURT,
	ENTITY_SKELETON_SHOOT,
	ENTITY_SKELETON_STEP,
	ENTITY_SLIME_ATTACK,
	ENTITY_SLIME_DEATH,
	ENTITY_SLIME_DEATH_SMALL,
	ENTITY_SLIME_HURT,
	ENTITY_SLIME_HURT_SMALL,
	ENTITY_SLIME_JUMP,
	ENTITY_SLIME_JUMP_SMALL,
	ENTITY_SLIME_SQUISH,
	ENTITY_SLIME_SQUISH_SMALL,
	ENTITY_SNOWBALL_THROW,
	ENTITY_SNOW_GOLEM_AMBIENT,
	ENTITY_SNOW_GOLEM_DEATH,
	ENTITY_SNOW_GOLEM_HURT,
	ENTITY_SNOW_GOLEM_SHEAR,
	ENTITY_SNOW_GOLEM_SHOOT,
	ENTITY_SPIDER_AMBIENT,
	ENTITY_SPIDER_DEATH,
	ENTITY_SPIDER_HURT,
	ENTITY_SPIDER_STEP,
	ENTITY_SPLASH_POTION_BREAK,
	ENTITY_SPLASH_POTION_THROW,
	ENTITY_SQUID_AMBIENT,
	ENTITY_SQUID_DEATH,
	ENTITY_SQUID_HURT,
	ENTITY_SQUID_SQUIRT,
	ENTITY_STRAY_AMBIENT,
	ENTITY_STRAY_DEATH,
	ENTITY_STRAY_HURT,
	ENTITY_STRAY_STEP,
	ENTITY_STRIDER_AMBIENT,
	ENTITY_STRIDER_DEATH,
	ENTITY_STRIDER_EAT,
	ENTITY_STRIDER_HAPPY,
	ENTITY_STRIDER_HURT,
	ENTITY_STRIDER_RETREAT,
	ENTITY_STRIDER_SADDLE,
	ENTITY_STRIDER_STEP,
	ENTITY_STRIDER_STEP_LAVA,
	ENTITY_TNT_PRIMED,
	ENTITY_TROPICAL_FISH_AMBIENT,
	ENTITY_TROPICAL_FISH_DEATH,
	ENTITY_TROPICAL_FISH_FLOP,
	ENTITY_TROPICAL_FISH_HURT,
	ENTITY_TURTLE_AMBIENT_LAND,
	ENTITY_TURTLE_DEATH,
	ENTITY_TURTLE_DEATH_BABY,
	ENTITY_TURTLE_EGG_BREAK,
	ENTITY_TURTLE_EGG_CRACK,
	ENTITY_TURTLE_EGG_HATCH,
	ENTITY_TURTLE_HURT,
	ENTITY_TURTLE_HURT_BABY,
	ENTITY_TURTLE_LAY_EGG,
	ENTITY_TURTLE_SHAMBLE,
	ENTITY_TURTLE_SHAMBLE_BABY,
	ENTITY_TURTLE_SWIM,
	ENTITY_VEX_AMBIENT,
	ENTITY_VEX_CHARGE,
	ENTITY_VEX_DEATH,
	ENTITY_VEX_HURT,
	ENTITY_VILLAGER_AMBIENT,
	ENTITY_VILLAGER_CELEBRATE,
	ENTITY_VILLAGER_DEATH,
	ENTITY_VILLAGER_HURT,
	ENTITY_VILLAGER_NO,
	ENTITY_VILLAGER_TRADE,
	ENTITY_VILLAGER_WORK_ARMORER,
	ENTITY_VILLAGER_WORK_BUTCHER,
	ENTITY_VILLAGER_WORK_CARTOGRAPHER,
	ENTITY_VILLAGER_WORK_CLERIC,
	ENTITY_VILLAGER_WORK_FARMER,
	ENTITY_VILLAGER_WORK_FISHERMAN,
	ENTITY_VILLAGER_WORK_FLETCHER,
	ENTITY_VILLAGER_WORK_LEATHERWORKER,
	ENTITY_VILLAGER_WORK_LIBRARIAN,
	ENTITY_VILLAGER_WORK_MASON,
	ENTITY_VILLAGER_WORK_SHEPHERD,
	ENTITY_VILLAGER_WORK_TOOLSMITH,
	ENTITY_VILLAGER_WORK_WEAPONSMITH,
	ENTITY_VILLAGER_YES,
	ENTITY_VINDICATOR_AMBIENT,
	ENTITY_VINDICATOR_CELEBRATE,
	ENTITY_VINDICATOR_DEATH,
	ENTITY_VINDICATOR_HURT,
	ENTITY_WANDERING_TRADER_AMBIENT,
	ENTITY_WANDERING_TRADER_DEATH,
	ENTITY_WANDERING_TRADER_DISAPPEARED,
	ENTITY_WANDERING_TRADER_DRINK_MILK,
	ENTITY_WANDERING_TRADER_DRINK_POTION,
	ENTITY_WANDERING_TRADER_HURT,
	ENTITY_WANDERING_TRADER_NO,
	ENTITY_WANDERING_TRADER_REAPPEARED,
	ENTITY_WANDERING_TRADER_TRADE,
	ENTITY_WANDERING_TRADER_YES,
	ENTITY_WITCH_AMBIENT,
	ENTITY_WITCH_CELEBRATE,
	ENTITY_WITCH_DEATH,
	ENTITY_WITCH_DRINK,
	ENTITY_WITCH_HURT,
	ENTITY_WITCH_THROW,
	ENTITY_WITHER_AMBIENT,
	ENTITY_WITHER_BREAK_BLOCK,
	ENTITY_WITHER_DEATH,
	ENTITY_WITHER_HURT,
	ENTITY_WITHER_SHOOT,
	ENTITY_WITHER_SKELETON_AMBIENT,
	ENTITY_WITHER_SKELETON_DEATH,
	ENTITY_WITHER_SKELETON_HURT,
	ENTITY_WITHER_SKELETON_STEP,
	ENTITY_WITHER_SPAWN,
	ENTITY_WOLF_AMBIENT,
	ENTITY_WOLF_DEATH,
	ENTITY_WOLF_GROWL,
	ENTITY_WOLF_HOWL,
	ENTITY_WOLF_HURT,
	ENTITY_WOLF_PANT,
	ENTITY_WOLF_SHAKE,
	ENTITY_WOLF_STEP,
	ENTITY_WOLF_WHINE,
	ENTITY_ZOGLIN_AMBIENT,
	ENTITY_ZOGLIN_ANGRY,
	ENTITY_ZOGLIN_ATTACK,
	ENTITY_ZOGLIN_DEATH,
	ENTITY_ZOGLIN_HURT,
	ENTITY_ZOGLIN_STEP,
	ENTITY_ZOMBIE_AMBIENT,
	ENTITY_ZOMBIE_ATTACK_IRON_DOOR,
	ENTITY_ZOMBIE_ATTACK_WOODEN_DOOR,
	ENTITY_ZOMBIE_BREAK_WOODEN_DOOR,
	ENTITY_ZOMBIE_CONVERTED_TO_DROWNED,
	ENTITY_ZOMBIE_DEATH,
	ENTITY_ZOMBIE_DESTROY_EGG,
	ENTITY_ZOMBIE_HORSE_AMBIENT,
	ENTITY_ZOMBIE_HORSE_DEATH,
	ENTITY_ZOMBIE_HORSE_HURT,
	ENTITY_ZOMBIE_HURT,
	ENTITY_ZOMBIE_INFECT,
	ENTITY_ZOMBIE_STEP,
	ENTITY_ZOMBIE_VILLAGER_AMBIENT,
	ENTITY_ZOMBIE_VILLAGER_CONVERTED,
	ENTITY_ZOMBIE_VILLAGER_CURE,
	ENTITY_ZOMBIE_VILLAGER_DEATH,
	ENTITY_ZOMBIE_VILLAGER_HURT,
	ENTITY_ZOMBIE_VILLAGER_STEP,
	ENTITY_ZOMBIFIED_PIGLIN_AMBIENT,
	ENTITY_ZOMBIFIED_PIGLIN_ANGRY,
	ENTITY_ZOMBIFIED_PIGLIN_DEATH,
	ENTITY_ZOMBIFIED_PIGLIN_HURT,
	EVENT_RAID_HORN,
	ITEM_ARMOR_EQUIP_CHAIN,
	ITEM_ARMOR_EQUIP_DIAMOND,
	ITEM_ARMOR_EQUIP_ELYTRA,
	ITEM_ARMOR_EQUIP_GENERIC,
	ITEM_ARMOR_EQUIP_GOLD,
	ITEM_ARMOR_EQUIP_IRON,
	ITEM_ARMOR_EQUIP_LEATHER,
	ITEM_ARMOR_EQUIP_NETHERITE,
	ITEM_ARMOR_EQUIP_TURTLE,
	ITEM_AXE_SCRAPE,
	ITEM_AXE_STRIP,
	ITEM_AXE_WAX_OFF,
	ITEM_BONE_MEAL_USE,
	ITEM_BOOK_PAGE_TURN,
	ITEM_BOOK_PUT,
	ITEM_BOTTLE_EMPTY,
	ITEM_BOTTLE_FILL,
	ITEM_BOTTLE_FILL_DRAGONBREATH,
	ITEM_BUCKET_EMPTY,
	ITEM_BUCKET_EMPTY_AXOLOTL,
	ITEM_BUCKET_EMPTY_FISH,
	ITEM_BUCKET_EMPTY_LAVA,
	ITEM_BUCKET_EMPTY_POWDER_SNOW,
	ITEM_BUCKET_FILL,
	ITEM_BUCKET_FILL_AXOLOTL,
	ITEM_BUCKET_FILL_FISH,
	ITEM_BUCKET_FILL_LAVA,
	ITEM_BUCKET_FILL_POWDER_SNOW,
	ITEM_CHORUS_FRUIT_TELEPORT,
	ITEM_CROP_PLANT,
	ITEM_CROSSBOW_HIT,
	ITEM_CROSSBOW_LOADING_END,
	ITEM_CROSSBOW_LOADING_MIDDLE,
	ITEM_CROSSBOW_LOADING_START,
	ITEM_CROSSBOW_QUICK_CHARGE_1,
	ITEM_CROSSBOW_QUICK_CHARGE_2,
	ITEM_CROSSBOW_QUICK_CHARGE_3,
	ITEM_CROSSBOW_SHOOT,
	ITEM_DYE_USE,
	ITEM_ELYTRA_FLYING,
	ITEM_FIRECHARGE_USE,
	ITEM_FLINTANDSTEEL_USE,
	ITEM_GLOW_INK_SAC_USE,
	ITEM_HOE_TILL,
	ITEM_HONEYCOMB_WAX_ON,
	ITEM_HONEY_BOTTLE_DRINK,
	ITEM_INK_SAC_USE,
	ITEM_LODESTONE_COMPASS_LOCK,
	ITEM_NETHER_WART_PLANT,
	ITEM_SHIELD_BLOCK,
	ITEM_SHIELD_BREAK,
	ITEM_SHOVEL_FLATTEN,
	ITEM_SPYGLASS_STOP_USING,
	ITEM_SPYGLASS_USE,
	ITEM_TOTEM_USE,
	ITEM_TRIDENT_HIT,
	ITEM_TRIDENT_HIT_GROUND,
	ITEM_TRIDENT_RETURN,
	ITEM_TRIDENT_RIPTIDE_1,
	ITEM_TRIDENT_RIPTIDE_2,
	ITEM_TRIDENT_RIPTIDE_3,
	ITEM_TRIDENT_THROW,
	ITEM_TRIDENT_THUNDER,
	MUSIC_CREATIVE,
	MUSIC_CREDITS,
	MUSIC_DISC_11,
	MUSIC_DISC_13,
	MUSIC_DISC_BLOCKS,
	MUSIC_DISC_CAT,
	MUSIC_DISC_CHIRP,
	MUSIC_DISC_FAR,
	MUSIC_DISC_MALL,
	MUSIC_DISC_MELLOHI,
	MUSIC_DISC_PIGSTEP,
	MUSIC_DISC_STAL,
	MUSIC_DISC_STRAD,
	MUSIC_DISC_WAIT,
	MUSIC_DISC_WARD,
	MUSIC_DRAGON,
	MUSIC_END,
	MUSIC_GAME,
	MUSIC_MENU,
	MUSIC_NETHER_BASALT_DELTAS,
	MUSIC_NETHER_CRIMSON_FOREST,
	MUSIC_NETHER_NETHER_WASTES,
	MUSIC_NETHER_SOUL_SAND_VALLEY,
	MUSIC_NETHER_WARPED_FOREST,
	MUSIC_UNDER_WATER,
	PARTICLE_SOUL_ESCAPE,
	UI_BUTTON_CLICK,
	UI_CARTOGRAPHY_TABLE_TAKE_RESULT,
	UI_LOOM_SELECT_PATTERN,
	UI_LOOM_TAKE_RESULT,
	UI_STONECUTTER_SELECT_RECIPE,
	UI_STONECUTTER_TAKE_RESULT,
	UI_TOAST_CHALLENGE_COMPLETE,
	UI_TOAST_IN,
	UI_TOAST_OUT,
	WEATHER_RAIN,
	WEATHER_RAIN_ABOVE,
}
namespace Sound {
	function values(): Sound[]
	function valueOf(arg0: String): Sound
	function getKey(): NamespacedKey
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum EntityType {
	DROPPED_ITEM,
	EXPERIENCE_ORB,
	AREA_EFFECT_CLOUD,
	ELDER_GUARDIAN,
	WITHER_SKELETON,
	STRAY,
	EGG,
	LEASH_HITCH,
	PAINTING,
	ARROW,
	SNOWBALL,
	FIREBALL,
	SMALL_FIREBALL,
	ENDER_PEARL,
	ENDER_SIGNAL,
	SPLASH_POTION,
	THROWN_EXP_BOTTLE,
	ITEM_FRAME,
	WITHER_SKULL,
	PRIMED_TNT,
	FALLING_BLOCK,
	FIREWORK,
	HUSK,
	SPECTRAL_ARROW,
	SHULKER_BULLET,
	DRAGON_FIREBALL,
	ZOMBIE_VILLAGER,
	SKELETON_HORSE,
	ZOMBIE_HORSE,
	ARMOR_STAND,
	DONKEY,
	MULE,
	EVOKER_FANGS,
	EVOKER,
	VEX,
	VINDICATOR,
	ILLUSIONER,
	MINECART_COMMAND,
	BOAT,
	MINECART,
	MINECART_CHEST,
	MINECART_FURNACE,
	MINECART_TNT,
	MINECART_HOPPER,
	MINECART_MOB_SPAWNER,
	CREEPER,
	SKELETON,
	SPIDER,
	GIANT,
	ZOMBIE,
	SLIME,
	GHAST,
	ZOMBIFIED_PIGLIN,
	ENDERMAN,
	CAVE_SPIDER,
	SILVERFISH,
	BLAZE,
	MAGMA_CUBE,
	ENDER_DRAGON,
	WITHER,
	BAT,
	WITCH,
	ENDERMITE,
	GUARDIAN,
	SHULKER,
	PIG,
	SHEEP,
	COW,
	CHICKEN,
	SQUID,
	WOLF,
	MUSHROOM_COW,
	SNOWMAN,
	OCELOT,
	IRON_GOLEM,
	HORSE,
	RABBIT,
	POLAR_BEAR,
	LLAMA,
	LLAMA_SPIT,
	PARROT,
	VILLAGER,
	ENDER_CRYSTAL,
	TURTLE,
	PHANTOM,
	TRIDENT,
	COD,
	SALMON,
	PUFFERFISH,
	TROPICAL_FISH,
	DROWNED,
	DOLPHIN,
	CAT,
	PANDA,
	PILLAGER,
	RAVAGER,
	TRADER_LLAMA,
	WANDERING_TRADER,
	FOX,
	BEE,
	HOGLIN,
	PIGLIN,
	STRIDER,
	ZOGLIN,
	PIGLIN_BRUTE,
	AXOLOTL,
	GLOW_ITEM_FRAME,
	GLOW_SQUID,
	GOAT,
	MARKER,
	FISHING_HOOK,
	LIGHTNING,
	PLAYER,
	UNKNOWN,
}
namespace EntityType {
	function getEntityClass(): Class
	function isSpawnable(): boolean
	function getTypeId(): short
	function fromName(arg0: String): EntityType
	function fromId(arg0: int): EntityType
	function getName(): String
	function values(): EntityType[]
	function valueOf(arg0: String): EntityType
	function getKey(): NamespacedKey
	function isAlive(): boolean
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Result {
	ALLOWED,
	KICK_FULL,
	KICK_BANNED,
	KICK_WHITELIST,
	KICK_OTHER,
}
namespace Result {
	function values(): Result[]
	function valueOf(arg0: String): Result
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Variant {
	RED,
	BLUE,
	GREEN,
	CYAN,
	GRAY,
}
namespace Variant {
	function values(): Variant[]
	function valueOf(arg0: String): Variant
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Rotation {
	NONE,
	CLOCKWISE_45,
	CLOCKWISE,
	CLOCKWISE_135,
	FLIPPED,
	FLIPPED_45,
	COUNTER_CLOCKWISE,
	COUNTER_CLOCKWISE_45,
}
namespace Rotation {
	function rotateClockwise(): Rotation
	function rotateCounterClockwise(): Rotation
	function values(): Rotation[]
	function valueOf(arg0: String): Rotation
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Face {
	FLOOR,
	WALL,
	CEILING,
}
namespace Face {
	function values(): Face[]
	function valueOf(arg0: String): Face
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum FluidCollisionMode {
	NEVER,
	SOURCE_ONLY,
	ALWAYS,
}
namespace FluidCollisionMode {
	function values(): FluidCollisionMode[]
	function valueOf(arg0: String): FluidCollisionMode
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Result {
	ALLOWED,
	KICK_FULL,
	KICK_BANNED,
	KICK_WHITELIST,
	KICK_OTHER,
}
namespace Result {
	function values(): Result[]
	function valueOf(arg0: String): Result
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum DisplaySlot {
	BELOW_NAME,
	PLAYER_LIST,
	SIDEBAR,
}
namespace DisplaySlot {
	function values(): DisplaySlot[]
	function valueOf(arg0: String): DisplaySlot
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ClickType {
	LEFT,
	SHIFT_LEFT,
	RIGHT,
	SHIFT_RIGHT,
	WINDOW_BORDER_LEFT,
	WINDOW_BORDER_RIGHT,
	MIDDLE,
	NUMBER_KEY,
	DOUBLE_CLICK,
	DROP,
	CONTROL_DROP,
	CREATIVE,
	SWAP_OFFHAND,
	UNKNOWN,
}
namespace ClickType {
	function isRightClick(): boolean
	function isLeftClick(): boolean
	function isShiftClick(): boolean
	function isKeyboardClick(): boolean
	function isCreativeAction(): boolean
	function values(): ClickType[]
	function valueOf(arg0: String): ClickType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Color {
	WHITE,
	CREAMY,
	CHESTNUT,
	BROWN,
	BLACK,
	GRAY,
	DARK_BROWN,
}
namespace Color {
	function values(): Color[]
	function valueOf(arg0: String): Color
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Tone {
	G,
	A,
	B,
	C,
	D,
	E,
	F,
}
namespace Tone {
	function isSharpable(): boolean
	function isSharped(arg0: byte): boolean
	function getById(arg0: byte): Tone
	function values(): Tone[]
	function valueOf(arg0: String): Tone
	function getId(): byte
	function getId(arg0: boolean): byte
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Action {
	LEFT_CLICK_BLOCK,
	RIGHT_CLICK_BLOCK,
	LEFT_CLICK_AIR,
	RIGHT_CLICK_AIR,
	PHYSICAL,
}
namespace Action {
	function values(): Action[]
	function valueOf(arg0: String): Action
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ChangeReason {
	LOSING_JOB,
	EMPLOYED,
}
namespace ChangeReason {
	function values(): ChangeReason[]
	function valueOf(arg0: String): ChangeReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum DamageModifier {
	BASE,
	HARD_HAT,
	BLOCKING,
	ARMOR,
	RESISTANCE,
	MAGIC,
	ABSORPTION,
}
namespace DamageModifier {
	function values(): DamageModifier[]
	function valueOf(arg0: String): DamageModifier
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Mirror {
	NONE,
	LEFT_RIGHT,
	FRONT_BACK,
}
namespace Mirror {
	function values(): Mirror[]
	function valueOf(arg0: String): Mirror
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum GameMode {
	CREATIVE,
	SURVIVAL,
	ADVENTURE,
	SPECTATOR,
}
namespace GameMode {
	function getByValue(arg0: int): GameMode
	function values(): GameMode[]
	function valueOf(arg0: String): GameMode
	function getValue(): int
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	TABBY,
	BLACK,
	RED,
	SIAMESE,
	BRITISH_SHORTHAIR,
	CALICO,
	PERSIAN,
	RAGDOLL,
	WHITE,
	JELLIE,
	ALL_BLACK,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Effect {
	CLICK2,
	CLICK1,
	BOW_FIRE,
	DOOR_TOGGLE,
	IRON_DOOR_TOGGLE,
	TRAPDOOR_TOGGLE,
	IRON_TRAPDOOR_TOGGLE,
	FENCE_GATE_TOGGLE,
	DOOR_CLOSE,
	IRON_DOOR_CLOSE,
	TRAPDOOR_CLOSE,
	IRON_TRAPDOOR_CLOSE,
	FENCE_GATE_CLOSE,
	EXTINGUISH,
	RECORD_PLAY,
	GHAST_SHRIEK,
	GHAST_SHOOT,
	BLAZE_SHOOT,
	ZOMBIE_CHEW_WOODEN_DOOR,
	ZOMBIE_CHEW_IRON_DOOR,
	ZOMBIE_DESTROY_DOOR,
	SMOKE,
	STEP_SOUND,
	POTION_BREAK,
	INSTANT_POTION_BREAK,
	ENDER_SIGNAL,
	MOBSPAWNER_FLAMES,
	BREWING_STAND_BREW,
	CHORUS_FLOWER_GROW,
	CHORUS_FLOWER_DEATH,
	PORTAL_TRAVEL,
	ENDEREYE_LAUNCH,
	FIREWORK_SHOOT,
	VILLAGER_PLANT_GROW,
	DRAGON_BREATH,
	ANVIL_BREAK,
	ANVIL_USE,
	ANVIL_LAND,
	ENDERDRAGON_SHOOT,
	WITHER_BREAK_BLOCK,
	WITHER_SHOOT,
	ZOMBIE_INFECT,
	ZOMBIE_CONVERTED_VILLAGER,
	BAT_TAKEOFF,
	END_GATEWAY_SPAWN,
	ENDERDRAGON_GROWL,
}
namespace Effect {
	function getData(): Class
	function getById(arg0: int): Effect
	function values(): Effect[]
	function valueOf(arg0: String): Effect
	function getId(): int
	function getType(): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum DragType {
	SINGLE,
	EVEN,
}
namespace DragType {
	function values(): DragType[]
	function valueOf(arg0: String): DragType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum HookState {
	UNHOOKED,
	HOOKED_ENTITY,
	BOBBING,
}
namespace HookState {
	function values(): HookState[]
	function valueOf(arg0: String): HookState
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	RED,
	SNOW,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Height {
	NONE,
	LOW,
	TALL,
}
namespace Height {
	function values(): Height[]
	function valueOf(arg0: String): Height
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Attachment {
	FLOOR,
	CEILING,
	SINGLE_WALL,
	DOUBLE_WALL,
}
namespace Attachment {
	function values(): Attachment[]
	function valueOf(arg0: String): Attachment
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum BarStyle {
	SOLID,
	SEGMENTED_6,
	SEGMENTED_10,
	SEGMENTED_12,
	SEGMENTED_20,
}
namespace BarStyle {
	function values(): BarStyle[]
	function valueOf(arg0: String): BarStyle
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	WHITE_POINTER,
	GREEN_POINTER,
	RED_POINTER,
	BLUE_POINTER,
	WHITE_CROSS,
	RED_MARKER,
	WHITE_CIRCLE,
	SMALL_WHITE_CIRCLE,
	MANSION,
	TEMPLE,
	BANNER_WHITE,
	BANNER_ORANGE,
	BANNER_MAGENTA,
	BANNER_LIGHT_BLUE,
	BANNER_YELLOW,
	BANNER_LIME,
	BANNER_PINK,
	BANNER_GRAY,
	BANNER_LIGHT_GRAY,
	BANNER_CYAN,
	BANNER_PURPLE,
	BANNER_BLUE,
	BANNER_BROWN,
	BANNER_GREEN,
	BANNER_RED,
	BANNER_BLACK,
	RED_X,
}
namespace Type {
	function byValue(arg0: byte): Type
	function values(): Type[]
	function valueOf(arg0: String): Type
	function getValue(): byte
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Orientation {
	DOWN_EAST,
	DOWN_NORTH,
	DOWN_SOUTH,
	DOWN_WEST,
	UP_EAST,
	UP_NORTH,
	UP_SOUTH,
	UP_WEST,
	WEST_UP,
	EAST_UP,
	NORTH_UP,
	SOUTH_UP,
}
namespace Orientation {
	function values(): Orientation[]
	function valueOf(arg0: String): Orientation
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Mode {
	COMPARE,
	SUBTRACT,
}
namespace Mode {
	function values(): Mode[]
	function valueOf(arg0: String): Mode
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum SkipReason {
	COMMAND,
	CUSTOM,
	NIGHT_SKIP,
}
namespace SkipReason {
	function values(): SkipReason[]
	function valueOf(arg0: String): SkipReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Style {
	NONE,
	WHITE,
	WHITEFIELD,
	WHITE_DOTS,
	BLACK_DOTS,
}
namespace Style {
	function values(): Style[]
	function valueOf(arg0: String): Style
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum WeatherType {
	DOWNFALL,
	CLEAR,
}
namespace WeatherType {
	function values(): WeatherType[]
	function valueOf(arg0: String): WeatherType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	BALL,
	BALL_LARGE,
	STAR,
	BURST,
	CREEPER,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Attribute {
	GENERIC_MAX_HEALTH,
	GENERIC_FOLLOW_RANGE,
	GENERIC_KNOCKBACK_RESISTANCE,
	GENERIC_MOVEMENT_SPEED,
	GENERIC_FLYING_SPEED,
	GENERIC_ATTACK_DAMAGE,
	GENERIC_ATTACK_KNOCKBACK,
	GENERIC_ATTACK_SPEED,
	GENERIC_ARMOR,
	GENERIC_ARMOR_TOUGHNESS,
	GENERIC_LUCK,
	HORSE_JUMP_STRENGTH,
	ZOMBIE_SPAWN_REINFORCEMENTS,
}
namespace Attribute {
	function values(): Attribute[]
	function valueOf(arg0: String): Attribute
	function getKey(): NamespacedKey
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Generation {
	ORIGINAL,
	COPY_OF_ORIGINAL,
	COPY_OF_COPY,
	TATTERED,
}
namespace Generation {
	function values(): Generation[]
	function valueOf(arg0: String): Generation
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum RemoveCause {
	ENTITY,
	EXPLOSION,
	OBSTRUCTION,
	PHYSICS,
	DEFAULT,
}
namespace RemoveCause {
	function values(): RemoveCause[]
	function valueOf(arg0: String): RemoveCause
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum InventoryAction {
	NOTHING,
	PICKUP_ALL,
	PICKUP_SOME,
	PICKUP_HALF,
	PICKUP_ONE,
	PLACE_ALL,
	PLACE_SOME,
	PLACE_ONE,
	SWAP_WITH_CURSOR,
	DROP_ALL_CURSOR,
	DROP_ONE_CURSOR,
	DROP_ALL_SLOT,
	DROP_ONE_SLOT,
	MOVE_TO_OTHER_INVENTORY,
	HOTBAR_MOVE_AND_READD,
	HOTBAR_SWAP,
	CLONE_STACK,
	COLLECT_TO_CURSOR,
	UNKNOWN,
}
namespace InventoryAction {
	function values(): InventoryAction[]
	function valueOf(arg0: String): InventoryAction
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum InventoryType {
	CHEST,
	DISPENSER,
	DROPPER,
	FURNACE,
	WORKBENCH,
	CRAFTING,
	ENCHANTING,
	BREWING,
	PLAYER,
	CREATIVE,
	MERCHANT,
	ENDER_CHEST,
	ANVIL,
	SMITHING,
	BEACON,
	HOPPER,
	SHULKER_BOX,
	BARREL,
	BLAST_FURNACE,
	LECTERN,
	SMOKER,
	LOOM,
	CARTOGRAPHY,
	GRINDSTONE,
	STONECUTTER,
	COMPOSTER,
}
namespace InventoryType {
	function isCreatable(): boolean
	function getDefaultSize(): int
	function getDefaultTitle(): String
	function values(): InventoryType[]
	function valueOf(arg0: String): InventoryType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum State {
	FISHING,
	CAUGHT_FISH,
	CAUGHT_ENTITY,
	IN_GROUND,
	FAILED_ATTEMPT,
	REEL_IN,
	BITE,
}
namespace State {
	function values(): State[]
	function valueOf(arg0: String): State
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Cause {
	COMMAND,
	TRIDENT,
	TRAP,
	WEATHER,
	UNKNOWN,
}
namespace Cause {
	function values(): Cause[]
	function valueOf(arg0: String): Cause
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ChangeReason {
	BUCKET_FILL,
	BUCKET_EMPTY,
	BOTTLE_FILL,
	BOTTLE_EMPTY,
	BANNER_WASH,
	ARMOR_WASH,
	SHULKER_WASH,
	EXTINGUISH,
	EVAPORATE,
	NATURAL_FILL,
	UNKNOWN,
}
namespace ChangeReason {
	function values(): ChangeReason[]
	function valueOf(arg0: String): ChangeReason
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Result {
	DENY,
	DEFAULT,
	ALLOW,
}
namespace Result {
	function values(): Result[]
	function valueOf(arg0: String): Result
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Variant {
	LUCY,
	WILD,
	GOLD,
	CYAN,
	BLUE,
}
namespace Variant {
	function values(): Variant[]
	function valueOf(arg0: String): Variant
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum SandstoneType {
	CRACKED,
	GLYPHED,
	SMOOTH,
}
namespace SandstoneType {
	function getData(): byte
	function getByData(arg0: byte): SandstoneType
	function values(): SandstoneType[]
	function valueOf(arg0: String): SandstoneType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum WorldType {
	NORMAL,
	FLAT,
	LARGE_BIOMES,
	AMPLIFIED,
}
namespace WorldType {
	function getName(): String
	function values(): WorldType[]
	function valueOf(arg0: String): WorldType
	function getByName(arg0: String): WorldType
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Leaves {
	NONE,
	SMALL,
	LARGE,
}
namespace Leaves {
	function values(): Leaves[]
	function valueOf(arg0: String): Leaves
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Particle {
	EXPLOSION_NORMAL,
	EXPLOSION_LARGE,
	EXPLOSION_HUGE,
	FIREWORKS_SPARK,
	WATER_BUBBLE,
	WATER_SPLASH,
	WATER_WAKE,
	SUSPENDED,
	SUSPENDED_DEPTH,
	CRIT,
	CRIT_MAGIC,
	SMOKE_NORMAL,
	SMOKE_LARGE,
	SPELL,
	SPELL_INSTANT,
	SPELL_MOB,
	SPELL_MOB_AMBIENT,
	SPELL_WITCH,
	DRIP_WATER,
	DRIP_LAVA,
	VILLAGER_ANGRY,
	VILLAGER_HAPPY,
	TOWN_AURA,
	NOTE,
	PORTAL,
	ENCHANTMENT_TABLE,
	FLAME,
	LAVA,
	CLOUD,
	REDSTONE,
	SNOWBALL,
	SNOW_SHOVEL,
	SLIME,
	HEART,
	BARRIER,
	ITEM_CRACK,
	BLOCK_CRACK,
	BLOCK_DUST,
	WATER_DROP,
	MOB_APPEARANCE,
	DRAGON_BREATH,
	END_ROD,
	DAMAGE_INDICATOR,
	SWEEP_ATTACK,
	FALLING_DUST,
	TOTEM,
	SPIT,
	SQUID_INK,
	BUBBLE_POP,
	CURRENT_DOWN,
	BUBBLE_COLUMN_UP,
	NAUTILUS,
	DOLPHIN,
	SNEEZE,
	CAMPFIRE_COSY_SMOKE,
	CAMPFIRE_SIGNAL_SMOKE,
	COMPOSTER,
	FLASH,
	FALLING_LAVA,
	LANDING_LAVA,
	FALLING_WATER,
	DRIPPING_HONEY,
	FALLING_HONEY,
	LANDING_HONEY,
	FALLING_NECTAR,
	SOUL_FIRE_FLAME,
	ASH,
	CRIMSON_SPORE,
	WARPED_SPORE,
	SOUL,
	DRIPPING_OBSIDIAN_TEAR,
	FALLING_OBSIDIAN_TEAR,
	LANDING_OBSIDIAN_TEAR,
	REVERSE_PORTAL,
	WHITE_ASH,
	LIGHT,
	DUST_COLOR_TRANSITION,
	VIBRATION,
	FALLING_SPORE_BLOSSOM,
	SPORE_BLOSSOM_AIR,
	SMALL_FLAME,
	SNOWFLAKE,
	DRIPPING_DRIPSTONE_LAVA,
	FALLING_DRIPSTONE_LAVA,
	DRIPPING_DRIPSTONE_WATER,
	FALLING_DRIPSTONE_WATER,
	GLOW_SQUID_INK,
	GLOW,
	WAX_ON,
	WAX_OFF,
	ELECTRIC_SPARK,
	SCRAPE,
	LEGACY_BLOCK_CRACK,
	LEGACY_BLOCK_DUST,
	LEGACY_FALLING_DUST,
}
namespace Particle {
	function getDataType(): Class
	function values(): Particle[]
	function valueOf(arg0: String): Particle
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Action {
	ADDED,
	CHANGED,
	CLEARED,
	REMOVED,
}
namespace Action {
	function values(): Action[]
	function valueOf(arg0: String): Action
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Cause {
	AREA_EFFECT_CLOUD,
	ARROW,
	ATTACK,
	AXOLOTL,
	BEACON,
	COMMAND,
	CONDUIT,
	CONVERSION,
	DEATH,
	DOLPHIN,
	EXPIRATION,
	FOOD,
	ILLUSION,
	MILK,
	PATROL_CAPTAIN,
	PLUGIN,
	POTION_DRINK,
	POTION_SPLASH,
	SPIDER_SPAWN,
	TOTEM,
	TURTLE_HELMET,
	UNKNOWN,
	VILLAGER_TRADE,
	WITHER_ROSE,
}
namespace Cause {
	function values(): Cause[]
	function valueOf(arg0: String): Cause
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Operation {
	ADD_NUMBER,
	ADD_SCALAR,
	MULTIPLY_SCALAR_1,
}
namespace Operation {
	function values(): Operation[]
	function valueOf(arg0: String): Operation
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum OptionStatus {
	ALWAYS,
	NEVER,
	FOR_OTHER_TEAMS,
	FOR_OWN_TEAM,
}
namespace OptionStatus {
	function values(): OptionStatus[]
	function valueOf(arg0: String): OptionStatus
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum ChatColor {
	BLACK,
	DARK_BLUE,
	DARK_GREEN,
	DARK_AQUA,
	DARK_RED,
	DARK_PURPLE,
	GOLD,
	GRAY,
	DARK_GRAY,
	BLUE,
	GREEN,
	AQUA,
	RED,
	LIGHT_PURPLE,
	YELLOW,
	WHITE,
	MAGIC,
	BOLD,
	STRIKETHROUGH,
	UNDERLINE,
	ITALIC,
	RESET,
}
namespace ChatColor {
	function getLastColors(arg0: String): String
	function isColor(): boolean
	function getByChar(arg0: String): ChatColor
	function getByChar(arg0: char): ChatColor
	function asBungee(): ChatColor
	function isFormat(): boolean
	function stripColor(arg0: String): String
	function translateAlternateColorCodes(arg0: char, arg1: String): String
	function toString(): String
	function values(): ChatColor[]
	function getChar(): char
	function valueOf(arg0: String): ChatColor
	function name(): String
	function equals(arg0: Object): boolean
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Variant {
	RED,
	BROWN,
}
namespace Variant {
	function values(): Variant[]
	function valueOf(arg0: String): Variant
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum Type {
	WILD_OCELOT,
	BLACK_CAT,
	RED_CAT,
	SIAMESE_CAT,
}
namespace Type {
	function values(): Type[]
	function valueOf(arg0: String): Type
	function getId(): int
	function getType(arg0: int): Type
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare enum RaidStatus {
	ONGOING,
	VICTORY,
	LOSS,
	STOPPED,
}
namespace RaidStatus {
	function values(): RaidStatus[]
	function valueOf(arg0: String): RaidStatus
	function name(): String
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function compareTo(arg0: Object): int
	function compareTo(arg0: Enum): int
	function valueOf(arg0: Class, arg1: String): Enum
	function describeConstable(): Optional
	function getDeclaringClass(): Class
	function ordinal(): int
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PerlinNoiseGenerator extends NoiseGenerator {
	getNoise(arg0: double): double
	getNoise(arg0: double, arg1: double, arg2: double, arg3: int, arg4: double, arg5: double): double
	getNoise(arg0: double, arg1: double, arg2: double): double
	getNoise(arg0: double, arg1: int, arg2: double, arg3: double): double
	getNoise(arg0: double, arg1: double, arg2: int, arg3: double, arg4: double): double
	getNoise(arg0: double, arg1: double): double
	noise(arg0: double, arg1: double, arg2: double): double
	getInstance(): PerlinNoiseGenerator
}
declare class SmithingRecipe implements Recipe, Keyed {
	getAddition(): RecipeChoice
	getBase(): RecipeChoice
	getKey(): NamespacedKey
	getResult(): ItemStack
}
declare interface DaylightDetector extends TileState {
}
namespace EntitySpawnEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityTameEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function getOwner(): AnimalTamer
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace FurnaceBurnEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBurnTime(): int
	function setBurnTime(arg0: int): void
	function getFuel(): ItemStack
	function isBurning(): boolean
	function setBurning(arg0: boolean): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace ServerCommandEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getCommand(): String
	function setCommand(arg0: String): void
	function getSender(): CommandSender
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Diode extends MaterialData implements Directional, Redstone {
	setFacingDirection(arg0: BlockFace): void
	setDelay(arg0: int): void
	getDelay(): int
	getFacing(): BlockFace
	isPowered(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Diode
	clone(): MaterialData
}
declare interface Jigsaw extends TileState {
}
declare class Location implements Cloneable, ConfigurationSerializable {
	isWorldLoaded(): boolean
	getDirection(): Vector
	setDirection(arg0: Vector): Location
	lengthSquared(): double
	distanceSquared(arg0: Location): double
	checkFinite(): void
	deserialize(arg0: Map): Location
	normalizeYaw(arg0: float): float
	normalizePitch(arg0: float): float
	setWorld(arg0: World): void
	setX(arg0: double): void
	getBlockX(): int
	locToBlock(arg0: double): int
	setY(arg0: double): void
	getBlockY(): int
	setZ(arg0: double): void
	getBlockZ(): int
	setYaw(arg0: float): void
	getYaw(): float
	setPitch(arg0: float): void
	getPitch(): float
	subtract(arg0: Location): Location
	subtract(arg0: double, arg1: double, arg2: double): Location
	subtract(arg0: Vector): Location
	toVector(): Vector
	serialize(): Map
	getBlock(): Block
	getWorld(): World
	getX(): double
	getY(): double
	getZ(): double
	getChunk(): Chunk
	add(arg0: Vector): Location
	add(arg0: double, arg1: double, arg2: double): Location
	add(arg0: Location): Location
	equals(arg0: Object): boolean
	length(): double
	toString(): String
	hashCode(): int
	clone(): Location
	clone(): Object
	zero(): Location
	distance(arg0: Location): double
	multiply(arg0: double): Location
}
declare interface HelpTopicFactory {
	createTopic(arg0: Command): HelpTopic
}
declare class PressurePlate extends MaterialData implements PressureSensor {
	isPressed(): boolean
	toString(): String
	clone(): PressurePlate
	clone(): MaterialData
	clone(): Object
}
declare class TrapDoor extends SimpleAttachableMaterialData implements Openable {
	setFacingDirection(arg0: BlockFace): void
	setInverted(arg0: boolean): void
	getAttachedFace(): BlockFace
	setOpen(arg0: boolean): void
	isInverted(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): MaterialData
	clone(): Object
	clone(): SimpleAttachableMaterialData
	clone(): TrapDoor
	isOpen(): boolean
}
declare interface SculkSensor extends TileState {
	setLastVibrationFrequency(arg0: int): void
	getLastVibrationFrequency(): int
}
declare interface Sign extends TileState, Colorable {
	setEditable(arg0: boolean): void
	isGlowingText(): boolean
	setGlowingText(arg0: boolean): void
	getLines(): String[]
	getLine(arg0: int): String
	setLine(arg0: int, arg1: String): void
	isEditable(): boolean
}
declare interface Blaze extends Monster {
}
namespace PlayerBucketEntityEvent {
	function getOriginalBucket(): ItemStack
	function getEntityBucket(): ItemStack
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Zoglin extends Monster, Ageable {
	isBaby(): boolean
	setBaby(arg0: boolean): void
}
declare class Hopper extends MaterialData implements Directional, Redstone {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	isPowered(): boolean
	setActive(arg0: boolean): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Hopper
	clone(): Object
	clone(): MaterialData
	isActive(): boolean
}
declare interface TabExecutor extends TabCompleter, CommandExecutor {
}
declare interface FurnaceInventory extends Inventory {
	setSmelting(arg0: ItemStack): void
	getSmelting(): ItemStack
	getFuel(): ItemStack
	setFuel(arg0: ItemStack): void
	getHolder(): Furnace
	getHolder(): InventoryHolder
	setResult(arg0: ItemStack): void
	getResult(): ItemStack
}
declare class Tripwire extends MaterialData {
	isActivated(): boolean
	setActivated(arg0: boolean): void
	isObjectTriggering(): boolean
	setObjectTriggering(arg0: boolean): void
	toString(): String
	clone(): Tripwire
	clone(): MaterialData
	clone(): Object
}
declare class EulerAngle {
	setX(arg0: double): EulerAngle
	setY(arg0: double): EulerAngle
	setZ(arg0: double): EulerAngle
	subtract(arg0: double, arg1: double, arg2: double): EulerAngle
	getX(): double
	getY(): double
	getZ(): double
	add(arg0: double, arg1: double, arg2: double): EulerAngle
	equals(arg0: Object): boolean
	hashCode(): int
}
namespace InventoryOpenEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getPlayer(): HumanEntity
	function getHandlers(): HandlerList
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Flags extends Enum implements PluginAwareness {
	values(): Flags[]
	valueOf(arg0: String): Flags
}
declare interface Redstone {
	isPowered(): boolean
}
declare class Step extends TexturedMaterial {
	setInverted(arg0: boolean): void
	getTextures(): List
	getTextureIndex(): int
	setTextureIndex(arg0: int): void
	isInverted(): boolean
	toString(): String
	clone(): MaterialData
	clone(): Object
	clone(): TexturedMaterial
	clone(): Step
}
declare class Rails extends MaterialData {
	getDirection(): BlockFace
	setDirection(arg0: BlockFace, arg1: boolean): void
	getConvertedData(): byte
	isOnSlope(): boolean
	isCurve(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Rails
	clone(): Object
	clone(): MaterialData
}
declare interface IronGolem extends Golem {
	isPlayerCreated(): boolean
	setPlayerCreated(arg0: boolean): void
}
namespace ExplosionPrimeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRadius(): float
	function setRadius(arg0: float): void
	function getFire(): boolean
	function setFire(arg0: boolean): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockGrowEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getNewState(): BlockState
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Wither extends Monster, Boss {
}
namespace HangingBreakByEntityEvent {
	function getRemover(): Entity
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getCause(): RemoveCause
	function getHandlers(): HandlerList
	function getEntity(): Hanging
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BannerMeta extends ItemMeta {
	getBaseColor(): DyeColor
	setBaseColor(arg0: DyeColor): void
	getPatterns(): List
	setPatterns(arg0: List): void
	removePattern(arg0: int): Pattern
	numberOfPatterns(): int
	addPattern(arg0: Pattern): void
	getPattern(arg0: int): Pattern
	setPattern(arg0: int, arg1: Pattern): void
}
declare class Spigot extends Spigot {
	isSilent(): boolean
}
declare interface Warning extends Annotation {
	value(): boolean
	reason(): String
}
namespace InventoryCreativeEvent {
	function getCursor(): ItemStack
	function setCursor(arg0: ItemStack): void
	function getHandlerList(): HandlerList
	function getSlotType(): SlotType
	function getCurrentItem(): ItemStack
	function isRightClick(): boolean
	function isLeftClick(): boolean
	function isShiftClick(): boolean
	function setCurrentItem(arg0: ItemStack): void
	function getClickedInventory(): Inventory
	function getHotbarButton(): int
	function getRawSlot(): int
	function getAction(): InventoryAction
	function getClick(): ClickType
	function getSlot(): int
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getWhoClicked(): HumanEntity
	function setResult(arg0: Result): void
	function getResult(): Result
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface CommandMap {
	registerAll(arg0: String, arg1: List): void
	clearCommands(): void
	tabComplete(arg0: CommandSender, arg1: String, arg2: Location): List
	tabComplete(arg0: CommandSender, arg1: String): List
	getCommand(arg0: String): Command
	dispatch(arg0: CommandSender, arg1: String): boolean
	register(arg0: String, arg1: String, arg2: Command): boolean
	register(arg0: String, arg1: Command): boolean
}
declare interface Prompt extends Cloneable {
	getPromptText(arg0: ConversationContext): String
	blocksForInput(arg0: ConversationContext): boolean
	acceptInput(arg0: ConversationContext, arg1: String): Prompt
}
declare interface Lightable extends BlockData {
	isLit(): boolean
	setLit(arg0: boolean): void
}
declare interface Directional extends BlockData {
	getFacing(): BlockFace
	setFacing(arg0: BlockFace): void
	getFaces(): Set
}
namespace PlayerLocaleChangeEvent {
	function getHandlerList(): HandlerList
	function getLocale(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface ExplosiveMinecart extends Minecart {
}
declare interface Spellcaster extends Illager {
	getSpell(): Spell
	setSpell(arg0: Spell): void
}
namespace VehicleEntityCollisionEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isPickupCancelled(): boolean
	function setPickupCancelled(arg0: boolean): void
	function isCollisionCancelled(): boolean
	function setCollisionCancelled(arg0: boolean): void
	function getEntity(): Entity
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace VehicleDamageEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getAttacker(): Entity
	function setDamage(arg0: double): void
	function getDamage(): double
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface CachedServerIcon {
}
declare interface BanEntry {
	getExpiration(): Date
	setExpiration(arg0: Date): void
	getCreated(): Date
	setCreated(arg0: Date): void
	setSource(arg0: String): void
	setReason(arg0: String): void
	save(): void
	getTarget(): String
	getReason(): String
	getSource(): String
}
declare interface AnvilInventory extends Inventory {
	getRenameText(): String
	getRepairCost(): int
	setRepairCost(arg0: int): void
	getMaximumRepairCost(): int
	setMaximumRepairCost(arg0: int): void
}
declare interface SuspiciousStewMeta extends ItemMeta {
	hasCustomEffects(): boolean
	getCustomEffects(): List
	addCustomEffect(arg0: PotionEffect, arg1: boolean): boolean
	removeCustomEffect(arg0: PotionEffectType): boolean
	hasCustomEffect(arg0: PotionEffectType): boolean
	clearCustomEffects(): boolean
	clone(): Object
	clone(): ItemMeta
	clone(): SuspiciousStewMeta
}
declare class Skull extends MaterialData implements Directional {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Skull
	clone(): MaterialData
}
namespace PlayerLevelChangeEvent {
	function getHandlerList(): HandlerList
	function getOldLevel(): int
	function getNewLevel(): int
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerResourcePackStatusEvent {
	function getHandlerList(): HandlerList
	function getStatus(): Status
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class YamlConfiguration extends FileConfiguration {
	saveToString(): String
	buildHeader(): String
	loadFromString(arg0: String): void
	parseHeader(arg0: String): String
	convertMapsToSections(arg0: Map, arg1: ConfigurationSection): void
	loadConfiguration(arg0: Reader): YamlConfiguration
	loadConfiguration(arg0: File): YamlConfiguration
	options(): MemoryConfigurationOptions
	options(): ConfigurationOptions
	options(): FileConfigurationOptions
	options(): YamlConfigurationOptions
}
namespace EntityCombustByBlockEvent {
	function getCombuster(): Block
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getDuration(): int
	function setDuration(arg0: int): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class EnchantmentOffer {
	getEnchantment(): Enchantment
	setEnchantment(arg0: Enchantment): void
	getEnchantmentLevel(): int
	setEnchantmentLevel(arg0: int): void
	getCost(): int
	setCost(arg0: int): void
}
declare class RegexPrompt extends ValidatingPrompt {
	isInputValid(arg0: ConversationContext, arg1: String): boolean
}
declare interface PersistentDataAdapterContext {
	newPersistentDataContainer(): PersistentDataContainer
}
declare class ChatPaginator {
	paginate(arg0: String, arg1: int, arg2: int, arg3: int): ChatPage
	paginate(arg0: String, arg1: int): ChatPage
	wordWrap(arg0: String, arg1: int): String[]
}
declare interface MerchantInventory extends Inventory {
	getSelectedRecipeIndex(): int
	getSelectedRecipe(): MerchantRecipe
	getMerchant(): Merchant
}
declare interface Stairs extends Bisected, Directional, Waterlogged {
	getShape(): Shape
	setShape(arg0: Shape): void
}
declare class ChunkGenerator {
	generateChunkData(arg0: World, arg1: Random, arg2: int, arg3: int, arg4: BiomeGrid): ChunkData
	createChunkData(arg0: World): ChunkData
	getDefaultPopulators(arg0: World): List
	getFixedSpawnLocation(arg0: World, arg1: Random): Location
	isParallelCapable(): boolean
	shouldGenerateCaves(): boolean
	shouldGenerateDecorations(): boolean
	shouldGenerateMobs(): boolean
	shouldGenerateStructures(): boolean
	canSpawn(arg0: World, arg1: int, arg2: int): boolean
	$SWITCH_TABLE$org$bukkit$World$Environment(): int[]
}
declare interface Illager extends Raider {
}
declare interface PoweredMinecart extends Minecart {
	getFuel(): int
	setFuel(arg0: int): void
}
namespace TimeSkipEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getSkipReason(): SkipReason
	function getSkipAmount(): long
	function setSkipAmount(arg0: long): void
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface PressureSensor {
	isPressed(): boolean
}
declare class LootTables extends Enum implements Keyed {
	getLootTable(): LootTable
	values(): LootTables[]
	valueOf(arg0: String): LootTables
	getKey(): NamespacedKey
}
namespace PluginEvent {
	function getPlugin(): Plugin
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Pillager extends Illager, InventoryHolder {
}
declare class StringPrompt implements Prompt {
	blocksForInput(arg0: ConversationContext): boolean
}
declare interface MagmaCube extends Slime {
}
declare interface CommandMinecart extends Minecart {
	getCommand(): String
	setCommand(arg0: String): void
	setName(arg0: String): void
}
declare interface BanList {
	getBanEntry(arg0: String): BanEntry
	getBanEntries(): Set
	addBan(arg0: String, arg1: String, arg2: Date, arg3: String): BanEntry
	isBanned(arg0: String): boolean
	pardon(arg0: String): void
}
declare class EntityType extends Enum implements Keyed {
	getEntityClass(): Class
	isSpawnable(): boolean
	getTypeId(): short
	fromName(arg0: String): EntityType
	fromId(arg0: int): EntityType
	getName(): String
	values(): EntityType[]
	valueOf(arg0: String): EntityType
	getKey(): NamespacedKey
	isAlive(): boolean
}
declare interface Lockable {
	getLock(): String
	setLock(arg0: String): void
	isLocked(): boolean
}
namespace RemoteServerCommandEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getCommand(): String
	function setCommand(arg0: String): void
	function getSender(): CommandSender
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class BroadcastPermissions {
	registerPermissions(arg0: Permission): Permission
}
declare class DustTransition extends DustOptions {
	getToColor(): Color
}
namespace EntityBreedEvent {
	function setExperience(arg0: int): void
	function getBredWith(): ItemStack
	function getExperience(): int
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function getMother(): LivingEntity
	function getFather(): LivingEntity
	function getBreeder(): LivingEntity
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Snow extends BlockData {
	getMinimumLayers(): int
	getMaximumLayers(): int
	getLayers(): int
	setLayers(arg0: int): void
}
declare class NullConversationPrefix implements ConversationPrefix {
	getPrefix(arg0: ConversationContext): String
}
declare interface RemoteConsoleCommandSender extends CommandSender {
}
declare class Wool extends MaterialData implements Colorable {
	getColor(): DyeColor
	toString(): String
	clone(): Wool
	clone(): MaterialData
	clone(): Object
	setColor(arg0: DyeColor): void
}
namespace InventoryPickupItemEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getInventory(): Inventory
	function getItem(): Item
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Pig extends Steerable, Vehicle {
}
declare interface Wall extends Waterlogged {
	getHeight(arg0: BlockFace): Height
	isUp(): boolean
	setUp(arg0: boolean): void
	setHeight(arg0: BlockFace, arg1: Height): void
}
declare interface ShulkerBox extends Container, Lootable, Lidded {
	getColor(): DyeColor
}
declare class PlayerNamePrompt extends ValidatingPrompt {
	isInputValid(arg0: ConversationContext, arg1: String): boolean
	acceptValidatedInput(arg0: ConversationContext, arg1: Player): Prompt
	acceptValidatedInput(arg0: ConversationContext, arg1: String): Prompt
}
declare interface Cod extends Fish {
}
namespace WeatherChangeEvent {
	function toWeatherState(): boolean
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Trident extends AbstractArrow, ThrowableProjectile {
}
namespace VehicleDestroyEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getAttacker(): Entity
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Consumer {
	accept(arg0: Object): void
}
declare interface WorldBorder {
	getDamageBuffer(): double
	setDamageBuffer(arg0: double): void
	getDamageAmount(): double
	setDamageAmount(arg0: double): void
	getWarningTime(): int
	setWarningTime(arg0: int): void
	getWarningDistance(): int
	setWarningDistance(arg0: int): void
	getCenter(): Location
	setCenter(arg0: Location): void
	setCenter(arg0: double, arg1: double): void
	isInside(arg0: Location): boolean
	getSize(): double
	reset(): void
	setSize(arg0: double, arg1: long): void
	setSize(arg0: double): void
}
declare interface Llama extends ChestedHorse {
	getStrength(): int
	setStrength(arg0: int): void
	getInventory(): Inventory
	getInventory(): LlamaInventory
	getInventory(): AbstractHorseInventory
	getColor(): Color
	setColor(arg0: Color): void
}
declare interface MushroomCow extends Cow {
	setVariant(arg0: Variant): void
	getVariant(): Variant
}
declare class TimingsCommand extends BukkitCommand {
	executeSpigotTimings(arg0: CommandSender, arg1: String[]): void
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[]): List
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
}
declare interface MapView {
	getRenderers(): List
	addRenderer(arg0: MapRenderer): void
	removeRenderer(arg0: MapRenderer): boolean
	isTrackingPosition(): boolean
	setTrackingPosition(arg0: boolean): void
	isUnlimitedTracking(): boolean
	setUnlimitedTracking(arg0: boolean): void
	setWorld(arg0: World): void
	getWorld(): World
	isVirtual(): boolean
	getScale(): Scale
	setScale(arg0: Scale): void
	getCenterX(): int
	getCenterZ(): int
	setCenterX(arg0: int): void
	setCenterZ(arg0: int): void
	setLocked(arg0: boolean): void
	getId(): int
	isLocked(): boolean
}
declare class Wood extends MaterialData {
	getSpeciesType(arg0: Material, arg1: TreeSpecies): Material
	setSpecies(arg0: TreeSpecies): void
	getSpecies(): TreeSpecies
	$SWITCH_TABLE$org$bukkit$Material(): int[]
	$SWITCH_TABLE$org$bukkit$TreeSpecies(): int[]
	toString(): String
	clone(): Wood
	clone(): MaterialData
	clone(): Object
}
declare interface PiglinAbstract extends Monster, Ageable {
	isImmuneToZombification(): boolean
	setImmuneToZombification(arg0: boolean): void
	getConversionTime(): int
	setConversionTime(arg0: int): void
	isConverting(): boolean
	isBaby(): boolean
	setBaby(arg0: boolean): void
}
namespace CraftItemEvent {
	function getInventory(): Inventory
	function getInventory(): CraftingInventory
	function getRecipe(): Recipe
	function getHandlerList(): HandlerList
	function getSlotType(): SlotType
	function getCurrentItem(): ItemStack
	function isRightClick(): boolean
	function isLeftClick(): boolean
	function isShiftClick(): boolean
	function setCurrentItem(arg0: ItemStack): void
	function getClickedInventory(): Inventory
	function getHotbarButton(): int
	function getCursor(): ItemStack
	function setCursor(arg0: ItemStack): void
	function getRawSlot(): int
	function getAction(): InventoryAction
	function getClick(): ClickType
	function getSlot(): int
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getWhoClicked(): HumanEntity
	function setResult(arg0: Result): void
	function getResult(): Result
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace LeavesDecayEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Command extends MaterialData implements Redstone {
	isPowered(): boolean
	setPowered(arg0: boolean): void
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): Command
}
namespace PigZombieAngerEvent {
	function getNewAnger(): int
	function setNewAnger(arg0: int): void
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): PigZombie
	function getTarget(): Entity
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface ScoreboardManager {
	getMainScoreboard(): Scoreboard
	getNewScoreboard(): Scoreboard
}
declare class PerlinOctaveGenerator extends OctaveGenerator {
	createOctaves(arg0: Random, arg1: int): NoiseGenerator[]
}
namespace WorldEvent {
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface TripwireHook extends Attachable, Directional, Powerable {
}
namespace BlockExplodeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getYield(): float
	function blockList(): List
	function setYield(arg0: float): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface TippedArrow extends Arrow {
}
declare interface Cow extends Animals {
}
declare interface RedstoneWire extends AnaloguePowerable {
	getAllowedFaces(): Set
	getFace(arg0: BlockFace): Connection
	setFace(arg0: BlockFace, arg1: Connection): void
}
declare interface Goat extends Animals {
	isScreaming(): boolean
	setScreaming(arg0: boolean): void
}
declare interface Furnace extends Directional, Lightable {
}
declare interface TechnicalPiston extends Directional {
	setType(arg0: Type): void
	getType(): Type
}
declare interface RespawnAnchor extends BlockData {
	getMaximumCharges(): int
	getCharges(): int
	setCharges(arg0: int): void
}
namespace EntityUnleashEvent {
	function getHandlerList(): HandlerList
	function getReason(): UnleashReason
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace SlimeSplitEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Slime
	function getEntity(): Entity
	function setCount(arg0: int): void
	function getCount(): int
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerVelocityEvent {
	function setVelocity(arg0: Vector): void
	function getVelocity(): Vector
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BeaconInventory extends Inventory {
	setItem(arg0: ItemStack): void
	getItem(): ItemStack
}
declare interface EnderChest extends TileState {
}
declare interface Chest extends Directional, Waterlogged {
	setType(arg0: Type): void
	getType(): Type
}
declare class YamlConfigurationOptions extends FileConfigurationOptions {
	copyDefaults(arg0: boolean): MemoryConfigurationOptions
	copyDefaults(arg0: boolean): YamlConfigurationOptions
	copyDefaults(arg0: boolean): ConfigurationOptions
	copyDefaults(arg0: boolean): FileConfigurationOptions
	header(arg0: String): FileConfigurationOptions
	header(arg0: String): YamlConfigurationOptions
	copyHeader(arg0: boolean): YamlConfigurationOptions
	copyHeader(arg0: boolean): FileConfigurationOptions
	indent(arg0: int): YamlConfigurationOptions
	indent(): int
	configuration(): YamlConfiguration
	configuration(): FileConfiguration
	configuration(): MemoryConfiguration
	configuration(): Configuration
	pathSeparator(arg0: char): MemoryConfigurationOptions
	pathSeparator(arg0: char): ConfigurationOptions
	pathSeparator(arg0: char): FileConfigurationOptions
	pathSeparator(arg0: char): YamlConfigurationOptions
}
declare interface ItemFrame extends Hanging {
	setRotation(arg0: Rotation): void
	getItemDropChance(): float
	setItemDropChance(arg0: float): void
	getRotation(): Rotation
	setVisible(arg0: boolean): void
	isFixed(): boolean
	isVisible(): boolean
	setItem(arg0: ItemStack, arg1: boolean): void
	setItem(arg0: ItemStack): void
	setFixed(arg0: boolean): void
	getItem(): ItemStack
}
declare class MonsterEggs extends TexturedMaterial {
	getTextures(): List
	clone(): MaterialData
	clone(): Object
	clone(): TexturedMaterial
	clone(): MonsterEggs
}
namespace WorldSaveEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Chunk extends PersistentDataHolder {
	getChunkSnapshot(): ChunkSnapshot
	getChunkSnapshot(arg0: boolean, arg1: boolean, arg2: boolean): ChunkSnapshot
	getEntities(): Entity[]
	getTileEntities(): BlockState[]
	isSlimeChunk(): boolean
	isForceLoaded(): boolean
	setForceLoaded(arg0: boolean): void
	addPluginChunkTicket(arg0: Plugin): boolean
	removePluginChunkTicket(arg0: Plugin): boolean
	getPluginChunkTickets(): Collection
	getInhabitedTime(): long
	setInhabitedTime(arg0: long): void
	getBlock(arg0: int, arg1: int, arg2: int): Block
	getWorld(): World
	getX(): int
	getZ(): int
	load(arg0: boolean): boolean
	load(): boolean
	contains(arg0: BlockData): boolean
	isLoaded(): boolean
	unload(arg0: boolean): boolean
	unload(): boolean
}
namespace BlockRedstoneEvent {
	function getOldCurrent(): int
	function getNewCurrent(): int
	function setNewCurrent(arg0: int): void
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface FireworkEffectMeta extends ItemMeta {
	setEffect(arg0: FireworkEffect): void
	hasEffect(): boolean
	getEffect(): FireworkEffect
	clone(): Object
	clone(): ItemMeta
	clone(): FireworkEffectMeta
}
declare interface ConversationAbandonedListener extends EventListener {
	conversationAbandoned(arg0: ConversationAbandonedEvent): void
}
namespace EnchantItemEvent {
	function getEnchanter(): Player
	function getEnchantBlock(): Block
	function getExpLevelCost(): int
	function setExpLevelCost(arg0: int): void
	function getEnchantsToAdd(): Map
	function whichButton(): int
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BlockData extends Cloneable {
	getMaterial(): Material
	getSoundGroup(): SoundGroup
	getAsString(arg0: boolean): String
	getAsString(): String
	clone(): BlockData
	clone(): Object
	matches(arg0: BlockData): boolean
	merge(arg0: BlockData): BlockData
}
declare interface PermissionRemovedExecutor {
	attachmentRemoved(arg0: PermissionAttachment): void
}
declare class Spigot extends Spigot {
}
declare class CampfireRecipe extends CookingRecipe {
}
namespace PlayerToggleFlightEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isFlying(): boolean
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Spider extends Monster {
}
declare class BukkitCommand extends Command {
}
declare class ItemStack implements Cloneable, ConfigurationSerializable {
	deserialize(arg0: Map): ItemStack
	getMaxStackSize(): int
	setDurability(arg0: short): void
	hasItemMeta(): boolean
	getItemMeta(): ItemMeta
	setItemMeta0(arg0: ItemMeta, arg1: Material): boolean
	getDurability(): short
	setItemMeta(arg0: ItemMeta): boolean
	containsEnchantment(arg0: Enchantment): boolean
	getEnchantments(): Map
	addEnchantments(arg0: Map): void
	addEnchantment(arg0: Enchantment, arg1: int): void
	addUnsafeEnchantment(arg0: Enchantment, arg1: int): void
	addUnsafeEnchantments(arg0: Map): void
	removeEnchantment(arg0: Enchantment): int
	getEnchantmentLevel(arg0: Enchantment): int
	serialize(): Map
	setData(arg0: MaterialData): void
	getData(): MaterialData
	setType(arg0: Material): void
	createData(arg0: byte): void
	getAmount(): int
	setAmount(arg0: int): void
	isSimilar(arg0: ItemStack): boolean
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	clone(): Object
	clone(): ItemStack
	getType(): Material
}
declare interface Hanging extends Entity, Attachable {
	setFacingDirection(arg0: BlockFace, arg1: boolean): boolean
}
declare interface BlockDataMeta extends ItemMeta {
	hasBlockData(): boolean
	getBlockData(arg0: Material): BlockData
	setBlockData(arg0: BlockData): void
}
declare interface Sapling extends BlockData {
	getMaximumStage(): int
	getStage(): int
	setStage(arg0: int): void
}
declare class DefaultPermissions {
	registerPermission(arg0: Permission, arg1: Permission): Permission
	registerPermission(arg0: String, arg1: String): Permission
	registerPermission(arg0: String, arg1: String, arg2: PermissionDefault, arg3: Map): Permission
	registerPermission(arg0: String, arg1: String, arg2: PermissionDefault): Permission
	registerPermission(arg0: String, arg1: String, arg2: PermissionDefault, arg3: Permission): Permission
	registerPermission(arg0: String, arg1: String, arg2: Permission): Permission
	registerPermission(arg0: String, arg1: String, arg2: PermissionDefault, arg3: Map, arg4: Permission): Permission
	registerPermission(arg0: Permission): Permission
	registerPermission(arg0: Permission, arg1: boolean): Permission
	registerCorePermissions(): void
}
declare class MapFont {
	getHeight(): int
	getWidth(arg0: String): int
	isValid(arg0: String): boolean
	getChar(arg0: char): CharacterSprite
	setChar(arg0: char, arg1: CharacterSprite): void
}
declare interface Bisected extends BlockData {
	getHalf(): Half
	setHalf(arg0: Half): void
}
namespace MoistureChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getNewState(): BlockState
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class GameRule {
	getName(): String
	equals(arg0: Object): boolean
	toString(): String
	values(): GameRule[]
	getType(): Class
	getByName(arg0: String): GameRule
}
declare class StonecuttingRecipe implements Recipe, Keyed {
	setInputChoice(arg0: RecipeChoice): StonecuttingRecipe
	getInputChoice(): RecipeChoice
	getGroup(): String
	setGroup(arg0: String): void
	getKey(): NamespacedKey
	setInput(arg0: Material): StonecuttingRecipe
	getInput(): ItemStack
	getResult(): ItemStack
}
declare interface CaveVines extends Ageable, CaveVinesPlant {
}
namespace InventoryCloseEvent {
	function getHandlerList(): HandlerList
	function getPlayer(): HumanEntity
	function getHandlers(): HandlerList
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerRespawnEvent {
	function isAnchorSpawn(): boolean
	function getRespawnLocation(): Location
	function setRespawnLocation(arg0: Location): void
	function getHandlerList(): HandlerList
	function isBedSpawn(): boolean
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerBucketFishEvent {
	function getWaterBucket(): ItemStack
	function getFishBucket(): ItemStack
	function getEntity(): Entity
	function getEntity(): Fish
	function getOriginalBucket(): ItemStack
	function getEntityBucket(): ItemStack
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface LeashHitch extends Hanging {
}
declare interface Cake extends BlockData {
	getMaximumBites(): int
	getBites(): int
	setBites(arg0: int): void
}
declare interface CaveVinesPlant extends BlockData {
	isBerries(): boolean
	setBerries(arg0: boolean): void
}
declare interface Chain extends Orientable, Waterlogged {
}
declare interface Skull extends TileState {
	setRotation(arg0: BlockFace): void
	getRotation(): BlockFace
	getOwningPlayer(): OfflinePlayer
	setOwningPlayer(arg0: OfflinePlayer): void
	getSkullType(): SkullType
	setSkullType(arg0: SkullType): void
	hasOwner(): boolean
	getOwner(): String
	setOwner(arg0: String): boolean
}
declare class FormattedCommandAlias extends Command {
	buildCommand(arg0: String, arg1: String[]): String
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
	inRange(arg0: int, arg1: int, arg2: int): boolean
}
namespace VehicleCreateEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityPlaceEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlockFace(): BlockFace
	function getBlock(): Block
	function getPlayer(): Player
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace ServerListPingEvent {
	function getHandlerList(): HandlerList
	function getNumPlayers(): int
	function getMaxPlayers(): int
	function setMaxPlayers(arg0: int): void
	function setServerIcon(arg0: CachedServerIcon): void
	function getMotd(): String
	function setMotd(arg0: String): void
	function iterator(): Iterator
	function getAddress(): InetAddress
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
	function spliterator(): Spliterator
	function forEach(arg0: Consumer): void
}
declare interface Vehicle extends Entity {
	setVelocity(arg0: Vector): void
	getVelocity(): Vector
}
declare interface ServicesManager {
	unregisterAll(arg0: Plugin): void
	getRegistration(arg0: Class): RegisteredServiceProvider
	getRegistrations(arg0: Class): Collection
	getRegistrations(arg0: Plugin): List
	getKnownServices(): Collection
	isProvidedFor(arg0: Class): boolean
	load(arg0: Class): Object
	register(arg0: Class, arg1: Object, arg2: Plugin, arg3: ServicePriority): void
	unregister(arg0: Object): void
	unregister(arg0: Class, arg1: Object): void
}
declare interface Server extends PluginMessageRecipient {
	getLootTable(arg0: NamespacedKey): LootTable
	getOnlinePlayers(): Collection
	getConsoleSender(): ConsoleCommandSender
	getItemFactory(): ItemFactory
	getPluginManager(): PluginManager
	getOfflinePlayer(arg0: UUID): OfflinePlayer
	getOfflinePlayer(arg0: String): OfflinePlayer
	createChunkData(arg0: World): ChunkData
	dispatchCommand(arg0: CommandSender, arg1: String): boolean
	getMaxPlayers(): int
	getBukkitVersion(): String
	getViewDistance(): int
	getWorldType(): String
	getGenerateStructures(): boolean
	getMaxWorldSize(): int
	getAllowEnd(): boolean
	getAllowNether(): boolean
	hasWhitelist(): boolean
	setWhitelist(arg0: boolean): void
	isWhitelistEnforced(): boolean
	setWhitelistEnforced(arg0: boolean): void
	getWhitelistedPlayers(): Set
	reloadWhitelist(): void
	broadcastMessage(arg0: String): int
	getUpdateFolder(): String
	getUpdateFolderFile(): File
	getConnectionThrottle(): long
	getTicksPerAnimalSpawns(): int
	getTicksPerMonsterSpawns(): int
	getTicksPerWaterSpawns(): int
	getTicksPerAmbientSpawns(): int
	getPlayerExact(arg0: String): Player
	matchPlayer(arg0: String): List
	getScheduler(): BukkitScheduler
	getServicesManager(): ServicesManager
	createWorld(arg0: WorldCreator): World
	unloadWorld(arg0: World, arg1: boolean): boolean
	unloadWorld(arg0: String, arg1: boolean): boolean
	createExplorerMap(arg0: World, arg1: Location, arg2: StructureType): ItemStack
	createExplorerMap(arg0: World, arg1: Location, arg2: StructureType, arg3: int, arg4: boolean): ItemStack
	getPluginCommand(arg0: String): PluginCommand
	savePlayers(): void
	getRecipesFor(arg0: ItemStack): List
	recipeIterator(): Iterator
	clearRecipes(): void
	resetRecipes(): void
	removeRecipe(arg0: NamespacedKey): boolean
	getCommandAliases(): Map
	getSpawnRadius(): int
	setSpawnRadius(arg0: int): void
	getOnlineMode(): boolean
	getAllowFlight(): boolean
	getBannedPlayers(): Set
	getOperators(): Set
	getDefaultGameMode(): GameMode
	setDefaultGameMode(arg0: GameMode): void
	getWorldContainer(): File
	getOfflinePlayers(): OfflinePlayer[]
	getMessenger(): Messenger
	createInventory(arg0: InventoryHolder, arg1: InventoryType): Inventory
	createInventory(arg0: InventoryHolder, arg1: int, arg2: String): Inventory
	createInventory(arg0: InventoryHolder, arg1: InventoryType, arg2: String): Inventory
	createInventory(arg0: InventoryHolder, arg1: int): Inventory
	createMerchant(arg0: String): Merchant
	getMonsterSpawnLimit(): int
	getAnimalSpawnLimit(): int
	getWaterAnimalSpawnLimit(): int
	getWaterAmbientSpawnLimit(): int
	getAmbientSpawnLimit(): int
	isPrimaryThread(): boolean
	getShutdownMessage(): String
	getWarningState(): WarningState
	getScoreboardManager(): ScoreboardManager
	getServerIcon(): CachedServerIcon
	loadServerIcon(arg0: File): CachedServerIcon
	loadServerIcon(arg0: BufferedImage): CachedServerIcon
	setIdleTimeout(arg0: int): void
	getIdleTimeout(): int
	createBossBar(arg0: String, arg1: BarColor, arg2: BarStyle, arg3: BarFlag[]): BossBar
	createBossBar(arg0: NamespacedKey, arg1: String, arg2: BarColor, arg3: BarStyle, arg4: BarFlag[]): KeyedBossBar
	getBossBars(): Iterator
	removeBossBar(arg0: NamespacedKey): boolean
	getAdvancement(arg0: NamespacedKey): Advancement
	advancementIterator(): Iterator
	createBlockData(arg0: Material, arg1: Consumer): BlockData
	createBlockData(arg0: String): BlockData
	createBlockData(arg0: Material, arg1: String): BlockData
	createBlockData(arg0: Material): BlockData
	selectEntities(arg0: CommandSender, arg1: String): List
	reload(): void
	getWorld(arg0: UUID): World
	getWorld(arg0: String): World
	getEntity(arg0: UUID): Entity
	spigot(): Spigot
	getPlayer(arg0: UUID): Player
	getPlayer(arg0: String): Player
	getBossBar(arg0: NamespacedKey): KeyedBossBar
	getRecipe(arg0: NamespacedKey): Recipe
	getMotd(): String
	getIp(): String
	getWorlds(): List
	reloadData(): void
	addRecipe(arg0: Recipe): boolean
	isHardcore(): boolean
	getIPBans(): Set
	banIP(arg0: String): void
	unbanIP(arg0: String): void
	getBanList(arg0: Type): BanList
	getHelpMap(): HelpMap
	getTags(arg0: String, arg1: Class): Iterable
	getTicksPerWaterAmbientSpawns(): int
	getName(): String
	shutdown(): void
	getUnsafe(): UnsafeValues
	getLogger(): Logger
	getPort(): int
	broadcast(arg0: String, arg1: String): int
	getMap(arg0: int): MapView
	createMap(arg0: World): MapView
	getTag(arg0: String, arg1: NamespacedKey, arg2: Class): Tag
	getVersion(): String
}
namespace TabCompleteEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getCompletions(): List
	function setCompletions(arg0: List): void
	function getSender(): CommandSender
	function getBuffer(): String
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class OctaveGenerator {
	noise(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): double
	noise(arg0: double, arg1: double, arg2: double, arg3: double): double
	noise(arg0: double, arg1: double, arg2: double, arg3: boolean): double
	noise(arg0: double, arg1: double, arg2: double): double
	noise(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: boolean): double
	noise(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): double
	setScale(arg0: double): void
	setXScale(arg0: double): void
	setYScale(arg0: double): void
	setZScale(arg0: double): void
	getXScale(): double
	getYScale(): double
	getZScale(): double
	getOctaves(): NoiseGenerator[]
}
declare interface Bamboo extends Ageable, Sapling {
	getLeaves(): Leaves
	setLeaves(arg0: Leaves): void
}
declare interface Raid {
	getActiveTicks(): long
	getBadOmenLevel(): int
	setBadOmenLevel(arg0: int): void
	getSpawnedGroups(): int
	getTotalGroups(): int
	getTotalWaves(): int
	getTotalHealth(): float
	getStatus(): RaidStatus
	isStarted(): boolean
	getHeroes(): Set
	getRaiders(): List
	getLocation(): Location
}
declare interface MetadataStore {
	setMetadata(arg0: Object, arg1: String, arg2: MetadataValue): void
	getMetadata(arg0: Object, arg1: String): List
	hasMetadata(arg0: Object, arg1: String): boolean
	removeMetadata(arg0: Object, arg1: String, arg2: Plugin): void
	invalidateAll(arg0: Plugin): void
}
namespace EntityPortalEvent {
	function getHandlerList(): HandlerList
	function setSearchRadius(arg0: int): void
	function getSearchRadius(): int
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getFrom(): Location
	function setFrom(arg0: Location): void
	function getTo(): Location
	function setTo(arg0: Location): void
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class LazyMetadataValue extends MetadataValueAdapter {
	eval(): void
	value(): Object
	invalidate(): void
}
declare class Sandstone extends MaterialData {
	setType(arg0: SandstoneType): void
	toString(): String
	clone(): Object
	clone(): Sandstone
	clone(): MaterialData
	getType(): SandstoneType
}
declare class Stairs extends MaterialData implements Directional {
	setFacingDirection(arg0: BlockFace): void
	setInverted(arg0: boolean): void
	getAscendingDirection(): BlockFace
	getDescendingDirection(): BlockFace
	getFacing(): BlockFace
	isInverted(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Stairs
	clone(): Object
	clone(): MaterialData
}
namespace PlayerToggleSprintEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isSprinting(): boolean
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Builder {
	withFlicker(): Builder
	flicker(arg0: boolean): Builder
	trail(arg0: boolean): Builder
	withTrail(): Builder
	withColor(arg0: Iterable): Builder
	withColor(arg0: Color[]): Builder
	withColor(arg0: Color): Builder
	withFade(arg0: Color): Builder
	withFade(arg0: Iterable): Builder
	withFade(arg0: Color[]): Builder
	build(): FireworkEffect
	with(arg0: Type): Builder
}
namespace PlayerItemBreakEvent {
	function getHandlerList(): HandlerList
	function getBrokenItem(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityDropItemEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getItemDrop(): Item
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class MetadataStoreBase {
	setMetadata(arg0: Object, arg1: String, arg2: MetadataValue): void
	getMetadata(arg0: Object, arg1: String): List
	hasMetadata(arg0: Object, arg1: String): boolean
	removeMetadata(arg0: Object, arg1: String, arg2: Plugin): void
	invalidateAll(arg0: Plugin): void
	disambiguate(arg0: Object, arg1: String): String
}
declare class PluginDescriptionFile {
	getDescription(): String
	getProvides(): List
	getContributors(): List
	getSoftDepend(): List
	getLoadBefore(): List
	getCommands(): Map
	getFullName(): String
	getPermissionDefault(): PermissionDefault
	getAwareness(): Set
	getAPIVersion(): String
	getLibraries(): List
	getClassLoaderOf(): String
	makePluginNameList(arg0: Map, arg1: String): List
	getPrefix(): String
	asMap(arg0: Object): Map
	loadMap(arg0: Map): void
	getMain(): String
	getLoad(): PluginLoadOrder
	getAuthors(): List
	getWebsite(): String
	getDepend(): List
	saveMap(): Map
	getRawName(): String
	getName(): String
	getPermissions(): List
	save(arg0: Writer): void
	getVersion(): String
}
declare interface LlamaInventory extends AbstractHorseInventory {
	getDecor(): ItemStack
	setDecor(arg0: ItemStack): void
}
declare interface Fish extends WaterMob {
}
namespace EnderDragonChangePhaseEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setNewPhase(arg0: Phase): void
	function getCurrentPhase(): Phase
	function getNewPhase(): Phase
	function getEntity(): Entity
	function getEntity(): EnderDragon
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Enchantment implements Keyed {
	getStartLevel(): int
	getMaxLevel(): int
	canEnchantItem(arg0: ItemStack): boolean
	getItemTarget(): EnchantmentTarget
	conflictsWith(arg0: Enchantment): boolean
	registerEnchantment(arg0: Enchantment): void
	isAcceptingRegistrations(): boolean
	stopAcceptingRegistrations(): void
	isTreasure(): boolean
	isCursed(): boolean
	getByKey(arg0: NamespacedKey): Enchantment
	getName(): String
	equals(arg0: Object): boolean
	toString(): String
	values(): Enchantment[]
	hashCode(): int
	getKey(): NamespacedKey
	getByName(arg0: String): Enchantment
}
namespace PlayerFishEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getExpToDrop(): int
	function setExpToDrop(arg0: int): void
	function getCaught(): Entity
	function getHook(): FishHook
	function getState(): State
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface SkullMeta extends ItemMeta {
	getOwningPlayer(): OfflinePlayer
	setOwningPlayer(arg0: OfflinePlayer): boolean
	hasOwner(): boolean
	clone(): SkullMeta
	clone(): ItemMeta
	clone(): Object
	getOwner(): String
	setOwner(arg0: String): boolean
}
declare interface EnchantingInventory extends Inventory {
	setSecondary(arg0: ItemStack): void
	getSecondary(): ItemStack
	setItem(arg0: ItemStack): void
	getItem(): ItemStack
}
declare interface EventHandler extends Annotation {
	ignoreCancelled(): boolean
	priority(): EventPriority
}
declare interface Hopper extends Directional {
	isEnabled(): boolean
	setEnabled(arg0: boolean): void
}
declare class FurnaceAndDispenser extends DirectionalContainer {
	clone(): Object
	clone(): MaterialData
	clone(): DirectionalContainer
	clone(): FurnaceAndDispenser
}
declare interface EvokerFangs extends Entity {
	getOwner(): LivingEntity
	setOwner(arg0: LivingEntity): void
}
declare interface BlockInventoryHolder extends InventoryHolder {
	getBlock(): Block
}
declare interface Block extends Metadatable {
	getPistonMoveReaction(): PistonMoveReaction
	getBoundingBox(): BoundingBox
	getBlockData(): BlockData
	getLightLevel(): byte
	setBlockData(arg0: BlockData): void
	setBlockData(arg0: BlockData, arg1: boolean): void
	getRelative(arg0: BlockFace, arg1: int): Block
	getRelative(arg0: int, arg1: int, arg2: int): Block
	getRelative(arg0: BlockFace): Block
	getLightFromSky(): byte
	getLightFromBlocks(): byte
	isBlockPowered(): boolean
	isBlockIndirectlyPowered(): boolean
	isBlockFacePowered(arg0: BlockFace): boolean
	getBlockPower(arg0: BlockFace): int
	getBlockPower(): int
	getTemperature(): double
	getHumidity(): double
	breakNaturally(arg0: ItemStack): boolean
	breakNaturally(): boolean
	applyBoneMeal(arg0: BlockFace): boolean
	isPreferredTool(arg0: ItemStack): boolean
	getBreakSpeed(arg0: Player): float
	getCollisionShape(): VoxelShape
	getWorld(): World
	getX(): int
	getY(): int
	getZ(): int
	getChunk(): Chunk
	getData(): byte
	setType(arg0: Material): void
	setType(arg0: Material, arg1: boolean): void
	getFace(arg0: Block): BlockFace
	getBiome(): Biome
	setBiome(arg0: Biome): void
	isLiquid(): boolean
	getDrops(): Collection
	getDrops(arg0: ItemStack): Collection
	getDrops(arg0: ItemStack, arg1: Entity): Collection
	isPassable(): boolean
	rayTrace(arg0: Location, arg1: Vector, arg2: double, arg3: FluidCollisionMode): RayTraceResult
	isBlockFaceIndirectlyPowered(arg0: BlockFace): boolean
	isEmpty(): boolean
	getLocation(): Location
	getLocation(arg0: Location): Location
	getState(): BlockState
	getType(): Material
}
declare interface GlowSquid extends Squid {
	getDarkTicksRemaining(): int
	setDarkTicksRemaining(arg0: int): void
}
declare class FileConfigurationOptions extends MemoryConfigurationOptions {
	copyDefaults(arg0: boolean): FileConfigurationOptions
	copyDefaults(arg0: boolean): ConfigurationOptions
	copyDefaults(arg0: boolean): MemoryConfigurationOptions
	header(arg0: String): FileConfigurationOptions
	header(): String
	copyHeader(): boolean
	copyHeader(arg0: boolean): FileConfigurationOptions
	configuration(): FileConfiguration
	configuration(): Configuration
	configuration(): MemoryConfiguration
	pathSeparator(arg0: char): ConfigurationOptions
	pathSeparator(arg0: char): MemoryConfigurationOptions
	pathSeparator(arg0: char): FileConfigurationOptions
}
declare interface Sheep extends Animals, Colorable {
	isSheared(): boolean
	setSheared(arg0: boolean): void
}
declare class Type extends Enum implements Keyed {
	values(): Type[]
	valueOf(arg0: String): Type
	getKey(): NamespacedKey
}
declare interface EnderChest extends Directional, Waterlogged {
}
namespace PluginDisableEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getPlugin(): Plugin
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class BlockPopulator {
	populate(arg0: World, arg1: Random, arg2: Chunk): void
}
namespace PlayerItemDamageEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setDamage(arg0: int): void
	function getDamage(): int
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace StriderTemperatureChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isShivering(): boolean
	function getEntity(): Entity
	function getEntity(): Strider
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface SmallDripleaf extends Dripleaf, Bisected {
}
namespace PlayerShearEntityEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getHand(): EquipmentSlot
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace FurnaceSmeltEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setResult(arg0: ItemStack): void
	function getSource(): ItemStack
	function getHandlers(): HandlerList
	function getResult(): ItemStack
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Rotatable extends BlockData {
	setRotation(arg0: BlockFace): void
	getRotation(): BlockFace
}
declare class PluginCommand extends Command implements PluginIdentifiableCommand {
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[]): List
	setExecutor(arg0: CommandExecutor): void
	getExecutor(): CommandExecutor
	setTabCompleter(arg0: TabCompleter): void
	getTabCompleter(): TabCompleter
	getPlugin(): Plugin
	toString(): String
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
}
namespace ExpBottleEvent {
	function setExperience(arg0: int): void
	function getExperience(): int
	function getHandlerList(): HandlerList
	function getShowEffect(): boolean
	function setShowEffect(arg0: boolean): void
	function getEntity(): Projectile
	function getEntity(): ThrownExpBottle
	function getEntity(): Entity
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHitBlock(): Block
	function getHitBlockFace(): BlockFace
	function getHitEntity(): Entity
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockIgniteEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getIgnitingEntity(): Entity
	function getIgnitingBlock(): Block
	function getPlayer(): Player
	function getCause(): IgniteCause
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Nameable {
	setCustomName(arg0: String): void
	getCustomName(): String
}
namespace PlayerDeathEvent {
	function getNewLevel(): int
	function setDeathMessage(arg0: String): void
	function getDeathMessage(): String
	function setNewLevel(arg0: int): void
	function getNewTotalExp(): int
	function setNewTotalExp(arg0: int): void
	function getKeepLevel(): boolean
	function setKeepLevel(arg0: boolean): void
	function setKeepInventory(arg0: boolean): void
	function getKeepInventory(): boolean
	function getEntity(): LivingEntity
	function getEntity(): Player
	function getEntity(): Entity
	function getNewExp(): int
	function setNewExp(arg0: int): void
	function getHandlerList(): HandlerList
	function getDroppedExp(): int
	function setDroppedExp(arg0: int): void
	function getDrops(): List
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Wrapper implements Serializable {
	newWrapper(arg0: ConfigurationSerializable): Wrapper
}
declare interface Wolf extends Tameable, Sittable {
	getCollarColor(): DyeColor
	setCollarColor(arg0: DyeColor): void
	isAngry(): boolean
	setAngry(arg0: boolean): void
}
declare interface MetadataValue {
	getOwningPlugin(): Plugin
	asInt(): int
	asFloat(): float
	asDouble(): double
	asLong(): long
	asShort(): short
	asByte(): byte
	asBoolean(): boolean
	asString(): String
	value(): Object
	invalidate(): void
}
declare interface PotionBrewer {
	createEffect(arg0: PotionEffectType, arg1: int, arg2: int): PotionEffect
	getEffectsFromDamage(arg0: int): Collection
	getEffects(arg0: PotionType, arg1: boolean, arg2: boolean): Collection
}
declare class DoubleChest implements InventoryHolder {
	getLeftSide(): InventoryHolder
	getRightSide(): InventoryHolder
	getInventory(): Inventory
	getWorld(): World
	getX(): double
	getY(): double
	getZ(): double
	getLocation(): Location
}
namespace HangingEvent {
	function getEntity(): Hanging
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface CrossbowMeta extends ItemMeta {
	hasChargedProjectiles(): boolean
	getChargedProjectiles(): List
	setChargedProjectiles(arg0: List): void
	addChargedProjectile(arg0: ItemStack): void
}
declare interface Lidded {
	close(): void
	open(): void
}
declare class CocoaPlant extends MaterialData implements Directional, Attachable {
	$SWITCH_TABLE$org$bukkit$material$CocoaPlant$CocoaPlantSize(): int[]
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	getFacing(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): CocoaPlant
	getSize(): CocoaPlantSize
	setSize(arg0: CocoaPlantSize): void
}
declare interface RecipeChoice extends Predicate, Cloneable {
	getItemStack(): ItemStack
	clone(): Object
	clone(): RecipeChoice
	test(arg0: Object): boolean
	test(arg0: ItemStack): boolean
}
declare class Sign extends MaterialData implements Attachable {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	getFacing(): BlockFace
	isWallSign(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Sign
	clone(): MaterialData
}
namespace EntityPickupItemEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function getRemaining(): int
	function getItem(): Item
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface FaceAttachable extends BlockData {
	getAttachedFace(): AttachedFace
	setAttachedFace(arg0: AttachedFace): void
}
declare interface TileState extends BlockState, PersistentDataHolder {
	getPersistentDataContainer(): PersistentDataContainer
}
declare interface PotionMeta extends ItemMeta {
	setBasePotionData(arg0: PotionData): void
	getBasePotionData(): PotionData
	hasCustomEffects(): boolean
	getCustomEffects(): List
	addCustomEffect(arg0: PotionEffect, arg1: boolean): boolean
	removeCustomEffect(arg0: PotionEffectType): boolean
	hasCustomEffect(arg0: PotionEffectType): boolean
	clearCustomEffects(): boolean
	setMainEffect(arg0: PotionEffectType): boolean
	getColor(): Color
	hasColor(): boolean
	clone(): ItemMeta
	clone(): PotionMeta
	clone(): Object
	setColor(arg0: Color): void
}
declare interface ZombieHorse extends AbstractHorse {
}
namespace SheepRegrowWoolEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): Sheep
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Sittable {
	setSitting(arg0: boolean): void
	isSitting(): boolean
}
declare interface Giant extends Monster {
}
namespace PlayerPickupArrowEvent {
	function getArrow(): AbstractArrow
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRemaining(): int
	function getItem(): Item
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface StructureBlock extends BlockData {
	getMode(): Mode
	setMode(arg0: Mode): void
}
declare interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder {
	getInventory(): Inventory
	getInventory(): PlayerInventory
	getEnderChest(): Inventory
	getMainHand(): MainHand
	setWindowProperty(arg0: Property, arg1: int): boolean
	getOpenInventory(): InventoryView
	openInventory(arg0: InventoryView): void
	openInventory(arg0: Inventory): InventoryView
	openWorkbench(arg0: Location, arg1: boolean): InventoryView
	openEnchanting(arg0: Location, arg1: boolean): InventoryView
	openMerchant(arg0: Merchant, arg1: boolean): InventoryView
	openMerchant(arg0: Villager, arg1: boolean): InventoryView
	closeInventory(): void
	getItemInHand(): ItemStack
	setItemInHand(arg0: ItemStack): void
	getItemOnCursor(): ItemStack
	setItemOnCursor(arg0: ItemStack): void
	hasCooldown(arg0: Material): boolean
	getCooldown(arg0: Material): int
	setCooldown(arg0: Material, arg1: int): void
	getSleepTicks(): int
	getBedLocation(): Location
	getGameMode(): GameMode
	setGameMode(arg0: GameMode): void
	isHandRaised(): boolean
	getItemInUse(): ItemStack
	getExpToLevel(): int
	getAttackCooldown(): float
	discoverRecipe(arg0: NamespacedKey): boolean
	discoverRecipes(arg0: Collection): int
	undiscoverRecipe(arg0: NamespacedKey): boolean
	undiscoverRecipes(arg0: Collection): int
	hasDiscoveredRecipe(arg0: NamespacedKey): boolean
	getDiscoveredRecipes(): Set
	getShoulderEntityLeft(): Entity
	setShoulderEntityLeft(arg0: Entity): void
	getShoulderEntityRight(): Entity
	setShoulderEntityRight(arg0: Entity): void
	getExhaustion(): float
	setExhaustion(arg0: float): void
	getSaturation(): float
	setSaturation(arg0: float): void
	getFoodLevel(): int
	setFoodLevel(arg0: int): void
	getSaturatedRegenRate(): int
	setSaturatedRegenRate(arg0: int): void
	getUnsaturatedRegenRate(): int
	setUnsaturatedRegenRate(arg0: int): void
	getStarvationRate(): int
	setStarvationRate(arg0: int): void
	wakeup(arg0: boolean): void
	isBlocking(): boolean
	dropItem(arg0: boolean): boolean
	getName(): String
	sleep(arg0: Location, arg1: boolean): boolean
}
declare interface Team {
	allowFriendlyFire(): boolean
	canSeeFriendlyInvisibles(): boolean
	setAllowFriendlyFire(arg0: boolean): void
	setNameTagVisibility(arg0: NameTagVisibility): void
	getNameTagVisibility(): NameTagVisibility
	setDisplayName(arg0: String): void
	getScoreboard(): Scoreboard
	removePlayer(arg0: OfflinePlayer): boolean
	removeEntry(arg0: String): boolean
	getColor(): ChatColor
	getPrefix(): String
	getPlayers(): Set
	addPlayer(arg0: OfflinePlayer): void
	hasPlayer(arg0: OfflinePlayer): boolean
	hasEntry(arg0: String): boolean
	getOption(arg0: Option): OptionStatus
	setOption(arg0: Option, arg1: OptionStatus): void
	setPrefix(arg0: String): void
	getSuffix(): String
	setSuffix(arg0: String): void
	setCanSeeFriendlyInvisibles(arg0: boolean): void
	getName(): String
	addEntry(arg0: String): void
	getSize(): int
	getEntries(): Set
	getDisplayName(): String
	unregister(): void
	setColor(arg0: ChatColor): void
}
declare class NamespacedKey {
	getNamespace(): String
	minecraft(arg0: String): NamespacedKey
	randomKey(): NamespacedKey
	fromString(arg0: String): NamespacedKey
	fromString(arg0: String, arg1: Plugin): NamespacedKey
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	getKey(): String
}
declare class ManuallyAbandonedConversationCanceller implements ConversationCanceller {
	setConversation(arg0: Conversation): void
	cancelBasedOnInput(arg0: ConversationContext, arg1: String): boolean
	clone(): ConversationCanceller
	clone(): Object
}
declare interface GrindstoneInventory extends Inventory {
}
declare interface BlockState extends Metadatable {
	getBlockData(): BlockData
	getLightLevel(): byte
	setBlockData(arg0: BlockData): void
	getBlock(): Block
	getWorld(): World
	getX(): int
	getY(): int
	getZ(): int
	getChunk(): Chunk
	setData(arg0: MaterialData): void
	getRawData(): byte
	setRawData(arg0: byte): void
	isPlaced(): boolean
	getData(): MaterialData
	setType(arg0: Material): void
	update(arg0: boolean, arg1: boolean): boolean
	update(arg0: boolean): boolean
	update(): boolean
	getLocation(arg0: Location): Location
	getLocation(): Location
	getType(): Material
}
namespace PlayerDropItemEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getItemDrop(): Item
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface PolarBear extends Animals {
}
namespace PlayerItemHeldEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getPreviousSlot(): int
	function getNewSlot(): int
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerBucketEmptyEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getItemStack(): ItemStack
	function getBlockFace(): BlockFace
	function setItemStack(arg0: ItemStack): void
	function getBlockClicked(): Block
	function getBlock(): Block
	function getBucket(): Material
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Coal extends MaterialData {
	setType(arg0: CoalType): void
	toString(): String
	clone(): Object
	clone(): Coal
	clone(): MaterialData
	getType(): CoalType
}
namespace PlayerInteractAtEntityEvent {
	function getHandlerList(): HandlerList
	function getClickedPosition(): Vector
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getRightClicked(): Entity
	function getHand(): EquipmentSlot
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace FoodLevelChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getFoodLevel(): int
	function setFoodLevel(arg0: int): void
	function getEntity(): Entity
	function getEntity(): HumanEntity
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class MaterialChoice implements RecipeChoice {
	getItemStack(): ItemStack
	getChoices(): List
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	clone(): Object
	clone(): RecipeChoice
	clone(): MaterialChoice
	test(arg0: Object): boolean
	test(arg0: ItemStack): boolean
}
declare interface Metadatable {
	setMetadata(arg0: String, arg1: MetadataValue): void
	getMetadata(arg0: String): List
	hasMetadata(arg0: String): boolean
	removeMetadata(arg0: String, arg1: Plugin): void
}
namespace PlayerEvent {
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace ServiceEvent {
	function getProvider(): RegisteredServiceProvider
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface EnderPearl extends ThrowableProjectile {
}
namespace PlayerChangedWorldEvent {
	function getHandlerList(): HandlerList
	function getFrom(): World
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BrewingStand extends Container {
	getSnapshotInventory(): BrewerInventory
	getSnapshotInventory(): Inventory
	getInventory(): Inventory
	getInventory(): BrewerInventory
	getBrewingTime(): int
	setBrewingTime(arg0: int): void
	getFuelLevel(): int
	setFuelLevel(arg0: int): void
}
declare interface Lantern extends Waterlogged {
	isHanging(): boolean
	setHanging(arg0: boolean): void
}
declare interface ElderGuardian extends Guardian {
}
declare interface LoomInventory extends Inventory {
}
declare interface BrewerInventory extends Inventory {
	getIngredient(): ItemStack
	setIngredient(arg0: ItemStack): void
	getFuel(): ItemStack
	setFuel(arg0: ItemStack): void
	getHolder(): BrewingStand
	getHolder(): InventoryHolder
}
namespace InventoryEvent {
	function getHandlerList(): HandlerList
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerPortalEvent {
	function getHandlerList(): HandlerList
	function setSearchRadius(arg0: int): void
	function getSearchRadius(): int
	function getCanCreatePortal(): boolean
	function setCanCreatePortal(arg0: boolean): void
	function setCreationRadius(arg0: int): void
	function getCreationRadius(): int
	function getHandlers(): HandlerList
	function getCause(): TeleportCause
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getFrom(): Location
	function setFrom(arg0: Location): void
	function getTo(): Location
	function setTo(arg0: Location): void
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Explosive extends Entity {
	isIncendiary(): boolean
	setIsIncendiary(arg0: boolean): void
	getYield(): float
	setYield(arg0: float): void
}
declare class EnderChest extends DirectionalContainer {
	clone(): Object
	clone(): MaterialData
	clone(): DirectionalContainer
	clone(): EnderChest
}
namespace PlayerMoveEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getFrom(): Location
	function setFrom(arg0: Location): void
	function getTo(): Location
	function setTo(arg0: Location): void
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Drowned extends Zombie {
}
declare interface Enderman extends Monster {
	getCarriedMaterial(): MaterialData
	setCarriedMaterial(arg0: MaterialData): void
	getCarriedBlock(): BlockData
	setCarriedBlock(arg0: BlockData): void
}
declare interface Jigsaw extends BlockData {
	getOrientation(): Orientation
	setOrientation(arg0: Orientation): void
}
declare class SmoothBrick extends TexturedMaterial {
	getTextures(): List
	clone(): MaterialData
	clone(): Object
	clone(): TexturedMaterial
	clone(): SmoothBrick
}
declare interface StonecutterInventory extends Inventory {
}
declare class Potion {
	toItemStack(arg0: int): ItemStack
	setHasExtendedDuration(arg0: boolean): void
	hasExtendedDuration(): boolean
	toDamageValue(): short
	fromItemStack(arg0: ItemStack): Potion
	setPotionBrewer(arg0: PotionBrewer): void
	setType(arg0: PotionType): void
	splash(): Potion
	setSplash(arg0: boolean): void
	extend(): Potion
	getBrewer(): PotionBrewer
	isSplash(): boolean
	fromDamage(arg0: int): Potion
	getNameId(): int
	getEffects(): Collection
	equals(arg0: Object): boolean
	hashCode(): int
	apply(arg0: LivingEntity): void
	apply(arg0: ItemStack): void
	getType(): PotionType
	getLevel(): int
	setLevel(arg0: int): void
}
namespace PlayerToggleSneakEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isSneaking(): boolean
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PluginCommandYamlParser {
	parse(arg0: Plugin): List
}
declare interface BlockStateMeta extends ItemMeta {
	hasBlockState(): boolean
	getBlockState(): BlockState
	setBlockState(arg0: BlockState): void
}
namespace EntityExhaustionEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getExhaustion(): float
	function setExhaustion(arg0: float): void
	function getExhaustionReason(): ExhaustionReason
	function getEntity(): Entity
	function getEntity(): HumanEntity
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Gate extends MaterialData implements Directional, Openable {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	setOpen(arg0: boolean): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Gate
	clone(): Object
	clone(): MaterialData
	isOpen(): boolean
}
declare interface NPC extends Creature {
}
declare interface EnderSignal extends Entity {
	getTargetLocation(): Location
	setTargetLocation(arg0: Location): void
	getDropItem(): boolean
	setDropItem(arg0: boolean): void
	getDespawnTimer(): int
	setDespawnTimer(arg0: int): void
	setItem(arg0: ItemStack): void
	getItem(): ItemStack
}
declare interface Entity extends Metadatable, CommandSender, Nameable, PersistentDataHolder {
	setPersistent(arg0: boolean): void
	isCustomNameVisible(): boolean
	getUniqueId(): UUID
	isInsideVehicle(): boolean
	setTicksLived(arg0: int): void
	setFallDistance(arg0: float): void
	setPassenger(arg0: Entity): boolean
	getPortalCooldown(): int
	getPassenger(): Entity
	getPistonMoveReaction(): PistonMoveReaction
	addPassenger(arg0: Entity): boolean
	removeScoreboardTag(arg0: String): boolean
	setInvulnerable(arg0: boolean): void
	getFallDistance(): float
	setPortalCooldown(arg0: int): void
	setCustomNameVisible(arg0: boolean): void
	isPersistent(): boolean
	getScoreboardTags(): Set
	getPassengers(): List
	getLastDamageCause(): EntityDamageEvent
	isInvulnerable(): boolean
	leaveVehicle(): boolean
	removePassenger(arg0: Entity): boolean
	addScoreboardTag(arg0: String): boolean
	getTicksLived(): int
	setLastDamageCause(arg0: EntityDamageEvent): void
	getMaxFireTicks(): int
	getFreezeTicks(): int
	getFireTicks(): int
	getMaxFreezeTicks(): int
	setVisualFire(arg0: boolean): void
	getEntityId(): int
	isVisualFire(): boolean
	setVelocity(arg0: Vector): void
	setFireTicks(arg0: int): void
	setFreezeTicks(arg0: int): void
	getNearbyEntities(arg0: double, arg1: double, arg2: double): List
	getVelocity(): Vector
	setRotation(arg0: float, arg1: float): void
	getBoundingBox(): BoundingBox
	getFacing(): BlockFace
	getWorld(): World
	getHeight(): double
	getWidth(): double
	isOnGround(): boolean
	isInWater(): boolean
	teleport(arg0: Entity, arg1: TeleportCause): boolean
	teleport(arg0: Location, arg1: TeleportCause): boolean
	teleport(arg0: Entity): boolean
	teleport(arg0: Location): boolean
	isDead(): boolean
	isValid(): boolean
	getServer(): Server
	eject(): boolean
	playEffect(arg0: EntityEffect): void
	getVehicle(): Entity
	setGlowing(arg0: boolean): void
	isGlowing(): boolean
	isSilent(): boolean
	setSilent(arg0: boolean): void
	hasGravity(): boolean
	setGravity(arg0: boolean): void
	getPose(): Pose
	spigot(): Spigot
	spigot(): Spigot
	remove(): void
	isEmpty(): boolean
	getLocation(arg0: Location): Location
	getLocation(): Location
	getType(): EntityType
	isFrozen(): boolean
}
namespace FurnaceExtractEvent {
	function getItemType(): Material
	function getItemAmount(): int
	function getPlayer(): Player
	function getHandlerList(): HandlerList
	function getExpToDrop(): int
	function setExpToDrop(arg0: int): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Lectern extends Directional, Powerable {
	hasBook(): boolean
}
declare class BlockVector extends Vector {
	deserialize(arg0: Map): BlockVector
	equals(arg0: Object): boolean
	hashCode(): int
	clone(): BlockVector
	clone(): Vector
	clone(): Object
}
declare interface OfflinePlayer extends ServerOperator, AnimalTamer, ConfigurationSerializable {
	getUniqueId(): UUID
	isWhitelisted(): boolean
	setWhitelisted(arg0: boolean): void
	getFirstPlayed(): long
	getLastPlayed(): long
	hasPlayedBefore(): boolean
	getBedSpawnLocation(): Location
	incrementStatistic(arg0: Statistic): void
	incrementStatistic(arg0: Statistic, arg1: Material): void
	incrementStatistic(arg0: Statistic, arg1: EntityType): void
	incrementStatistic(arg0: Statistic, arg1: int): void
	incrementStatistic(arg0: Statistic, arg1: Material, arg2: int): void
	incrementStatistic(arg0: Statistic, arg1: EntityType, arg2: int): void
	decrementStatistic(arg0: Statistic, arg1: Material, arg2: int): void
	decrementStatistic(arg0: Statistic, arg1: EntityType, arg2: int): void
	decrementStatistic(arg0: Statistic, arg1: Material): void
	decrementStatistic(arg0: Statistic): void
	decrementStatistic(arg0: Statistic, arg1: EntityType): void
	decrementStatistic(arg0: Statistic, arg1: int): void
	setStatistic(arg0: Statistic, arg1: Material, arg2: int): void
	setStatistic(arg0: Statistic, arg1: int): void
	setStatistic(arg0: Statistic, arg1: EntityType, arg2: int): void
	getStatistic(arg0: Statistic, arg1: EntityType): int
	getStatistic(arg0: Statistic, arg1: Material): int
	getStatistic(arg0: Statistic): int
	getPlayer(): Player
	isBanned(): boolean
	isOnline(): boolean
	getName(): String
}
declare class InventoryView {
	getInventory(arg0: int): Inventory
	getTopInventory(): Inventory
	convertSlot(arg0: int): int
	getSlotType(arg0: int): SlotType
	getBottomInventory(): Inventory
	getPlayer(): HumanEntity
	getCursor(): ItemStack
	setCursor(arg0: ItemStack): void
	setItem(arg0: int, arg1: ItemStack): void
	countSlots(): int
	getTitle(): String
	$SWITCH_TABLE$org$bukkit$event$inventory$InventoryType(): int[]
	setProperty(arg0: Property, arg1: int): boolean
	close(): void
	getType(): InventoryType
	getItem(arg0: int): ItemStack
}
namespace VehicleUpdateEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface FallingBlock extends Entity {
	getBlockData(): BlockData
	getMaterial(): Material
	getDropItem(): boolean
	setDropItem(arg0: boolean): void
	canHurtEntities(): boolean
	setHurtEntities(arg0: boolean): void
}
namespace VehicleMoveEvent {
	function getHandlerList(): HandlerList
	function getFrom(): Location
	function getTo(): Location
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Panda extends Animals {
	getMainGene(): Gene
	setMainGene(arg0: Gene): void
	getHiddenGene(): Gene
	setHiddenGene(arg0: Gene): void
}
declare class NumericPrompt extends ValidatingPrompt {
	isInputValid(arg0: ConversationContext, arg1: String): boolean
	acceptValidatedInput(arg0: ConversationContext, arg1: String): Prompt
	acceptValidatedInput(arg0: ConversationContext, arg1: Number): Prompt
	getFailedValidationText(arg0: ConversationContext, arg1: Number): String
	getFailedValidationText(arg0: ConversationContext, arg1: String): String
	isNumberValid(arg0: ConversationContext, arg1: Number): boolean
	getInputNotNumericText(arg0: ConversationContext, arg1: String): String
}
declare interface Mob extends LivingEntity, Lootable {
	setAware(arg0: boolean): void
	isAware(): boolean
	getTarget(): LivingEntity
	setTarget(arg0: LivingEntity): void
}
namespace CreeperPowerEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLightning(): LightningStrike
	function getEntity(): Entity
	function getEntity(): Creeper
	function getCause(): PowerCause
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Ageable extends BlockData {
	getMaximumAge(): int
	getAge(): int
	setAge(arg0: int): void
}
declare interface PluginMessageListener {
	onPluginMessageReceived(arg0: String, arg1: Player, arg2: byte[]): void
}
declare interface Beacon extends TileState, Lockable, Nameable {
	getEntitiesInRange(): Collection
	getPrimaryEffect(): PotionEffect
	setPrimaryEffect(arg0: PotionEffectType): void
	getSecondaryEffect(): PotionEffect
	setSecondaryEffect(arg0: PotionEffectType): void
	getTier(): int
}
namespace EntityShootBowEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getConsumable(): ItemStack
	function getProjectile(): Entity
	function setProjectile(arg0: Entity): void
	function setConsumeItem(arg0: boolean): void
	function shouldConsumeItem(): boolean
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function getBow(): ItemStack
	function getForce(): float
	function getHand(): EquipmentSlot
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Profession extends Enum implements Keyed {
	values(): Profession[]
	valueOf(arg0: String): Profession
	getKey(): NamespacedKey
}
declare class ConfigurationOptions {
	copyDefaults(arg0: boolean): ConfigurationOptions
	copyDefaults(): boolean
	configuration(): Configuration
	pathSeparator(): char
	pathSeparator(arg0: char): ConfigurationOptions
}
declare class FurnaceRecipe extends CookingRecipe {
	setInputChoice(arg0: RecipeChoice): FurnaceRecipe
	setInputChoice(arg0: RecipeChoice): CookingRecipe
	setInput(arg0: Material, arg1: int): FurnaceRecipe
	setInput(arg0: Material): CookingRecipe
	setInput(arg0: MaterialData): FurnaceRecipe
	setInput(arg0: Material): FurnaceRecipe
}
declare class SmokingRecipe extends CookingRecipe {
}
namespace PlayerEggThrowEvent {
	function getHandlerList(): HandlerList
	function setHatching(arg0: boolean): void
	function getHatchingType(): EntityType
	function setHatchingType(arg0: EntityType): void
	function getNumHatches(): byte
	function setNumHatches(arg0: byte): void
	function getEgg(): Egg
	function isHatching(): boolean
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Messenger {
	isReservedChannel(arg0: String): boolean
	getOutgoingChannels(arg0: Plugin): Set
	getOutgoingChannels(): Set
	getIncomingChannels(): Set
	getIncomingChannels(arg0: Plugin): Set
	isRegistrationValid(arg0: PluginMessageListenerRegistration): boolean
	dispatchIncomingMessage(arg0: Player, arg1: String, arg2: byte[]): void
	registerOutgoingPluginChannel(arg0: Plugin, arg1: String): void
	unregisterOutgoingPluginChannel(arg0: Plugin): void
	unregisterOutgoingPluginChannel(arg0: Plugin, arg1: String): void
	registerIncomingPluginChannel(arg0: Plugin, arg1: String, arg2: PluginMessageListener): PluginMessageListenerRegistration
	unregisterIncomingPluginChannel(arg0: Plugin): void
	unregisterIncomingPluginChannel(arg0: Plugin, arg1: String): void
	unregisterIncomingPluginChannel(arg0: Plugin, arg1: String, arg2: PluginMessageListener): void
	getIncomingChannelRegistrations(arg0: Plugin): Set
	getIncomingChannelRegistrations(arg0: String): Set
	getIncomingChannelRegistrations(arg0: Plugin, arg1: String): Set
	isIncomingChannelRegistered(arg0: Plugin, arg1: String): boolean
	isOutgoingChannelRegistered(arg0: Plugin, arg1: String): boolean
}
namespace StructureGrowEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isFromBonemeal(): boolean
	function getPlayer(): Player
	function getSpecies(): TreeType
	function getBlocks(): List
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PluginBase implements Plugin {
	getName(): String
	equals(arg0: Object): boolean
	hashCode(): int
}
namespace RaidTriggerEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getPlayer(): Player
	function getHandlers(): HandlerList
	function getRaid(): Raid
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerPickupItemEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRemaining(): int
	function getItem(): Item
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface InventoryHolder {
	getInventory(): Inventory
}
declare interface BossBar {
	removePlayer(arg0: Player): void
	setProgress(arg0: double): void
	getProgress(): double
	setVisible(arg0: boolean): void
	isVisible(): boolean
	getColor(): BarColor
	getPlayers(): List
	addPlayer(arg0: Player): void
	getTitle(): String
	setTitle(arg0: String): void
	getStyle(): BarStyle
	setStyle(arg0: BarStyle): void
	removeFlag(arg0: BarFlag): void
	hasFlag(arg0: BarFlag): boolean
	show(): void
	hide(): void
	removeAll(): void
	addFlag(arg0: BarFlag): void
	setColor(arg0: BarColor): void
}
namespace PlayerPreLoginEvent {
	function getUniqueId(): UUID
	function getHandlerList(): HandlerList
	function getKickMessage(): String
	function setKickMessage(arg0: String): void
	function getName(): String
	function disallow(arg0: Result, arg1: String): void
	function allow(): void
	function getAddress(): InetAddress
	function setResult(arg0: Result): void
	function getHandlers(): HandlerList
	function getResult(): Result
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace RaidStopEvent {
	function getHandlerList(): HandlerList
	function getReason(): Reason
	function getHandlers(): HandlerList
	function getRaid(): Raid
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BundleMeta extends ItemMeta {
	addItem(arg0: ItemStack): void
	hasItems(): boolean
	getItems(): List
	setItems(arg0: List): void
}
declare interface Plugin extends TabExecutor {
	getDescription(): PluginDescriptionFile
	getDataFolder(): File
	saveDefaultConfig(): void
	saveResource(arg0: String, arg1: boolean): void
	reloadConfig(): void
	getPluginLoader(): PluginLoader
	setNaggable(arg0: boolean): void
	getDefaultWorldGenerator(arg0: String, arg1: String): ChunkGenerator
	getConfig(): FileConfiguration
	getServer(): Server
	saveConfig(): void
	onDisable(): void
	onLoad(): void
	onEnable(): void
	isNaggable(): boolean
	isEnabled(): boolean
	getName(): String
	getResource(arg0: String): InputStream
	getLogger(): Logger
}
declare interface LlamaSpit extends Projectile {
}
namespace BlockReceiveGameEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEvent(): GameEvent
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Salmon extends Fish {
}
declare interface Turtle extends Animals {
}
declare interface Cocoa extends Ageable, Directional {
}
declare interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginMessageRecipient {
	setDisplayName(arg0: String): void
	sendRawMessage(arg0: String): void
	getAllowFlight(): boolean
	isSprinting(): boolean
	getScoreboard(): Scoreboard
	getBedSpawnLocation(): Location
	getPlayerListName(): String
	setPlayerListName(arg0: String): void
	getPlayerListHeader(): String
	getPlayerListFooter(): String
	setPlayerListHeader(arg0: String): void
	setPlayerListFooter(arg0: String): void
	setPlayerListHeaderFooter(arg0: String, arg1: String): void
	setCompassTarget(arg0: Location): void
	getCompassTarget(): Location
	performCommand(arg0: String): boolean
	setSneaking(arg0: boolean): void
	setSprinting(arg0: boolean): void
	setSleepingIgnored(arg0: boolean): void
	isSleepingIgnored(): boolean
	setBedSpawnLocation(arg0: Location): void
	setBedSpawnLocation(arg0: Location, arg1: boolean): void
	sendBlockChange(arg0: Location, arg1: BlockData): void
	sendBlockChange(arg0: Location, arg1: Material, arg2: byte): void
	sendBlockDamage(arg0: Location, arg1: float): void
	sendChunkChange(arg0: Location, arg1: int, arg2: int, arg3: int, arg4: byte[]): boolean
	sendSignChange(arg0: Location, arg1: String[]): void
	sendSignChange(arg0: Location, arg1: String[], arg2: DyeColor): void
	updateInventory(): void
	setPlayerTime(arg0: long, arg1: boolean): void
	getPlayerTime(): long
	getPlayerTimeOffset(): long
	isPlayerTimeRelative(): boolean
	resetPlayerTime(): void
	setPlayerWeather(arg0: WeatherType): void
	getPlayerWeather(): WeatherType
	resetPlayerWeather(): void
	giveExpLevels(arg0: int): void
	getTotalExperience(): int
	setTotalExperience(arg0: int): void
	sendExperienceChange(arg0: float, arg1: int): void
	sendExperienceChange(arg0: float): void
	setAllowFlight(arg0: boolean): void
	setFlySpeed(arg0: float): void
	setWalkSpeed(arg0: float): void
	getFlySpeed(): float
	getWalkSpeed(): float
	setTexturePack(arg0: String): void
	setResourcePack(arg0: String, arg1: byte[]): void
	setResourcePack(arg0: String): void
	setScoreboard(arg0: Scoreboard): void
	isHealthScaled(): boolean
	setHealthScaled(arg0: boolean): void
	setHealthScale(arg0: double): void
	getHealthScale(): double
	getSpectatorTarget(): Entity
	setSpectatorTarget(arg0: Entity): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Object): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double, arg8: Object): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double, arg6: double): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double, arg6: Object): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: Object): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double, arg8: double): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double, arg6: double, arg7: Object): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: Object): void
	getAdvancementProgress(arg0: Advancement): AdvancementProgress
	getClientViewDistance(): int
	updateCommands(): void
	isOnGround(): boolean
	playEffect(arg0: Location, arg1: Effect, arg2: Object): void
	playEffect(arg0: Location, arg1: Effect, arg2: int): void
	spigot(): Spigot
	spigot(): Spigot
	spigot(): Spigot
	getLocale(): String
	canSee(arg0: Player): boolean
	isSneaking(): boolean
	kickPlayer(arg0: String): void
	chat(arg0: String): void
	saveData(): void
	loadData(): void
	playNote(arg0: Location, arg1: byte, arg2: byte): void
	playNote(arg0: Location, arg1: Instrument, arg2: Note): void
	playSound(arg0: Location, arg1: Sound, arg2: SoundCategory, arg3: float, arg4: float): void
	playSound(arg0: Location, arg1: String, arg2: SoundCategory, arg3: float, arg4: float): void
	playSound(arg0: Location, arg1: Sound, arg2: float, arg3: float): void
	playSound(arg0: Location, arg1: String, arg2: float, arg3: float): void
	stopSound(arg0: String, arg1: SoundCategory): void
	stopSound(arg0: Sound, arg1: SoundCategory): void
	stopSound(arg0: String): void
	stopSound(arg0: Sound): void
	breakBlock(arg0: Block): boolean
	sendMap(arg0: MapView): void
	giveExp(arg0: int): void
	getExp(): float
	setExp(arg0: float): void
	hidePlayer(arg0: Plugin, arg1: Player): void
	hidePlayer(arg0: Player): void
	showPlayer(arg0: Plugin, arg1: Player): void
	showPlayer(arg0: Player): void
	setFlying(arg0: boolean): void
	sendTitle(arg0: String, arg1: String, arg2: int, arg3: int, arg4: int): void
	sendTitle(arg0: String, arg1: String): void
	resetTitle(): void
	getPing(): int
	openBook(arg0: ItemStack): void
	isFlying(): boolean
	getAddress(): InetSocketAddress
	getDisplayName(): String
	getLevel(): int
	setLevel(arg0: int): void
}
declare class NoiseGenerator {
	noise(arg0: double, arg1: int, arg2: double, arg3: double, arg4: boolean): double
	noise(arg0: double, arg1: int, arg2: double, arg3: double): double
	noise(arg0: double, arg1: double, arg2: double, arg3: int, arg4: double, arg5: double, arg6: boolean): double
	noise(arg0: double, arg1: double): double
	noise(arg0: double, arg1: double, arg2: int, arg3: double, arg4: double): double
	noise(arg0: double, arg1: double, arg2: int, arg3: double, arg4: double, arg5: boolean): double
	noise(arg0: double, arg1: double, arg2: double, arg3: int, arg4: double, arg5: double): double
	noise(arg0: double): double
	noise(arg0: double, arg1: double, arg2: double): double
	fade(arg0: double): double
	grad(arg0: int, arg1: double, arg2: double, arg3: double): double
	lerp(arg0: double, arg1: double, arg2: double): double
	floor(arg0: double): int
}
declare interface Scoreboard {
	registerNewObjective(arg0: String, arg1: String, arg2: String, arg3: RenderType): Objective
	registerNewObjective(arg0: String, arg1: String, arg2: String): Objective
	registerNewObjective(arg0: String, arg1: String): Objective
	getObjective(arg0: String): Objective
	getObjective(arg0: DisplaySlot): Objective
	getObjectivesByCriteria(arg0: String): Set
	getObjectives(): Set
	resetScores(arg0: OfflinePlayer): void
	resetScores(arg0: String): void
	getPlayerTeam(arg0: OfflinePlayer): Team
	getEntryTeam(arg0: String): Team
	registerNewTeam(arg0: String): Team
	getPlayers(): Set
	getScores(arg0: String): Set
	getScores(arg0: OfflinePlayer): Set
	getTeam(arg0: String): Team
	getTeams(): Set
	clearSlot(arg0: DisplaySlot): void
	getEntries(): Set
}
declare interface UnsafeValues {
	getDataVersion(): int
	getMaterial(arg0: String, arg1: int): Material
	modifyItemStack(arg0: ItemStack, arg1: String): ItemStack
	checkSupported(arg0: PluginDescriptionFile): void
	processClass(arg0: PluginDescriptionFile, arg1: String, arg2: byte[]): byte[]
	loadAdvancement(arg0: NamespacedKey, arg1: String): Advancement
	removeAdvancement(arg0: NamespacedKey): boolean
	toLegacy(arg0: Material): Material
	fromLegacy(arg0: Material, arg1: byte): BlockData
	fromLegacy(arg0: Material): Material
	fromLegacy(arg0: MaterialData): Material
	fromLegacy(arg0: MaterialData, arg1: boolean): Material
}
declare class MessagePrompt implements Prompt {
	blocksForInput(arg0: ConversationContext): boolean
	acceptInput(arg0: ConversationContext, arg1: String): Prompt
	getNextPrompt(arg0: ConversationContext): Prompt
}
declare class MapRenderer {
	isContextual(): boolean
	render(arg0: MapView, arg1: MapCanvas, arg2: Player): void
	initialize(arg0: MapView): void
}
declare interface Boat extends Vehicle {
	getMaxSpeed(): double
	setMaxSpeed(arg0: double): void
	getWoodType(): TreeSpecies
	setWoodType(arg0: TreeSpecies): void
	getOccupiedDeceleration(): double
	setOccupiedDeceleration(arg0: double): void
	getUnoccupiedDeceleration(): double
	setUnoccupiedDeceleration(arg0: double): void
	getWorkOnLand(): boolean
	setWorkOnLand(arg0: boolean): void
}
declare interface BlastFurnace extends Furnace {
}
declare interface ItemFactory {
	getItemMeta(arg0: Material): ItemMeta
	isApplicable(arg0: ItemMeta, arg1: Material): boolean
	isApplicable(arg0: ItemMeta, arg1: ItemStack): boolean
	updateMaterial(arg0: ItemMeta, arg1: Material): Material
	getDefaultLeatherColor(): Color
	asMetaFor(arg0: ItemMeta, arg1: ItemStack): ItemMeta
	asMetaFor(arg0: ItemMeta, arg1: Material): ItemMeta
	equals(arg0: ItemMeta, arg1: ItemMeta): boolean
}
namespace InventoryInteractEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getWhoClicked(): HumanEntity
	function setResult(arg0: Result): void
	function getResult(): Result
	function getHandlerList(): HandlerList
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Stray extends AbstractSkeleton {
}
declare interface LargeFireball extends SizedFireball {
}
declare interface Villager extends AbstractVillager {
	getProfession(): Profession
	setProfession(arg0: Profession): void
	getVillagerType(): Type
	setVillagerType(arg0: Type): void
	getVillagerLevel(): int
	setVillagerLevel(arg0: int): void
	getVillagerExperience(): int
	setVillagerExperience(arg0: int): void
	shakeHead(): void
	wakeup(): void
	sleep(arg0: Location): boolean
}
namespace FluidLevelChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getNewData(): BlockData
	function setNewData(arg0: BlockData): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface PluginMessageRecipient {
	sendPluginMessage(arg0: Plugin, arg1: String, arg2: byte[]): void
	getListeningPluginChannels(): Set
}
declare class Crops extends MaterialData {
	$SWITCH_TABLE$org$bukkit$Material(): int[]
	toString(): String
	clone(): Object
	clone(): Crops
	clone(): MaterialData
	getState(): CropState
	setState(arg0: CropState): void
}
namespace BrewEvent {
	function getContents(): BrewerInventory
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getFuelLevel(): int
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerArmorStandManipulateEvent {
	function getHandlerList(): HandlerList
	function getPlayerItem(): ItemStack
	function getArmorStandItem(): ItemStack
	function getRightClicked(): ArmorStand
	function getRightClicked(): Entity
	function getSlot(): EquipmentSlot
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHand(): EquipmentSlot
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerExpChangeEvent {
	function getHandlerList(): HandlerList
	function getAmount(): int
	function setAmount(arg0: int): void
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Vibration {
	getDestination(): Destination
	getArrivalTime(): int
	getOrigin(): Location
}
namespace BlockDropItemEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlockState(): BlockState
	function getPlayer(): Player
	function getItems(): List
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BukkitTask {
	isCancelled(): boolean
	cancel(): void
	getTaskId(): int
	getOwner(): Plugin
	isSync(): boolean
}
declare interface Smoker extends Furnace {
}
declare class Command {
	tabComplete0(arg0: CommandSender, arg1: String, arg2: String[], arg3: Location): List
	testPermissionSilent(arg0: CommandSender): boolean
	allowChangesFrom(arg0: CommandMap): boolean
	getPermissionMessage(): String
	getDescription(): String
	setDescription(arg0: String): Command
	setPermissionMessage(arg0: String): Command
	broadcastCommandMessage(arg0: CommandSender, arg1: String, arg2: boolean): void
	broadcastCommandMessage(arg0: CommandSender, arg1: String): void
	testPermission(arg0: CommandSender): boolean
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[]): List
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[], arg3: Location): List
	getLabel(): String
	setLabel(arg0: String): boolean
	getAliases(): List
	getUsage(): String
	setAliases(arg0: List): Command
	setUsage(arg0: String): Command
	getName(): String
	toString(): String
	isRegistered(): boolean
	register(arg0: CommandMap): boolean
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
	setName(arg0: String): boolean
	setPermission(arg0: String): void
	unregister(arg0: CommandMap): boolean
	getPermission(): String
}
declare class ExtendedRails extends Rails {
	setDirection(arg0: BlockFace, arg1: boolean): void
	getConvertedData(): byte
	isCurve(): boolean
	clone(): MaterialData
	clone(): Object
	clone(): Rails
	clone(): ExtendedRails
}
declare interface Parrot extends Tameable, Sittable {
	setVariant(arg0: Variant): void
	getVariant(): Variant
}
namespace PrepareItemEnchantEvent {
	function getEnchanter(): Player
	function getEnchantBlock(): Block
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getExpLevelCostsOffered(): int[]
	function getEnchantmentBonus(): int
	function getOffers(): EnchantmentOffer[]
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface AnaloguePowerable extends BlockData {
	getMaximumPower(): int
	getPower(): int
	setPower(arg0: int): void
}
declare class MapCursorCollection {
	removeCursor(arg0: MapCursor): boolean
	getCursor(arg0: int): MapCursor
	addCursor(arg0: int, arg1: int, arg2: byte): MapCursor
	addCursor(arg0: int, arg1: int, arg2: byte, arg3: byte, arg4: boolean): MapCursor
	addCursor(arg0: int, arg1: int, arg2: byte, arg3: byte): MapCursor
	addCursor(arg0: MapCursor): MapCursor
	addCursor(arg0: int, arg1: int, arg2: byte, arg3: byte, arg4: boolean, arg5: String): MapCursor
	size(): int
}
declare interface Orientable extends BlockData {
	getAxis(): Axis
	setAxis(arg0: Axis): void
	getAxes(): Set
}
declare class FireworkEffect implements ConfigurationSerializable {
	deserialize(arg0: Map): ConfigurationSerializable
	getFadeColors(): List
	serialize(): Map
	hasFlicker(): boolean
	hasTrail(): boolean
	getColors(): List
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	builder(): Builder
	getType(): Type
}
declare interface ItemMeta extends Cloneable, ConfigurationSerializable, PersistentDataHolder {
	setDisplayName(arg0: String): void
	hasDisplayName(): boolean
	hasLocalizedName(): boolean
	getLocalizedName(): String
	setLocalizedName(arg0: String): void
	hasCustomModelData(): boolean
	getCustomModelData(): int
	setCustomModelData(arg0: Integer): void
	hasEnchants(): boolean
	getEnchantLevel(arg0: Enchantment): int
	getEnchants(): Map
	removeEnchant(arg0: Enchantment): boolean
	hasConflictingEnchant(arg0: Enchantment): boolean
	addItemFlags(arg0: ItemFlag[]): void
	removeItemFlags(arg0: ItemFlag[]): void
	getItemFlags(): Set
	hasItemFlag(arg0: ItemFlag): boolean
	isUnbreakable(): boolean
	setUnbreakable(arg0: boolean): void
	hasAttributeModifiers(): boolean
	getAttributeModifiers(): Multimap
	getAttributeModifiers(arg0: Attribute): Collection
	getAttributeModifiers(arg0: EquipmentSlot): Multimap
	addAttributeModifier(arg0: Attribute, arg1: AttributeModifier): boolean
	setAttributeModifiers(arg0: Multimap): void
	removeAttributeModifier(arg0: EquipmentSlot): boolean
	removeAttributeModifier(arg0: Attribute): boolean
	removeAttributeModifier(arg0: Attribute, arg1: AttributeModifier): boolean
	getCustomTagContainer(): CustomItemTagContainer
	hasLore(): boolean
	getLore(): List
	setLore(arg0: List): void
	hasEnchant(arg0: Enchantment): boolean
	addEnchant(arg0: Enchantment, arg1: int, arg2: boolean): boolean
	setVersion(arg0: int): void
	clone(): ItemMeta
	clone(): Object
	getDisplayName(): String
}
declare class Bed extends MaterialData implements Directional {
	setFacingDirection(arg0: BlockFace): void
	isHeadOfBed(): boolean
	setHeadOfBed(arg0: boolean): void
	getFacing(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Bed
	clone(): MaterialData
}
declare interface PistonHead extends TechnicalPiston {
	isShort(): boolean
	setShort(arg0: boolean): void
}
declare class FixedMetadataValue extends LazyMetadataValue {
	value(): Object
	invalidate(): void
}
declare class WorldCreator {
	getGeneratorForName(arg0: String, arg1: String, arg2: CommandSender): ChunkGenerator
	generatorSettings(): String
	generatorSettings(arg0: String): WorldCreator
	generateStructures(arg0: boolean): WorldCreator
	generateStructures(): boolean
	createWorld(): World
	hardcore(arg0: boolean): WorldCreator
	hardcore(): boolean
	name(): String
	name(arg0: String): WorldCreator
	type(): WorldType
	type(arg0: WorldType): WorldCreator
	copy(arg0: WorldCreator): WorldCreator
	copy(arg0: World): WorldCreator
	generator(arg0: ChunkGenerator): WorldCreator
	generator(arg0: String): WorldCreator
	generator(): ChunkGenerator
	generator(arg0: String, arg1: CommandSender): WorldCreator
	seed(arg0: long): WorldCreator
	seed(): long
	environment(arg0: Environment): WorldCreator
	environment(): Environment
}
declare interface PiglinBrute extends PiglinAbstract {
}
declare class PermissionAttachment {
	getRemovalCallback(): PermissionRemovedExecutor
	unsetPermission(arg0: Permission): void
	unsetPermission(arg0: String): void
	getPermissible(): Permissible
	setRemovalCallback(arg0: PermissionRemovedExecutor): void
	getPlugin(): Plugin
	remove(): boolean
	getPermissions(): Map
	setPermission(arg0: String, arg1: boolean): void
	setPermission(arg0: Permission, arg1: boolean): void
}
namespace WorldUnloadEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace ChunkEvent {
	function getChunk(): Chunk
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockBurnEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getIgnitingBlock(): Block
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class SimpleRegistry implements Registry {
	get(arg0: NamespacedKey): Keyed
	get(arg0: NamespacedKey): Enum
	iterator(): Iterator
}
declare class BlockDestination implements Destination {
	getBlock(): Block
	getLocation(): Location
}
namespace EntityCombustEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getDuration(): int
	function setDuration(arg0: int): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Door extends Bisected, Directional, Openable, Powerable {
	getHinge(): Hinge
	setHinge(arg0: Hinge): void
}
declare interface PluginIdentifiableCommand {
	getPlugin(): Plugin
}
declare interface LecternInventory extends Inventory {
	getHolder(): Lectern
	getHolder(): InventoryHolder
}
declare interface ShulkerBullet extends Projectile {
	getTarget(): Entity
	setTarget(arg0: Entity): void
}
declare interface ConversationPrefix {
	getPrefix(arg0: ConversationContext): String
}
declare interface BigDripleaf extends Dripleaf {
	getTilt(): Tilt
	setTilt(arg0: Tilt): void
}
declare interface Mule extends ChestedHorse {
}
declare interface EntityEquipment {
	getArmorContents(): ItemStack[]
	getLeggingsDropChance(): float
	setItemInOffHand(arg0: ItemStack): void
	setItemInOffHand(arg0: ItemStack, arg1: boolean): void
	getBootsDropChance(): float
	getChestplateDropChance(): float
	setItemInOffHandDropChance(arg0: float): void
	setArmorContents(arg0: ItemStack[]): void
	getLeggings(): ItemStack
	setChestplate(arg0: ItemStack, arg1: boolean): void
	setChestplate(arg0: ItemStack): void
	getItemInOffHand(): ItemStack
	setBootsDropChance(arg0: float): void
	setLeggingsDropChance(arg0: float): void
	setLeggings(arg0: ItemStack, arg1: boolean): void
	setLeggings(arg0: ItemStack): void
	setItemInMainHand(arg0: ItemStack, arg1: boolean): void
	setItemInMainHand(arg0: ItemStack): void
	getItemInOffHandDropChance(): float
	getItemInHandDropChance(): float
	setChestplateDropChance(arg0: float): void
	getItemInMainHand(): ItemStack
	getChestplate(): ItemStack
	setHelmetDropChance(arg0: float): void
	getHelmetDropChance(): float
	setItemInHandDropChance(arg0: float): void
	getItemInHand(): ItemStack
	setItemInHand(arg0: ItemStack): void
	getHolder(): Entity
	getHelmet(): ItemStack
	setHelmet(arg0: ItemStack, arg1: boolean): void
	setHelmet(arg0: ItemStack): void
	getBoots(): ItemStack
	setBoots(arg0: ItemStack, arg1: boolean): void
	setBoots(arg0: ItemStack): void
	setItem(arg0: EquipmentSlot, arg1: ItemStack, arg2: boolean): void
	setItem(arg0: EquipmentSlot, arg1: ItemStack): void
	getItemInMainHandDropChance(): float
	setItemInMainHandDropChance(arg0: float): void
	clear(): void
	getItem(arg0: EquipmentSlot): ItemStack
}
namespace ProjectileHitEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHitBlock(): Block
	function getHitBlockFace(): BlockFace
	function getHitEntity(): Entity
	function getEntity(): Entity
	function getEntity(): Projectile
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface GlowLichen extends MultipleFacing, Waterlogged {
}
declare interface ServerOperator {
	isOp(): boolean
	setOp(arg0: boolean): void
}
declare class MetadataValueAdapter implements MetadataValue {
	getOwningPlugin(): Plugin
	asInt(): int
	asFloat(): float
	asDouble(): double
	asLong(): long
	asShort(): short
	asByte(): byte
	asBoolean(): boolean
	asString(): String
}
declare interface TrapDoor extends Bisected, Directional, Openable, Powerable, Waterlogged {
}
namespace PlayerBedLeaveEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function shouldSetSpawnLocation(): boolean
	function setSpawnLocation(arg0: boolean): void
	function getBed(): Block
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface World extends PluginMessageRecipient, Metadatable {
	getNearbyEntities(arg0: Location, arg1: double, arg2: double, arg3: double): Collection
	getNearbyEntities(arg0: Location, arg1: double, arg2: double, arg3: double, arg4: Predicate): Collection
	getNearbyEntities(arg0: BoundingBox): Collection
	getNearbyEntities(arg0: BoundingBox, arg1: Predicate): Collection
	getGameRuleValue(arg0: String): String
	getGameRuleValue(arg0: GameRule): Object
	getEntities(): List
	addPluginChunkTicket(arg0: int, arg1: int, arg2: Plugin): boolean
	removePluginChunkTicket(arg0: int, arg1: int, arg2: Plugin): boolean
	getPluginChunkTickets(): Map
	getPluginChunkTickets(arg0: int, arg1: int): Collection
	rayTraceBlocks(arg0: Location, arg1: Vector, arg2: double): RayTraceResult
	rayTraceBlocks(arg0: Location, arg1: Vector, arg2: double, arg3: FluidCollisionMode, arg4: boolean): RayTraceResult
	rayTraceBlocks(arg0: Location, arg1: Vector, arg2: double, arg3: FluidCollisionMode): RayTraceResult
	setDifficulty(arg0: Difficulty): void
	getClearWeatherDuration(): int
	createExplosion(arg0: Location, arg1: float, arg2: boolean): boolean
	createExplosion(arg0: Location, arg1: float, arg2: boolean, arg3: boolean, arg4: Entity): boolean
	createExplosion(arg0: double, arg1: double, arg2: double, arg3: float, arg4: boolean, arg5: boolean, arg6: Entity): boolean
	createExplosion(arg0: Location, arg1: float, arg2: boolean, arg3: boolean): boolean
	createExplosion(arg0: double, arg1: double, arg2: double, arg3: float): boolean
	createExplosion(arg0: double, arg1: double, arg2: double, arg3: float, arg4: boolean): boolean
	createExplosion(arg0: Location, arg1: float): boolean
	createExplosion(arg0: double, arg1: double, arg2: double, arg3: float, arg4: boolean, arg5: boolean): boolean
	setThundering(arg0: boolean): void
	getAllowAnimals(): boolean
	isClearWeather(): boolean
	getMaxHeight(): int
	setWeatherDuration(arg0: int): void
	spawnFallingBlock(arg0: Location, arg1: Material, arg2: byte): FallingBlock
	spawnFallingBlock(arg0: Location, arg1: BlockData): FallingBlock
	spawnFallingBlock(arg0: Location, arg1: MaterialData): FallingBlock
	getThunderDuration(): int
	getEmptyChunkSnapshot(arg0: int, arg1: int, arg2: boolean, arg3: boolean): ChunkSnapshot
	setThunderDuration(arg0: int): void
	isThundering(): boolean
	setAutoSave(arg0: boolean): void
	getAllowMonsters(): boolean
	getPopulators(): List
	setSpawnFlags(arg0: boolean, arg1: boolean): void
	getMinHeight(): int
	getSeaLevel(): int
	getKeepSpawnInMemory(): boolean
	setClearWeatherDuration(arg0: int): void
	setKeepSpawnInMemory(arg0: boolean): void
	getDifficulty(): Difficulty
	getEntitiesByClass(arg0: Class[]): Collection
	getEntitiesByClass(arg0: Class): Collection
	getLivingEntities(): List
	getWeatherDuration(): int
	strikeLightning(arg0: Location): LightningStrike
	strikeLightningEffect(arg0: Location): LightningStrike
	getHighestBlockAt(arg0: Location): Block
	getHighestBlockAt(arg0: Location, arg1: HeightMap): Block
	getHighestBlockAt(arg0: int, arg1: int): Block
	getHighestBlockAt(arg0: int, arg1: int, arg2: HeightMap): Block
	getGameTime(): long
	setFullTime(arg0: long): void
	getFullTime(): long
	getSpawnLocation(): Location
	rayTraceEntities(arg0: Location, arg1: Vector, arg2: double, arg3: Predicate): RayTraceResult
	rayTraceEntities(arg0: Location, arg1: Vector, arg2: double): RayTraceResult
	rayTraceEntities(arg0: Location, arg1: Vector, arg2: double, arg3: double): RayTraceResult
	rayTraceEntities(arg0: Location, arg1: Vector, arg2: double, arg3: double, arg4: Predicate): RayTraceResult
	getEntitiesByClasses(arg0: Class[]): Collection
	setAmbientSpawnLimit(arg0: int): void
	spawnEntity(arg0: Location, arg1: EntityType): Entity
	removePluginChunkTickets(arg0: Plugin): void
	setWaterAnimalSpawnLimit(arg0: int): void
	getForceLoadedChunks(): Collection
	setTicksPerWaterSpawns(arg0: int): void
	refreshChunk(arg0: int, arg1: int): boolean
	unloadChunkRequest(arg0: int, arg1: int): boolean
	isChunkInUse(arg0: int, arg1: int): boolean
	locateNearestRaid(arg0: Location, arg1: int): Raid
	setGameRuleValue(arg0: String, arg1: String): boolean
	setSpawnLocation(arg0: int, arg1: int, arg2: int, arg3: float): boolean
	setSpawnLocation(arg0: int, arg1: int, arg2: int): boolean
	setSpawnLocation(arg0: Location): boolean
	getEnderDragonBattle(): DragonBattle
	setMonsterSpawnLimit(arg0: int): void
	setTicksPerAnimalSpawns(arg0: int): void
	setHardcore(arg0: boolean): void
	getGameRules(): String[]
	setWaterAmbientSpawnLimit(arg0: int): void
	getWorldBorder(): WorldBorder
	getGenerator(): ChunkGenerator
	canGenerateStructures(): boolean
	setTicksPerMonsterSpawns(arg0: int): void
	getGameRuleDefault(arg0: GameRule): Object
	setTicksPerAmbientSpawns(arg0: int): void
	locateNearestStructure(arg0: Location, arg1: StructureType, arg2: int, arg3: boolean): Location
	setGameRule(arg0: GameRule, arg1: Object): boolean
	setAnimalSpawnLimit(arg0: int): void
	getWorldFolder(): File
	isChunkLoaded(arg0: Chunk): boolean
	isChunkLoaded(arg0: int, arg1: int): boolean
	setChunkForceLoaded(arg0: int, arg1: int, arg2: boolean): void
	regenerateChunk(arg0: int, arg1: int): boolean
	unloadChunk(arg0: int, arg1: int): boolean
	unloadChunk(arg0: Chunk): boolean
	unloadChunk(arg0: int, arg1: int, arg2: boolean): boolean
	getLoadedChunks(): Chunk[]
	generateTree(arg0: Location, arg1: TreeType, arg2: BlockChangeDelegate): boolean
	generateTree(arg0: Location, arg1: TreeType): boolean
	isChunkGenerated(arg0: int, arg1: int): boolean
	isChunkForceLoaded(arg0: int, arg1: int): boolean
	getHighestBlockYAt(arg0: int, arg1: int, arg2: HeightMap): int
	getHighestBlockYAt(arg0: int, arg1: int): int
	getHighestBlockYAt(arg0: Location): int
	getHighestBlockYAt(arg0: Location, arg1: HeightMap): int
	getEnvironment(): Environment
	getViewDistance(): int
	getWorldType(): WorldType
	getTicksPerAnimalSpawns(): long
	getTicksPerMonsterSpawns(): long
	getTicksPerWaterSpawns(): long
	getTicksPerAmbientSpawns(): long
	getMonsterSpawnLimit(): int
	getAnimalSpawnLimit(): int
	getWaterAnimalSpawnLimit(): int
	getWaterAmbientSpawnLimit(): int
	getAmbientSpawnLimit(): int
	getTemperature(arg0: int, arg1: int): double
	getTemperature(arg0: int, arg1: int, arg2: int): double
	getHumidity(arg0: int, arg1: int, arg2: int): double
	getHumidity(arg0: int, arg1: int): double
	dropItemNaturally(arg0: Location, arg1: ItemStack): Item
	dropItemNaturally(arg0: Location, arg1: ItemStack, arg2: Consumer): Item
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Object): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double, arg8: double): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double, arg6: double): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Object, arg10: boolean): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double, arg6: double, arg7: Object, arg8: boolean): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double, arg6: double, arg7: Object): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: Object): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double, arg6: Object): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: Object): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int, arg3: double, arg4: double, arg5: double): void
	spawnParticle(arg0: Particle, arg1: Location, arg2: int): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int): void
	spawnParticle(arg0: Particle, arg1: double, arg2: double, arg3: double, arg4: int, arg5: double, arg6: double, arg7: double, arg8: Object): void
	spawnArrow(arg0: Location, arg1: Vector, arg2: float, arg3: float): Arrow
	spawnArrow(arg0: Location, arg1: Vector, arg2: float, arg3: float, arg4: Class): AbstractArrow
	getUID(): UUID
	getChunkAt(arg0: Location): Chunk
	getChunkAt(arg0: Block): Chunk
	getChunkAt(arg0: int, arg1: int): Chunk
	getBlockAt(arg0: Location): Block
	getBlockAt(arg0: int, arg1: int, arg2: int): Block
	getSeed(): long
	playEffect(arg0: Location, arg1: Effect, arg2: Object, arg3: int): void
	playEffect(arg0: Location, arg1: Effect, arg2: int): void
	playEffect(arg0: Location, arg1: Effect, arg2: int, arg3: int): void
	playEffect(arg0: Location, arg1: Effect, arg2: Object): void
	spigot(): Spigot
	loadChunk(arg0: int, arg1: int, arg2: boolean): boolean
	loadChunk(arg0: Chunk): void
	loadChunk(arg0: int, arg1: int): void
	getPlayers(): List
	playSound(arg0: Location, arg1: Sound, arg2: float, arg3: float): void
	playSound(arg0: Location, arg1: Sound, arg2: SoundCategory, arg3: float, arg4: float): void
	playSound(arg0: Location, arg1: String, arg2: SoundCategory, arg3: float, arg4: float): void
	playSound(arg0: Location, arg1: String, arg2: float, arg3: float): void
	isHardcore(): boolean
	getBiome(arg0: int, arg1: int, arg2: int): Biome
	getBiome(arg0: int, arg1: int): Biome
	setBiome(arg0: int, arg1: int, arg2: Biome): void
	setBiome(arg0: int, arg1: int, arg2: int, arg3: Biome): void
	rayTrace(arg0: Location, arg1: Vector, arg2: double, arg3: FluidCollisionMode, arg4: boolean, arg5: double, arg6: Predicate): RayTraceResult
	dropItem(arg0: Location, arg1: ItemStack, arg2: Consumer): Item
	dropItem(arg0: Location, arg1: ItemStack): Item
	hasStorm(): boolean
	setStorm(arg0: boolean): void
	getPVP(): boolean
	setPVP(arg0: boolean): void
	spawn(arg0: Location, arg1: Class): Entity
	spawn(arg0: Location, arg1: Class, arg2: Consumer): Entity
	isAutoSave(): boolean
	isGameRule(arg0: String): boolean
	getRaids(): List
	setTicksPerWaterAmbientSpawns(arg0: int): void
	getTicksPerWaterAmbientSpawns(): long
	getName(): String
	save(): void
	getTime(): long
	setTime(arg0: long): void
}
declare interface SerializableAs extends Annotation {
	value(): String
}
namespace LootGenerateEvent {
	function getLootTable(): LootTable
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getInventoryHolder(): InventoryHolder
	function getLootContext(): LootContext
	function getEntity(): Entity
	function setLoot(arg0: Collection): void
	function getLoot(): List
	function isPlugin(): boolean
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockPlaceEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlockPlaced(): Block
	function getBlockReplacedState(): BlockState
	function getBlockAgainst(): Block
	function getItemInHand(): ItemStack
	function getPlayer(): Player
	function getHand(): EquipmentSlot
	function canBuild(): boolean
	function setBuild(arg0: boolean): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Material extends Enum implements Keyed {
	getMaxStackSize(): int
	getMaxDurability(): short
	matchMaterial(arg0: String, arg1: boolean): Material
	matchMaterial(arg0: String): Material
	isTransparent(): boolean
	isFlammable(): boolean
	isOccluding(): boolean
	isInteractable(): boolean
	getHardness(): float
	getBlastResistance(): float
	getSlipperiness(): float
	getCraftingRemainingItem(): Material
	getEquipmentSlot(): EquipmentSlot
	getMaterial(arg0: String): Material
	getMaterial(arg0: String, arg1: boolean): Material
	createBlockData(arg0: Consumer): BlockData
	createBlockData(arg0: String): BlockData
	createBlockData(): BlockData
	hasGravity(): boolean
	getData(): Class
	isLegacy(): boolean
	getNewData(arg0: byte): MaterialData
	isBlock(): boolean
	isEdible(): boolean
	isSolid(): boolean
	isAir(): boolean
	isBurnable(): boolean
	isFuel(): boolean
	isItem(): boolean
	$SWITCH_TABLE$org$bukkit$Material(): int[]
	values(): Material[]
	valueOf(arg0: String): Material
	isRecord(): boolean
	getKey(): NamespacedKey
	getId(): int
}
declare interface BrewingStand extends BlockData {
	getMaximumBottles(): int
	hasBottle(arg0: int): boolean
	setBottle(arg0: int, arg1: boolean): void
	getBottles(): Set
}
namespace BlockPhysicsEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getSourceBlock(): Block
	function getChangedType(): Material
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Conduit extends TileState {
}
declare interface Rabbit extends Animals {
	getRabbitType(): Type
	setRabbitType(arg0: Type): void
}
declare interface Vex extends Monster {
	setCharging(arg0: boolean): void
	isCharging(): boolean
}
namespace PlayerLoginEvent {
	function getHandlerList(): HandlerList
	function getRealAddress(): InetAddress
	function getHostname(): String
	function getKickMessage(): String
	function setKickMessage(arg0: String): void
	function disallow(arg0: Result, arg1: String): void
	function allow(): void
	function getAddress(): InetAddress
	function setResult(arg0: Result): void
	function getHandlers(): HandlerList
	function getResult(): Result
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface ComplexEntityPart extends Entity {
	getParent(): ComplexLivingEntity
}
declare interface Dropper extends Container, Lootable {
	drop(): void
}
declare class TexturedMaterial extends MaterialData {
	setMaterial(arg0: Material): void
	getTextures(): List
	getTextureIndex(): int
	setTextureIndex(arg0: int): void
	getMaterial(): Material
	toString(): String
	clone(): MaterialData
	clone(): Object
	clone(): TexturedMaterial
}
declare interface Cat extends Tameable, Sittable {
	getCollarColor(): DyeColor
	setCollarColor(arg0: DyeColor): void
	getCatType(): Type
	setCatType(arg0: Type): void
}
declare interface CustomItemTagContainer {
	setCustomTag(arg0: NamespacedKey, arg1: ItemTagType, arg2: Object): void
	hasCustomTag(arg0: NamespacedKey, arg1: ItemTagType): boolean
	getCustomTag(arg0: NamespacedKey, arg1: ItemTagType): Object
	removeCustomTag(arg0: NamespacedKey): void
	getAdapterContext(): ItemTagAdapterContext
	isEmpty(): boolean
}
namespace ChunkPopulateEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getChunk(): Chunk
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class BlastingRecipe extends CookingRecipe {
}
namespace PrepareItemCraftEvent {
	function getHandlerList(): HandlerList
	function getInventory(): Inventory
	function getInventory(): CraftingInventory
	function getRecipe(): Recipe
	function isRepair(): boolean
	function getHandlers(): HandlerList
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface FishHook extends Projectile {
	getMinWaitTime(): int
	setMinWaitTime(arg0: int): void
	getMaxWaitTime(): int
	setMaxWaitTime(arg0: int): void
	getApplyLure(): boolean
	setApplyLure(arg0: boolean): void
	getBiteChance(): double
	setBiteChance(arg0: double): void
	isInOpenWater(): boolean
	getHookedEntity(): Entity
	setHookedEntity(arg0: Entity): void
	pullHookedEntity(): boolean
	getState(): HookState
}
declare interface Silverfish extends Monster {
}
namespace EntityExplodeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getYield(): float
	function blockList(): List
	function setYield(arg0: float): void
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class FlowerPot extends MaterialData {
	getContents(): MaterialData
	setContents(arg0: MaterialData): void
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): FlowerPot
}
declare interface Registry extends Iterable {
	lambda$0(arg0: EntityType): boolean
	lambda$1(arg0: Material): boolean
	get(arg0: NamespacedKey): Keyed
}
declare interface Phantom extends Flying {
	getSize(): int
	setSize(arg0: int): void
}
namespace PiglinBarterEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): Piglin
	function getOutcome(): List
	function getInput(): ItemStack
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class LootContext {
	getLootingModifier(): int
	getLootedEntity(): Entity
	getKiller(): HumanEntity
	getLuck(): float
	getLocation(): Location
}
declare class PoweredRail extends ExtendedRails implements Redstone {
	isPowered(): boolean
	setPowered(arg0: boolean): void
	clone(): MaterialData
	clone(): Object
	clone(): Rails
	clone(): ExtendedRails
	clone(): PoweredRail
}
declare class GenericCommandHelpTopic extends HelpTopic {
	canSee(arg0: CommandSender): boolean
}
namespace VehicleEvent {
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class MemoryKey implements Keyed {
	getMemoryClass(): Class
	getByKey(arg0: NamespacedKey): MemoryKey
	values(): Set
	getKey(): NamespacedKey
}
declare interface CartographyInventory extends Inventory {
}
declare interface Flying extends Mob {
}
namespace BlockShearEntityEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getTool(): ItemStack
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Golem extends Creature {
}
declare interface SoundGroup {
	getBreakSound(): Sound
	getStepSound(): Sound
	getPlaceSound(): Sound
	getHitSound(): Sound
	getFallSound(): Sound
	getPitch(): float
	getVolume(): float
}
declare class Spigot {
	strikeLightning(arg0: Location, arg1: boolean): LightningStrike
	strikeLightningEffect(arg0: Location, arg1: boolean): LightningStrike
}
declare interface SmallFireball extends SizedFireball {
}
declare interface Egg extends ThrowableProjectile {
}
namespace ChunkUnloadEvent {
	function getHandlerList(): HandlerList
	function isSaveChunk(): boolean
	function setSaveChunk(arg0: boolean): void
	function getHandlers(): HandlerList
	function getChunk(): Chunk
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface ChunkSnapshot {
	getBlockData(arg0: int, arg1: int, arg2: int): BlockData
	getHighestBlockYAt(arg0: int, arg1: int): int
	getWorldName(): String
	getBlockType(arg0: int, arg1: int, arg2: int): Material
	getBlockSkyLight(arg0: int, arg1: int, arg2: int): int
	getBlockEmittedLight(arg0: int, arg1: int, arg2: int): int
	getRawBiomeTemperature(arg0: int, arg1: int, arg2: int): double
	getRawBiomeTemperature(arg0: int, arg1: int): double
	getCaptureFullTime(): long
	isSectionEmpty(arg0: int): boolean
	getX(): int
	getZ(): int
	getData(arg0: int, arg1: int, arg2: int): int
	getBiome(arg0: int, arg1: int, arg2: int): Biome
	getBiome(arg0: int, arg1: int): Biome
	contains(arg0: BlockData): boolean
}
declare class Statistic extends Enum implements Keyed {
	isSubstatistic(): boolean
	isBlock(): boolean
	values(): Statistic[]
	valueOf(arg0: String): Statistic
	getKey(): NamespacedKey
	getType(): Type
}
declare interface ConfigurationSection {
	createSection(arg0: String): ConfigurationSection
	createSection(arg0: String, arg1: Map): ConfigurationSection
	getCurrentPath(): String
	getStringList(arg0: String): List
	getIntegerList(arg0: String): List
	getBooleanList(arg0: String): List
	getDoubleList(arg0: String): List
	getFloatList(arg0: String): List
	getLongList(arg0: String): List
	getByteList(arg0: String): List
	getCharacterList(arg0: String): List
	getShortList(arg0: String): List
	getSerializable(arg0: String, arg1: Class, arg2: ConfigurationSerializable): ConfigurationSerializable
	getSerializable(arg0: String, arg1: Class): ConfigurationSerializable
	getOfflinePlayer(arg0: String, arg1: OfflinePlayer): OfflinePlayer
	getOfflinePlayer(arg0: String): OfflinePlayer
	isOfflinePlayer(arg0: String): boolean
	getItemStack(arg0: String): ItemStack
	getItemStack(arg0: String, arg1: ItemStack): ItemStack
	isItemStack(arg0: String): boolean
	getConfigurationSection(arg0: String): ConfigurationSection
	isConfigurationSection(arg0: String): boolean
	getDefaultSection(): ConfigurationSection
	getColor(arg0: String, arg1: Color): Color
	getColor(arg0: String): Color
	getValues(arg0: boolean): Map
	addDefault(arg0: String, arg1: Object): void
	isString(arg0: String): boolean
	isInt(arg0: String): boolean
	isBoolean(arg0: String): boolean
	isDouble(arg0: String): boolean
	isLong(arg0: String): boolean
	getList(arg0: String, arg1: List): List
	getList(arg0: String): List
	isList(arg0: String): boolean
	getMapList(arg0: String): List
	getVector(arg0: String, arg1: Vector): Vector
	getVector(arg0: String): Vector
	isVector(arg0: String): boolean
	isColor(arg0: String): boolean
	isLocation(arg0: String): boolean
	getName(): String
	get(arg0: String, arg1: Object): Object
	get(arg0: String): Object
	getBoolean(arg0: String): boolean
	getBoolean(arg0: String, arg1: boolean): boolean
	getInt(arg0: String): int
	getInt(arg0: String, arg1: int): int
	getLong(arg0: String, arg1: long): long
	getLong(arg0: String): long
	getDouble(arg0: String): double
	getDouble(arg0: String, arg1: double): double
	contains(arg0: String, arg1: boolean): boolean
	contains(arg0: String): boolean
	getLocation(arg0: String, arg1: Location): Location
	getLocation(arg0: String): Location
	getParent(): ConfigurationSection
	set(arg0: String, arg1: Object): void
	isSet(arg0: String): boolean
	getRoot(): Configuration
	getObject(arg0: String, arg1: Class): Object
	getObject(arg0: String, arg1: Class, arg2: Object): Object
	getString(arg0: String): String
	getString(arg0: String, arg1: String): String
	getKeys(arg0: boolean): Set
}
declare interface BlockChangeDelegate {
	getBlockData(arg0: int, arg1: int, arg2: int): BlockData
	setBlockData(arg0: int, arg1: int, arg2: int, arg3: BlockData): boolean
	getHeight(): int
	isEmpty(arg0: int, arg1: int, arg2: int): boolean
}
declare class IndexHelpTopic extends HelpTopic {
	amendCanSee(arg0: String): void
	getFullText(arg0: CommandSender): String
	setTopicsCollection(arg0: Collection): void
	buildPreamble(arg0: CommandSender): String
	buildIndexLine(arg0: CommandSender, arg1: HelpTopic): String
	canSee(arg0: CommandSender): boolean
}
declare class Chest extends DirectionalContainer {
	clone(): Object
	clone(): MaterialData
	clone(): DirectionalContainer
	clone(): Chest
}
namespace WorldInitEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Objective {
	setDisplayName(arg0: String): void
	getScoreboard(): Scoreboard
	getCriteria(): String
	isModifiable(): boolean
	setDisplaySlot(arg0: DisplaySlot): void
	getDisplaySlot(): DisplaySlot
	setRenderType(arg0: RenderType): void
	getRenderType(): RenderType
	getScore(arg0: String): Score
	getScore(arg0: OfflinePlayer): Score
	getName(): String
	getDisplayName(): String
	unregister(): void
}
declare class Conversation {
	acceptInput(arg0: String): void
	isLocalEchoEnabled(): boolean
	setLocalEchoEnabled(arg0: boolean): void
	addConversationCanceller(arg0: ConversationCanceller): void
	getCancellers(): List
	outputNextPrompt(): void
	getForWhom(): Conversable
	getPrefix(): ConversationPrefix
	setPrefix(arg0: ConversationPrefix): void
	isModal(): boolean
	setModal(arg0: boolean): void
	abandon(arg0: ConversationAbandonedEvent): void
	abandon(): void
	addConversationAbandonedListener(arg0: ConversationAbandonedListener): void
	removeConversationAbandonedListener(arg0: ConversationAbandonedListener): void
	begin(): void
	getContext(): ConversationContext
	getState(): ConversationState
}
declare class Furnace extends FurnaceAndDispenser {
	clone(): MaterialData
	clone(): Object
	clone(): DirectionalContainer
	clone(): FurnaceAndDispenser
	clone(): Furnace
}
namespace EntityDamageByEntityEvent {
	function getDamager(): Entity
	function isApplicable(arg0: DamageModifier): boolean
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getOriginalDamage(arg0: DamageModifier): double
	function getFinalDamage(): double
	function setDamage(arg0: double): void
	function setDamage(arg0: DamageModifier, arg1: double): void
	function getDamage(): double
	function getDamage(arg0: DamageModifier): double
	function getCause(): DamageCause
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Bukkit {
	getLootTable(arg0: NamespacedKey): LootTable
	getOnlinePlayers(): Collection
	getConsoleSender(): ConsoleCommandSender
	getItemFactory(): ItemFactory
	getPluginManager(): PluginManager
	getOfflinePlayer(arg0: String): OfflinePlayer
	getOfflinePlayer(arg0: UUID): OfflinePlayer
	createChunkData(arg0: World): ChunkData
	dispatchCommand(arg0: CommandSender, arg1: String): boolean
	getMaxPlayers(): int
	getBukkitVersion(): String
	getViewDistance(): int
	getWorldType(): String
	getGenerateStructures(): boolean
	getMaxWorldSize(): int
	getAllowEnd(): boolean
	getAllowNether(): boolean
	hasWhitelist(): boolean
	setWhitelist(arg0: boolean): void
	isWhitelistEnforced(): boolean
	setWhitelistEnforced(arg0: boolean): void
	getWhitelistedPlayers(): Set
	reloadWhitelist(): void
	broadcastMessage(arg0: String): int
	getUpdateFolder(): String
	getUpdateFolderFile(): File
	getConnectionThrottle(): long
	getTicksPerAnimalSpawns(): int
	getTicksPerMonsterSpawns(): int
	getTicksPerWaterSpawns(): int
	getTicksPerAmbientSpawns(): int
	getPlayerExact(arg0: String): Player
	matchPlayer(arg0: String): List
	getScheduler(): BukkitScheduler
	getServicesManager(): ServicesManager
	createWorld(arg0: WorldCreator): World
	unloadWorld(arg0: World, arg1: boolean): boolean
	unloadWorld(arg0: String, arg1: boolean): boolean
	createExplorerMap(arg0: World, arg1: Location, arg2: StructureType): ItemStack
	createExplorerMap(arg0: World, arg1: Location, arg2: StructureType, arg3: int, arg4: boolean): ItemStack
	getPluginCommand(arg0: String): PluginCommand
	savePlayers(): void
	getRecipesFor(arg0: ItemStack): List
	recipeIterator(): Iterator
	clearRecipes(): void
	resetRecipes(): void
	removeRecipe(arg0: NamespacedKey): boolean
	getCommandAliases(): Map
	getSpawnRadius(): int
	setSpawnRadius(arg0: int): void
	getOnlineMode(): boolean
	getAllowFlight(): boolean
	getBannedPlayers(): Set
	getOperators(): Set
	getDefaultGameMode(): GameMode
	setDefaultGameMode(arg0: GameMode): void
	getWorldContainer(): File
	getOfflinePlayers(): OfflinePlayer[]
	getMessenger(): Messenger
	createInventory(arg0: InventoryHolder, arg1: InventoryType): Inventory
	createInventory(arg0: InventoryHolder, arg1: int, arg2: String): Inventory
	createInventory(arg0: InventoryHolder, arg1: InventoryType, arg2: String): Inventory
	createInventory(arg0: InventoryHolder, arg1: int): Inventory
	createMerchant(arg0: String): Merchant
	getMonsterSpawnLimit(): int
	getAnimalSpawnLimit(): int
	getWaterAnimalSpawnLimit(): int
	getWaterAmbientSpawnLimit(): int
	getAmbientSpawnLimit(): int
	isPrimaryThread(): boolean
	getShutdownMessage(): String
	getWarningState(): WarningState
	getScoreboardManager(): ScoreboardManager
	getServerIcon(): CachedServerIcon
	loadServerIcon(arg0: File): CachedServerIcon
	loadServerIcon(arg0: BufferedImage): CachedServerIcon
	setIdleTimeout(arg0: int): void
	getIdleTimeout(): int
	createBossBar(arg0: String, arg1: BarColor, arg2: BarStyle, arg3: BarFlag[]): BossBar
	createBossBar(arg0: NamespacedKey, arg1: String, arg2: BarColor, arg3: BarStyle, arg4: BarFlag[]): KeyedBossBar
	getBossBars(): Iterator
	removeBossBar(arg0: NamespacedKey): boolean
	getAdvancement(arg0: NamespacedKey): Advancement
	advancementIterator(): Iterator
	createBlockData(arg0: Material, arg1: Consumer): BlockData
	createBlockData(arg0: Material, arg1: String): BlockData
	createBlockData(arg0: String): BlockData
	createBlockData(arg0: Material): BlockData
	selectEntities(arg0: CommandSender, arg1: String): List
	reload(): void
	getWorld(arg0: UUID): World
	getWorld(arg0: String): World
	getEntity(arg0: UUID): Entity
	getServer(): Server
	spigot(): Spigot
	getPlayer(arg0: UUID): Player
	getPlayer(arg0: String): Player
	getBossBar(arg0: NamespacedKey): KeyedBossBar
	getRecipe(arg0: NamespacedKey): Recipe
	getMotd(): String
	getIp(): String
	getWorlds(): List
	reloadData(): void
	addRecipe(arg0: Recipe): boolean
	isHardcore(): boolean
	getIPBans(): Set
	banIP(arg0: String): void
	unbanIP(arg0: String): void
	getBanList(arg0: Type): BanList
	getHelpMap(): HelpMap
	getTags(arg0: String, arg1: Class): Iterable
	setServer(arg0: Server): void
	getTicksPerWaterAmbientSpawns(): int
	getName(): String
	shutdown(): void
	getUnsafe(): UnsafeValues
	getLogger(): Logger
	getPort(): int
	broadcast(arg0: String, arg1: String): int
	getMap(arg0: int): MapView
	createMap(arg0: World): MapView
	getTag(arg0: String, arg1: NamespacedKey, arg2: Class): Tag
	getVersion(): String
}
declare interface Attributable {
	getAttribute(arg0: Attribute): AttributeInstance
}
namespace PlayerJoinEvent {
	function getHandlerList(): HandlerList
	function getJoinMessage(): String
	function setJoinMessage(arg0: String): void
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface HopperMinecart extends Minecart, InventoryHolder, Lootable {
	isEnabled(): boolean
	setEnabled(arg0: boolean): void
}
namespace CreatureSpawnEvent {
	function getSpawnReason(): SpawnReason
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Leaves extends BlockData {
	setPersistent(arg0: boolean): void
	isPersistent(): boolean
	getDistance(): int
	setDistance(arg0: int): void
}
declare interface FireworkMeta extends ItemMeta {
	getEffectsSize(): int
	removeEffect(arg0: int): void
	clearEffects(): void
	getPower(): int
	setPower(arg0: int): void
	getEffects(): List
	addEffect(arg0: FireworkEffect): void
	addEffects(arg0: FireworkEffect[]): void
	addEffects(arg0: Iterable): void
	hasEffects(): boolean
	clone(): Object
	clone(): ItemMeta
	clone(): FireworkMeta
}
declare class RedstoneWire extends MaterialData implements Redstone {
	isPowered(): boolean
	toString(): String
	clone(): RedstoneWire
	clone(): MaterialData
	clone(): Object
}
declare interface SpectralArrow extends AbstractArrow {
	getGlowingTicks(): int
	setGlowingTicks(arg0: int): void
}
declare interface Horse extends AbstractHorse {
	isCarryingChest(): boolean
	setCarryingChest(arg0: boolean): void
	getInventory(): AbstractHorseInventory
	getInventory(): HorseInventory
	getInventory(): Inventory
	getColor(): Color
	getStyle(): Style
	setStyle(arg0: Style): void
	setColor(arg0: Color): void
}
declare interface WitherSkeleton extends AbstractSkeleton {
}
declare interface Piston extends Directional {
	setExtended(arg0: boolean): void
	isExtended(): boolean
}
declare class ConfigurationSerialization {
	deserialize(arg0: Map): ConfigurationSerializable
	registerClass(arg0: Class): void
	registerClass(arg0: Class, arg1: String): void
	deserializeViaMethod(arg0: Method, arg1: Map): ConfigurationSerializable
	deserializeViaCtor(arg0: Constructor, arg1: Map): ConfigurationSerializable
	deserializeObject(arg0: Map, arg1: Class): ConfigurationSerializable
	deserializeObject(arg0: Map): ConfigurationSerializable
	getClassByAlias(arg0: String): Class
	unregisterClass(arg0: Class): void
	unregisterClass(arg0: String): void
	getAlias(arg0: Class): String
	getMethod(arg0: String, arg1: boolean): Method
	getConstructor(): Constructor
}
declare class Door extends MaterialData implements Directional, Openable {
	setFacingDirection(arg0: BlockFace): void
	getWoodDoorOfSpecies(arg0: TreeSpecies): Material
	getHingeCorner(): BlockFace
	getFacing(): BlockFace
	setOpen(arg0: boolean): void
	getHinge(): boolean
	setHinge(arg0: boolean): void
	setTopHalf(arg0: boolean): void
	isTopHalf(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	$SWITCH_TABLE$org$bukkit$TreeSpecies(): int[]
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): Door
	isOpen(): boolean
}
declare interface Gate extends Directional, Openable, Powerable {
	isInWall(): boolean
	setInWall(arg0: boolean): void
}
declare class Leaves extends Wood {
	isDecayable(): boolean
	setDecayable(arg0: boolean): void
	setDecaying(arg0: boolean): void
	isDecaying(): boolean
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): Wood
	clone(): Leaves
}
declare interface Waterlogged extends BlockData {
	isWaterlogged(): boolean
	setWaterlogged(arg0: boolean): void
}
declare interface WallSign extends Directional, Waterlogged {
}
namespace WorldLoadEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class MultipleCommandAlias extends Command {
	getCommands(): Command[]
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
}
declare interface Arrow extends AbstractArrow {
	setBasePotionData(arg0: PotionData): void
	getBasePotionData(): PotionData
	hasCustomEffects(): boolean
	getCustomEffects(): List
	addCustomEffect(arg0: PotionEffect, arg1: boolean): boolean
	removeCustomEffect(arg0: PotionEffectType): boolean
	hasCustomEffect(arg0: PotionEffectType): boolean
	clearCustomEffects(): void
	getColor(): Color
	setColor(arg0: Color): void
}
declare interface Illusioner extends Spellcaster {
}
namespace EntityDeathEvent {
	function getHandlerList(): HandlerList
	function getDroppedExp(): int
	function setDroppedExp(arg0: int): void
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function getDrops(): List
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class ExactMatchConversationCanceller implements ConversationCanceller {
	setConversation(arg0: Conversation): void
	cancelBasedOnInput(arg0: ConversationContext, arg1: String): boolean
	clone(): ConversationCanceller
	clone(): Object
}
declare interface WitherSkull extends Fireball {
	setCharged(arg0: boolean): void
	isCharged(): boolean
}
declare interface Dispenser extends Container, Nameable, Lootable {
	getBlockProjectileSource(): BlockProjectileSource
	dispense(): boolean
}
declare class Vine extends MaterialData {
	removeFromFace(arg0: BlockFace): void
	isOnFace(arg0: BlockFace): boolean
	putOnFace(arg0: BlockFace): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Vine
	clone(): Object
	clone(): MaterialData
}
declare interface Minecart extends Vehicle {
	getMaxSpeed(): double
	setMaxSpeed(arg0: double): void
	isSlowWhenEmpty(): boolean
	setSlowWhenEmpty(arg0: boolean): void
	getFlyingVelocityMod(): Vector
	setFlyingVelocityMod(arg0: Vector): void
	getDerailedVelocityMod(): Vector
	setDerailedVelocityMod(arg0: Vector): void
	setDisplayBlock(arg0: MaterialData): void
	getDisplayBlock(): MaterialData
	setDisplayBlockData(arg0: BlockData): void
	getDisplayBlockData(): BlockData
	setDisplayBlockOffset(arg0: int): void
	getDisplayBlockOffset(): int
	setDamage(arg0: double): void
	getDamage(): double
}
declare class ReloadCommand extends BukkitCommand {
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[]): List
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
}
declare interface Donkey extends ChestedHorse {
}
declare class StandardMessenger implements Messenger {
	isReservedChannel(arg0: String): boolean
	getOutgoingChannels(arg0: Plugin): Set
	getOutgoingChannels(): Set
	getIncomingChannels(arg0: Plugin): Set
	getIncomingChannels(): Set
	isRegistrationValid(arg0: PluginMessageListenerRegistration): boolean
	dispatchIncomingMessage(arg0: Player, arg1: String, arg2: byte[]): void
	addToOutgoing(arg0: Plugin, arg1: String): void
	removeFromOutgoing(arg0: Plugin): void
	removeFromOutgoing(arg0: Plugin, arg1: String): void
	addToIncoming(arg0: PluginMessageListenerRegistration): void
	removeFromIncoming(arg0: Plugin, arg1: String): void
	removeFromIncoming(arg0: Plugin): void
	removeFromIncoming(arg0: PluginMessageListenerRegistration): void
	validateAndCorrectChannel(arg0: String): String
	validateChannel(arg0: String): void
	validatePluginMessage(arg0: Messenger, arg1: Plugin, arg2: String, arg3: byte[]): void
	registerOutgoingPluginChannel(arg0: Plugin, arg1: String): void
	unregisterOutgoingPluginChannel(arg0: Plugin, arg1: String): void
	unregisterOutgoingPluginChannel(arg0: Plugin): void
	registerIncomingPluginChannel(arg0: Plugin, arg1: String, arg2: PluginMessageListener): PluginMessageListenerRegistration
	unregisterIncomingPluginChannel(arg0: Plugin, arg1: String, arg2: PluginMessageListener): void
	unregisterIncomingPluginChannel(arg0: Plugin): void
	unregisterIncomingPluginChannel(arg0: Plugin, arg1: String): void
	getIncomingChannelRegistrations(arg0: String): Set
	getIncomingChannelRegistrations(arg0: Plugin): Set
	getIncomingChannelRegistrations(arg0: Plugin, arg1: String): Set
	isIncomingChannelRegistered(arg0: Plugin, arg1: String): boolean
	isOutgoingChannelRegistered(arg0: Plugin, arg1: String): boolean
}
declare interface CreatureSpawner extends TileState {
	getSpawnedType(): EntityType
	setSpawnedType(arg0: EntityType): void
	setCreatureTypeByName(arg0: String): void
	getCreatureTypeName(): String
	getMinSpawnDelay(): int
	setMinSpawnDelay(arg0: int): void
	getMaxSpawnDelay(): int
	setMaxSpawnDelay(arg0: int): void
	getSpawnCount(): int
	setSpawnCount(arg0: int): void
	getMaxNearbyEntities(): int
	setMaxNearbyEntities(arg0: int): void
	getRequiredPlayerRange(): int
	setRequiredPlayerRange(arg0: int): void
	getSpawnRange(): int
	setSpawnRange(arg0: int): void
	setDelay(arg0: int): void
	getDelay(): int
}
namespace PlayerCommandSendEvent {
	function getHandlerList(): HandlerList
	function getCommands(): Collection
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockBreakEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function setDropItems(arg0: boolean): void
	function isDropItems(): boolean
	function getPlayer(): Player
	function getHandlerList(): HandlerList
	function getExpToDrop(): int
	function setExpToDrop(arg0: int): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Tree extends Wood {
	getDirection(): BlockFace
	setDirection(arg0: BlockFace): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Tree
	clone(): MaterialData
	clone(): Object
	clone(): Wood
}
namespace EntityPotionEffectEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getOldEffect(): PotionEffect
	function getNewEffect(): PotionEffect
	function getModifiedType(): PotionEffectType
	function setOverride(arg0: boolean): void
	function getAction(): Action
	function isOverride(): boolean
	function getCause(): Cause
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface CommandExecutor {
	onCommand(arg0: CommandSender, arg1: Command, arg2: String, arg3: String[]): boolean
}
declare class RayTraceResult {
	getHitBlock(): Block
	getHitBlockFace(): BlockFace
	getHitEntity(): Entity
	getHitPosition(): Vector
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
}
declare interface Chicken extends Animals {
}
namespace PlayerTeleportEvent {
	function getHandlerList(): HandlerList
	function getCause(): TeleportCause
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getFrom(): Location
	function setFrom(arg0: Location): void
	function getTo(): Location
	function setTo(arg0: Location): void
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockDispenseArmorEvent {
	function getTargetEntity(): LivingEntity
	function setVelocity(arg0: Vector): void
	function getVelocity(): Vector
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setItem(arg0: ItemStack): void
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerRecipeDiscoverEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRecipe(): NamespacedKey
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface EnderDragon extends ComplexLivingEntity, Boss {
	getDragonBattle(): DragonBattle
	getDeathAnimationTicks(): int
	getPhase(): Phase
	setPhase(arg0: Phase): void
}
declare class MapPalette {
	getDistance(arg0: Color, arg1: Color): double
	resizeImage(arg0: Image): BufferedImage
	imageToBytes(arg0: Image): byte[]
	getColor(arg0: byte): Color
	matchColor(arg0: int, arg1: int, arg2: int): byte
	matchColor(arg0: Color): byte
	c(arg0: int, arg1: int, arg2: int): Color
}
namespace RaidFinishEvent {
	function getHandlerList(): HandlerList
	function getWinners(): List
	function getHandlers(): HandlerList
	function getRaid(): Raid
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Tameable extends Animals {
	isTamed(): boolean
	setTamed(arg0: boolean): void
	getOwner(): AnimalTamer
	setOwner(arg0: AnimalTamer): void
}
declare interface GlowItemFrame extends ItemFrame {
}
declare interface EndPortalFrame extends Directional {
	hasEye(): boolean
	setEye(arg0: boolean): void
}
declare interface Bell extends Directional, Powerable {
	getAttachment(): Attachment
	setAttachment(arg0: Attachment): void
}
declare interface Dripleaf extends Directional, Waterlogged {
}
namespace PlayerStatisticIncrementEvent {
	function getEntityType(): EntityType
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getMaterial(): Material
	function getStatistic(): Statistic
	function getPreviousValue(): int
	function getNewValue(): int
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Event {
	getEventName(): String
	isAsynchronous(): boolean
	getHandlers(): HandlerList
}
namespace BlockFormEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getNewState(): BlockState
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface PluginAwareness {
}
declare interface BubbleColumn extends BlockData {
	isDrag(): boolean
	setDrag(arg0: boolean): void
}
declare class Spigot {
	sendMessage(arg0: UUID, arg1: BaseComponent): void
	sendMessage(arg0: UUID, arg1: BaseComponent[]): void
	sendMessage(arg0: BaseComponent): void
	sendMessage(arg0: BaseComponent[]): void
}
declare class PluginNameConversationPrefix implements ConversationPrefix {
	getPrefix(arg0: ConversationContext): String
}
declare interface Monster extends Creature {
}
declare interface EndGateway extends TileState {
	getExitLocation(): Location
	setExitLocation(arg0: Location): void
	isExactTeleport(): boolean
	setExactTeleport(arg0: boolean): void
	getAge(): long
	setAge(arg0: long): void
}
declare class PistonExtensionMaterial extends MaterialData implements Attachable {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	getFacing(): BlockFace
	isSticky(): boolean
	setSticky(arg0: boolean): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	clone(): MaterialData
	clone(): Object
	clone(): PistonExtensionMaterial
}
declare interface Directional {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
}
namespace CauldronLevelChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getNewState(): BlockState
	function getOldLevel(): int
	function getNewLevel(): int
	function setNewLevel(arg0: int): void
	function getEntity(): Entity
	function getReason(): ChangeReason
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityBreakDoorEvent {
	function getEntity(): LivingEntity
	function getEntity(): Entity
	function getBlockData(): BlockData
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlock(): Block
	function getTo(): Material
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface WanderingTrader extends AbstractVillager {
	getDespawnDelay(): int
	setDespawnDelay(arg0: int): void
}
declare interface Ageable extends Creature {
	setBaby(): void
	getAge(): int
	setAge(arg0: int): void
	setAgeLock(arg0: boolean): void
	getAgeLock(): boolean
	setAdult(): void
	isAdult(): boolean
	canBreed(): boolean
	setBreed(arg0: boolean): void
}
namespace LightningStrikeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLightning(): LightningStrike
	function getCause(): Cause
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockSpreadEvent {
	function getHandlerList(): HandlerList
	function getSource(): Block
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getNewState(): BlockState
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityEvent {
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Advancement extends Keyed {
	getCriteria(): Collection
}
namespace EntityResurrectEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class VersionCommand extends BukkitCommand {
	getDistance(arg0: String, arg1: String): int
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[]): List
	sendVersion(arg0: CommandSender): void
	describeToSender(arg0: Plugin, arg1: CommandSender): void
	getNameList(arg0: List): String
	obtainVersion(): void
	setVersionMessage(arg0: String): void
	access$0(arg0: VersionCommand): void
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
}
namespace LingeringPotionSplashEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getAreaEffectCloud(): AreaEffectCloud
	function getEntity(): Projectile
	function getEntity(): Entity
	function getEntity(): ThrownPotion
	function getHandlers(): HandlerList
	function getHitBlock(): Block
	function getHitBlockFace(): BlockFace
	function getHitEntity(): Entity
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Fox extends Animals, Sittable {
	isCrouching(): boolean
	setCrouching(arg0: boolean): void
	setSleeping(arg0: boolean): void
	getFirstTrustedPlayer(): AnimalTamer
	setFirstTrustedPlayer(arg0: AnimalTamer): void
	getSecondTrustedPlayer(): AnimalTamer
	setSecondTrustedPlayer(arg0: AnimalTamer): void
	getFoxType(): Type
	setFoxType(arg0: Type): void
}
namespace PlayerItemMendEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getExperienceOrb(): ExperienceOrb
	function getRepairAmount(): int
	function setRepairAmount(arg0: int): void
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerChatTabCompleteEvent {
	function getHandlerList(): HandlerList
	function getChatMessage(): String
	function getLastToken(): String
	function getTabCompletions(): Collection
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerQuitEvent {
	function getHandlerList(): HandlerList
	function getQuitMessage(): String
	function setQuitMessage(arg0: String): void
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Beehive extends Directional {
	getHoneyLevel(): int
	setHoneyLevel(arg0: int): void
	getMaximumHoneyLevel(): int
}
declare class NumberConversions {
	checkFinite(arg0: float, arg1: String): void
	checkFinite(arg0: double, arg1: String): void
	square(arg0: double): double
	toDouble(arg0: Object): double
	toFloat(arg0: Object): float
	toInt(arg0: Object): int
	toLong(arg0: Object): long
	toShort(arg0: Object): short
	toByte(arg0: Object): byte
	floor(arg0: double): int
	ceil(arg0: double): int
	isFinite(arg0: float): boolean
	isFinite(arg0: double): boolean
	round(arg0: double): int
}
declare interface Lectern extends TileState, BlockInventoryHolder {
	getSnapshotInventory(): Inventory
	getInventory(): Inventory
	getPage(): int
	setPage(arg0: int): void
}
declare interface ConversationCanceller extends Cloneable {
	setConversation(arg0: Conversation): void
	cancelBasedOnInput(arg0: ConversationContext, arg1: String): boolean
	clone(): Object
	clone(): ConversationCanceller
}
declare class BoundingBox implements Cloneable, ConfigurationSerializable {
	deserialize(arg0: Map): BoundingBox
	expandDirectional(arg0: Vector): BoundingBox
	expandDirectional(arg0: double, arg1: double, arg2: double): BoundingBox
	intersection(arg0: BoundingBox): BoundingBox
	serialize(): Map
	getHeight(): double
	getCenter(): Vector
	getCenterX(): double
	getCenterZ(): double
	rayTrace(arg0: Vector, arg1: Vector, arg2: double): RayTraceResult
	getVolume(): double
	getMinX(): double
	getMinY(): double
	getMinZ(): double
	getMin(): Vector
	getMaxX(): double
	getMaxY(): double
	getMaxZ(): double
	getMax(): Vector
	getWidthX(): double
	getWidthZ(): double
	getCenterY(): double
	overlaps(arg0: BoundingBox): boolean
	overlaps(arg0: Vector, arg1: Vector): boolean
	overlaps(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): boolean
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	clone(): BoundingBox
	clone(): Object
	of(arg0: Location, arg1: double, arg2: double, arg3: double): BoundingBox
	of(arg0: Vector, arg1: double, arg2: double, arg3: double): BoundingBox
	of(arg0: Block): BoundingBox
	of(arg0: Vector, arg1: Vector): BoundingBox
	of(arg0: Location, arg1: Location): BoundingBox
	of(arg0: Block, arg1: Block): BoundingBox
	contains(arg0: BoundingBox): boolean
	contains(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): boolean
	contains(arg0: Vector): boolean
	contains(arg0: double, arg1: double, arg2: double): boolean
	contains(arg0: Vector, arg1: Vector): boolean
	copy(arg0: BoundingBox): BoundingBox
	expand(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): BoundingBox
	expand(arg0: double): BoundingBox
	expand(arg0: Vector, arg1: double): BoundingBox
	expand(arg0: double, arg1: double, arg2: double, arg3: double): BoundingBox
	expand(arg0: BlockFace, arg1: double): BoundingBox
	expand(arg0: Vector): BoundingBox
	expand(arg0: double, arg1: double, arg2: double): BoundingBox
	shift(arg0: Location): BoundingBox
	shift(arg0: double, arg1: double, arg2: double): BoundingBox
	shift(arg0: Vector): BoundingBox
	resize(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): BoundingBox
	union(arg0: Vector): BoundingBox
	union(arg0: BoundingBox): BoundingBox
	union(arg0: Location): BoundingBox
	union(arg0: double, arg1: double, arg2: double): BoundingBox
}
namespace PortalCreateEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getBlocks(): List
	function getReason(): CreateReason
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace AreaEffectCloudApplyEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getAffectedEntities(): List
	function getEntity(): Entity
	function getEntity(): AreaEffectCloud
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface EnchantingTable extends TileState, Nameable {
}
namespace SheepDyeWoolEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Sheep
	function getEntity(): Entity
	function getColor(): DyeColor
	function getHandlers(): HandlerList
	function setColor(arg0: DyeColor): void
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface LingeringPotion extends ThrownPotion {
}
declare interface AbstractVillager extends Breedable, NPC, InventoryHolder, Merchant {
	getInventory(): Inventory
}
declare interface Destination {
}
namespace EntityEnterBlockEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlock(): Block
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace ServiceUnregisterEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getProvider(): RegisteredServiceProvider
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BukkitScheduler {
	scheduleSyncDelayedTask(arg0: Plugin, arg1: BukkitRunnable): int
	scheduleSyncDelayedTask(arg0: Plugin, arg1: Runnable): int
	scheduleSyncDelayedTask(arg0: Plugin, arg1: BukkitRunnable, arg2: long): int
	scheduleSyncDelayedTask(arg0: Plugin, arg1: Runnable, arg2: long): int
	scheduleSyncRepeatingTask(arg0: Plugin, arg1: BukkitRunnable, arg2: long, arg3: long): int
	scheduleSyncRepeatingTask(arg0: Plugin, arg1: Runnable, arg2: long, arg3: long): int
	scheduleAsyncDelayedTask(arg0: Plugin, arg1: Runnable): int
	scheduleAsyncDelayedTask(arg0: Plugin, arg1: Runnable, arg2: long): int
	scheduleAsyncRepeatingTask(arg0: Plugin, arg1: Runnable, arg2: long, arg3: long): int
	callSyncMethod(arg0: Plugin, arg1: Callable): Future
	cancelTasks(arg0: Plugin): void
	isCurrentlyRunning(arg0: int): boolean
	getActiveWorkers(): List
	getPendingTasks(): List
	runTaskAsynchronously(arg0: Plugin, arg1: BukkitRunnable): BukkitTask
	runTaskAsynchronously(arg0: Plugin, arg1: Runnable): BukkitTask
	runTaskAsynchronously(arg0: Plugin, arg1: Consumer): void
	runTaskLater(arg0: Plugin, arg1: Runnable, arg2: long): BukkitTask
	runTaskLater(arg0: Plugin, arg1: BukkitRunnable, arg2: long): BukkitTask
	runTaskLater(arg0: Plugin, arg1: Consumer, arg2: long): void
	runTaskLaterAsynchronously(arg0: Plugin, arg1: Consumer, arg2: long): void
	runTaskLaterAsynchronously(arg0: Plugin, arg1: Runnable, arg2: long): BukkitTask
	runTaskLaterAsynchronously(arg0: Plugin, arg1: BukkitRunnable, arg2: long): BukkitTask
	runTaskTimer(arg0: Plugin, arg1: BukkitRunnable, arg2: long, arg3: long): BukkitTask
	runTaskTimer(arg0: Plugin, arg1: Consumer, arg2: long, arg3: long): void
	runTaskTimer(arg0: Plugin, arg1: Runnable, arg2: long, arg3: long): BukkitTask
	runTaskTimerAsynchronously(arg0: Plugin, arg1: Consumer, arg2: long, arg3: long): void
	runTaskTimerAsynchronously(arg0: Plugin, arg1: Runnable, arg2: long, arg3: long): BukkitTask
	runTaskTimerAsynchronously(arg0: Plugin, arg1: BukkitRunnable, arg2: long, arg3: long): BukkitTask
	cancelTask(arg0: int): void
	runTask(arg0: Plugin, arg1: Consumer): void
	runTask(arg0: Plugin, arg1: Runnable): BukkitTask
	runTask(arg0: Plugin, arg1: BukkitRunnable): BukkitTask
	isQueued(arg0: int): boolean
}
declare interface DoubleChestInventory extends Inventory {
	getLeftSide(): Inventory
	getRightSide(): Inventory
	getHolder(): InventoryHolder
	getHolder(): DoubleChest
}
namespace ItemMergeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): Item
	function getTarget(): Item
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Criterias {
}
namespace EntityDamageByBlockEvent {
	function getDamager(): Block
	function isApplicable(arg0: DamageModifier): boolean
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getOriginalDamage(arg0: DamageModifier): double
	function getFinalDamage(): double
	function setDamage(arg0: double): void
	function setDamage(arg0: DamageModifier, arg1: double): void
	function getDamage(): double
	function getDamage(arg0: DamageModifier): double
	function getCause(): DamageCause
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface SkeletonHorse extends AbstractHorse {
}
namespace PlayerBucketEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getItemStack(): ItemStack
	function getBlockFace(): BlockFace
	function setItemStack(arg0: ItemStack): void
	function getBlockClicked(): Block
	function getBlock(): Block
	function getBucket(): Material
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class ChatPage {
	getPageNumber(): int
	getTotalPages(): int
	getLines(): String[]
}
declare class Lever extends SimpleAttachableMaterialData implements Redstone {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	isPowered(): boolean
	setPowered(arg0: boolean): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): SimpleAttachableMaterialData
	clone(): MaterialData
	clone(): Object
	clone(): Lever
}
declare interface ThrownPotion extends Projectile {
	setItem(arg0: ItemStack): void
	getEffects(): Collection
	getItem(): ItemStack
}
declare interface Zombie extends Monster, Ageable {
	getConversionTime(): int
	setConversionTime(arg0: int): void
	isConverting(): boolean
	setVillager(arg0: boolean): void
	setVillagerProfession(arg0: Profession): void
	getVillagerProfession(): Profession
	isBaby(): boolean
	setBaby(arg0: boolean): void
	isVillager(): boolean
}
declare interface PersistentDataHolder {
	getPersistentDataContainer(): PersistentDataContainer
}
declare interface Light extends Levelled, Waterlogged {
}
declare interface ConfigurationSerializable {
	serialize(): Map
}
declare interface Merchant {
	getRecipeCount(): int
	getRecipes(): List
	setRecipes(arg0: List): void
	setRecipe(arg0: int, arg1: MerchantRecipe): void
	isTrading(): boolean
	getTrader(): HumanEntity
	getRecipe(arg0: int): MerchantRecipe
}
declare interface Snowball extends ThrowableProjectile {
}
declare class SimplexOctaveGenerator extends OctaveGenerator {
	createOctaves(arg0: Random, arg1: int): NoiseGenerator[]
	noise(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): double
	noise(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): double
	setScale(arg0: double): void
	setWScale(arg0: double): void
	getWScale(): double
}
namespace EntityEnterLoveModeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHumanEntity(): HumanEntity
	function getTicksInLove(): int
	function setTicksInLove(arg0: int): void
	function getEntity(): Entity
	function getEntity(): Animals
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Utility extends Annotation {
}
declare interface Attachable extends BlockData {
	setAttached(arg0: boolean): void
	isAttached(): boolean
}
declare interface Hoglin extends Animals {
	isImmuneToZombification(): boolean
	setImmuneToZombification(arg0: boolean): void
	getConversionTime(): int
	setConversionTime(arg0: int): void
	isConverting(): boolean
	isAbleToBeHunted(): boolean
	setIsAbleToBeHunted(arg0: boolean): void
}
declare interface Boss extends Entity {
	getBossBar(): BossBar
}
declare interface AbstractHorse extends Vehicle, InventoryHolder, Tameable {
	getDomestication(): int
	setDomestication(arg0: int): void
	getMaxDomestication(): int
	setMaxDomestication(arg0: int): void
	getJumpStrength(): double
	setJumpStrength(arg0: double): void
	getInventory(): AbstractHorseInventory
	getInventory(): Inventory
	setVariant(arg0: Variant): void
	getVariant(): Variant
}
namespace PlayerKickEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLeaveMessage(): String
	function setLeaveMessage(arg0: String): void
	function setReason(arg0: String): void
	function getReason(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Rail extends Waterlogged {
	getShape(): Shape
	setShape(arg0: Shape): void
	getShapes(): Set
}
namespace PlayerAdvancementDoneEvent {
	function getHandlerList(): HandlerList
	function getAdvancement(): Advancement
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace ThunderChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function toThunderState(): boolean
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Damageable extends Entity {
	setAbsorptionAmount(arg0: double): void
	resetMaxHealth(): void
	getAbsorptionAmount(): double
	setMaxHealth(arg0: double): void
	getMaxHealth(): double
	damage(arg0: double): void
	damage(arg0: double, arg1: Entity): void
	getHealth(): double
	setHealth(arg0: double): void
}
namespace EntityTargetLivingEntityEvent {
	function getTarget(): Entity
	function getTarget(): LivingEntity
	function setTarget(arg0: Entity): void
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getReason(): TargetReason
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class DirectionalContainer extends MaterialData implements Directional {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): DirectionalContainer
	clone(): Object
	clone(): MaterialData
}
declare interface Item extends Entity {
	getItemStack(): ItemStack
	setItemStack(arg0: ItemStack): void
	getPickupDelay(): int
	setPickupDelay(arg0: int): void
	setThrower(arg0: UUID): void
	getThrower(): UUID
	getOwner(): UUID
	setOwner(arg0: UUID): void
}
declare interface AnimalTamer {
	getUniqueId(): UUID
	getName(): String
}
declare class MemoryConfiguration extends MemorySection implements Configuration {
	getDefaults(): Configuration
	addDefaults(arg0: Configuration): void
	addDefaults(arg0: Map): void
	setDefaults(arg0: Configuration): void
	addDefault(arg0: String, arg1: Object): void
	getParent(): ConfigurationSection
	options(): ConfigurationOptions
	options(): MemoryConfigurationOptions
}
declare interface Structure extends TileState {
	setRotation(arg0: StructureRotation): void
	getRotation(): StructureRotation
	setMetadata(arg0: String): void
	getMetadata(): String
	getStructureName(): String
	setStructureName(arg0: String): void
	getRelativePosition(): BlockVector
	setRelativePosition(arg0: BlockVector): void
	getStructureSize(): BlockVector
	setStructureSize(arg0: BlockVector): void
	setUsageMode(arg0: UsageMode): void
	getUsageMode(): UsageMode
	setIgnoreEntities(arg0: boolean): void
	isIgnoreEntities(): boolean
	setBoundingBoxVisible(arg0: boolean): void
	isBoundingBoxVisible(): boolean
	setIntegrity(arg0: float): void
	getIntegrity(): float
	getSeed(): long
	setSeed(arg0: long): void
	getAuthor(): String
	setAuthor(arg0: LivingEntity): void
	setAuthor(arg0: String): void
	setMirror(arg0: Mirror): void
	getMirror(): Mirror
	setShowAir(arg0: boolean): void
	isShowAir(): boolean
}
namespace PlayerAnimationEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getAnimationType(): PlayerAnimationType
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class SimpleAttachableMaterialData extends MaterialData implements Attachable {
	getFacing(): BlockFace
	toString(): String
	clone(): SimpleAttachableMaterialData
	clone(): MaterialData
	clone(): Object
}
namespace ItemDespawnEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): Item
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntitySpellCastEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): Spellcaster
	function getSpell(): Spell
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace HangingBreakEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getCause(): RemoveCause
	function getHandlers(): HandlerList
	function getEntity(): Hanging
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PotionEffectTypeWrapper extends PotionEffectType {
	getDurationModifier(): double
	getColor(): Color
	isInstant(): boolean
	getName(): String
	getType(): PotionEffectType
}
declare interface Openable {
	setOpen(arg0: boolean): void
	isOpen(): boolean
}
declare class Color implements ConfigurationSerializable {
	deserialize(arg0: Map): Color
	serialize(): Map
	asInt(arg0: String, arg1: Map): int
	getRed(): int
	getGreen(): int
	getBlue(): int
	fromRGB(arg0: int, arg1: int, arg2: int): Color
	fromRGB(arg0: int): Color
	fromBGR(arg0: int, arg1: int, arg2: int): Color
	fromBGR(arg0: int): Color
	setRed(arg0: int): Color
	setGreen(arg0: int): Color
	setBlue(arg0: int): Color
	asRGB(): int
	asBGR(): int
	mixDyes(arg0: DyeColor[]): Color
	mixColors(arg0: Color[]): Color
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
}
declare interface AbstractArrow extends Projectile {
	getKnockbackStrength(): int
	setKnockbackStrength(arg0: int): void
	getPierceLevel(): int
	setPierceLevel(arg0: int): void
	setCritical(arg0: boolean): void
	getAttachedBlock(): Block
	getPickupStatus(): PickupStatus
	setPickupStatus(arg0: PickupStatus): void
	isShotFromCrossbow(): boolean
	setShotFromCrossbow(arg0: boolean): void
	setDamage(arg0: double): void
	getDamage(): double
	isCritical(): boolean
	isInBlock(): boolean
}
namespace ServiceRegisterEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getProvider(): RegisteredServiceProvider
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Vindicator extends Illager {
}
declare interface ComplexRecipe extends Recipe, Keyed {
}
namespace HorseJumpEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): AbstractHorse
	function getEntity(): Entity
	function getPower(): float
	function setPower(arg0: float): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace ServerLoadEvent {
	function getHandlerList(): HandlerList
	function getType(): LoadType
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Dye extends MaterialData implements Colorable {
	getColor(): DyeColor
	toString(): String
	clone(): Dye
	clone(): MaterialData
	clone(): Object
	setColor(arg0: DyeColor): void
}
namespace BlockPistonEvent {
	function getDirection(): BlockFace
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function isSticky(): boolean
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockExpEvent {
	function getHandlerList(): HandlerList
	function getExpToDrop(): int
	function setExpToDrop(arg0: int): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerTakeLecternBookEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLectern(): Lectern
	function getBook(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PotionData {
	isExtended(): boolean
	isUpgraded(): boolean
	equals(arg0: Object): boolean
	hashCode(): int
	getType(): PotionType
}
declare interface Farmland extends BlockData {
	getMoisture(): int
	setMoisture(arg0: int): void
	getMaximumMoisture(): int
}
declare class RegisteredListener {
	isIgnoringCancelled(): boolean
	getListener(): Listener
	getPlugin(): Plugin
	callEvent(arg0: Event): void
	getPriority(): EventPriority
}
declare class Permission {
	recalculatePermissibles(): void
	getDescription(): String
	setDescription(arg0: String): void
	getChildren(): Map
	getPermissibles(): Set
	loadPermission(arg0: String, arg1: Map, arg2: PermissionDefault, arg3: List): Permission
	loadPermission(arg0: String, arg1: Map): Permission
	extractChildren(arg0: Map, arg1: String, arg2: PermissionDefault, arg3: List): Map
	loadPermissions(arg0: Map, arg1: String, arg2: PermissionDefault): List
	addParent(arg0: String, arg1: boolean): Permission
	addParent(arg0: Permission, arg1: boolean): void
	getName(): String
	getDefault(): PermissionDefault
	setDefault(arg0: PermissionDefault): void
}
declare interface ThrowableProjectile extends Projectile {
	setItem(arg0: ItemStack): void
	getItem(): ItemStack
}
declare interface Sign extends Rotatable, Waterlogged {
}
declare interface Container extends TileState, BlockInventoryHolder, Lockable, Nameable {
	getSnapshotInventory(): Inventory
	getInventory(): Inventory
}
declare class Dispenser extends FurnaceAndDispenser {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	clone(): MaterialData
	clone(): DirectionalContainer
	clone(): Dispenser
	clone(): Object
	clone(): FurnaceAndDispenser
}
declare interface Grindstone extends Directional, FaceAttachable {
}
declare interface Witch extends Raider {
}
namespace BlockDispenseEvent {
	function setVelocity(arg0: Vector): void
	function getVelocity(): Vector
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setItem(arg0: ItemStack): void
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Observer extends Directional, Powerable {
}
declare interface Tripwire extends Attachable, MultipleFacing, Powerable {
	setDisarmed(arg0: boolean): void
	isDisarmed(): boolean
}
declare class Button extends SimpleAttachableMaterialData implements Redstone {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	isPowered(): boolean
	setPowered(arg0: boolean): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): SimpleAttachableMaterialData
	clone(): MaterialData
	clone(): Object
	clone(): Button
}
declare interface Colorable {
	getColor(): DyeColor
	setColor(arg0: DyeColor): void
}
declare class DustOptions {
	getColor(): Color
	getSize(): float
}
declare class BlockIterator implements Iterator {
	getXPosition(arg0: Vector, arg1: Vector, arg2: Block): double
	getYPosition(arg0: Vector, arg1: Vector, arg2: Block): double
	getZPosition(arg0: Vector, arg1: Vector, arg2: Block): double
	blockEquals(arg0: Block, arg1: Block): boolean
	getPosition(arg0: double, arg1: double, arg2: int): double
	getXLength(arg0: Vector): double
	getXFace(arg0: Vector): BlockFace
	getYFace(arg0: Vector): BlockFace
	getYLength(arg0: Vector): double
	getZFace(arg0: Vector): BlockFace
	getZLength(arg0: Vector): double
	remove(): void
	hasNext(): boolean
	next(): Object
	next(): Block
	scan(): void
}
namespace AsyncPlayerPreLoginEvent {
	function getUniqueId(): UUID
	function getHandlerList(): HandlerList
	function getLoginResult(): Result
	function setLoginResult(arg0: Result): void
	function getKickMessage(): String
	function setKickMessage(arg0: String): void
	function getName(): String
	function disallow(arg0: Result, arg1: String): void
	function disallow(arg0: Result, arg1: String): void
	function allow(): void
	function getAddress(): InetAddress
	function setResult(arg0: Result): void
	function getHandlers(): HandlerList
	function getResult(): Result
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockPistonRetractEvent {
	function getHandlerList(): HandlerList
	function getRetractLocation(): Location
	function getBlocks(): List
	function getHandlers(): HandlerList
	function getDirection(): BlockFace
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function isSticky(): boolean
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface StorageMinecart extends Minecart, InventoryHolder, Lootable {
}
namespace EntityCreatePortalEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getPortalType(): PortalType
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function getBlocks(): List
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface PersistentDataContainer {
	getAdapterContext(): PersistentDataAdapterContext
	remove(arg0: NamespacedKey): void
	get(arg0: NamespacedKey, arg1: PersistentDataType): Object
	isEmpty(): boolean
	set(arg0: NamespacedKey, arg1: PersistentDataType, arg2: Object): void
	getOrDefault(arg0: NamespacedKey, arg1: PersistentDataType, arg2: Object): Object
	getKeys(): Set
	has(arg0: NamespacedKey, arg1: PersistentDataType): boolean
}
declare interface Ghast extends Flying {
}
declare class StringUtil {
	startsWithIgnoreCase(arg0: String, arg1: String): boolean
	copyPartialMatches(arg0: String, arg1: Iterable, arg2: Collection): Collection
}
declare interface DelegateDeserialization extends Annotation {
	value(): Class
}
declare interface Campfire extends TileState {
	getCookTime(arg0: int): int
	setCookTime(arg0: int, arg1: int): void
	getCookTimeTotal(arg0: int): int
	setCookTimeTotal(arg0: int, arg1: int): void
	setItem(arg0: int, arg1: ItemStack): void
	getSize(): int
	getItem(arg0: int): ItemStack
}
namespace ProjectileLaunchEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getEntity(): Projectile
	function getEntity(): Entity
	function getHandlerList(): HandlerList
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Conversable {
	sendRawMessage(arg0: UUID, arg1: String): void
	sendRawMessage(arg0: String): void
	isConversing(): boolean
	acceptConversationInput(arg0: String): void
	beginConversation(arg0: Conversation): boolean
	abandonConversation(arg0: Conversation, arg1: ConversationAbandonedEvent): void
	abandonConversation(arg0: Conversation): void
}
declare interface LeatherArmorMeta extends ItemMeta {
	getColor(): Color
	clone(): Object
	clone(): ItemMeta
	clone(): LeatherArmorMeta
	setColor(arg0: Color): void
}
namespace BlockMultiPlaceEvent {
	function getReplacedBlockStates(): List
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlockPlaced(): Block
	function getBlockReplacedState(): BlockState
	function getBlockAgainst(): Block
	function getItemInHand(): ItemStack
	function getPlayer(): Player
	function getHand(): EquipmentSlot
	function canBuild(): boolean
	function setBuild(arg0: boolean): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PotionEffectType {
	registerPotionEffectType(arg0: PotionEffectType): void
	stopAcceptingRegistrations(): void
	createEffect(arg0: int, arg1: int): PotionEffect
	getDurationModifier(): double
	getColor(): Color
	isInstant(): boolean
	getById(arg0: int): PotionEffectType
	getName(): String
	equals(arg0: Object): boolean
	toString(): String
	values(): PotionEffectType[]
	hashCode(): int
	getId(): int
	getByName(arg0: String): PotionEffectType
}
declare interface Painting extends Hanging {
	getArt(): Art
	setArt(arg0: Art): boolean
	setArt(arg0: Art, arg1: boolean): boolean
}
namespace PlayerChangedMainHandEvent {
	function getHandlerList(): HandlerList
	function getMainHand(): MainHand
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface AbstractHorseInventory extends Inventory {
	setSaddle(arg0: ItemStack): void
	getSaddle(): ItemStack
}
declare interface ItemTagType {
	getPrimitiveType(): Class
	getComplexType(): Class
	toPrimitive(arg0: Object, arg1: ItemTagAdapterContext): Object
	fromPrimitive(arg0: Object, arg1: ItemTagAdapterContext): Object
}
declare interface Dispenser extends Directional {
	isTriggered(): boolean
	setTriggered(arg0: boolean): void
}
declare interface Powerable extends BlockData {
	isPowered(): boolean
	setPowered(arg0: boolean): void
}
declare class HelpTopic {
	getShortText(): String
	amendCanSee(arg0: String): void
	applyAmendment(arg0: String, arg1: String): String
	getFullText(arg0: CommandSender): String
	canSee(arg0: CommandSender): boolean
	amendTopic(arg0: String, arg1: String): void
	getName(): String
}
declare interface Strider extends Steerable, Vehicle {
	setShivering(arg0: boolean): void
	isShivering(): boolean
}
namespace PlayerRegisterChannelEvent {
	function getHandlerList(): HandlerList
	function getChannel(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Endermite extends Monster {
	isPlayerSpawned(): boolean
	setPlayerSpawned(arg0: boolean): void
}
declare class Cake extends MaterialData {
	getSlicesEaten(): int
	getSlicesRemaining(): int
	setSlicesEaten(arg0: int): void
	setSlicesRemaining(arg0: int): void
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): Cake
}
declare class MemoryConfigurationOptions extends ConfigurationOptions {
	copyDefaults(arg0: boolean): ConfigurationOptions
	copyDefaults(arg0: boolean): MemoryConfigurationOptions
	configuration(): MemoryConfiguration
	configuration(): Configuration
	pathSeparator(arg0: char): ConfigurationOptions
	pathSeparator(arg0: char): MemoryConfigurationOptions
}
namespace PlayerInteractEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getMaterial(): Material
	function useItemInHand(): Result
	function useInteractedBlock(): Result
	function setUseInteractedBlock(arg0: Result): void
	function setUseItemInHand(arg0: Result): void
	function isBlockInHand(): boolean
	function getClickedBlock(): Block
	function getBlockFace(): BlockFace
	function getAction(): Action
	function getHand(): EquipmentSlot
	function hasItem(): boolean
	function hasBlock(): boolean
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace RaidSpawnWaveEvent {
	function getHandlerList(): HandlerList
	function getPatrolLeader(): Raider
	function getRaiders(): List
	function getHandlers(): HandlerList
	function getRaid(): Raid
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PotionSplashEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getIntensity(arg0: LivingEntity): double
	function setIntensity(arg0: LivingEntity, arg1: double): void
	function getAffectedEntities(): Collection
	function getEntity(): Projectile
	function getEntity(): ThrownPotion
	function getEntity(): Entity
	function getPotion(): ThrownPotion
	function getHandlers(): HandlerList
	function getHitBlock(): Block
	function getHitBlockFace(): BlockFace
	function getHitEntity(): Entity
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface LootTable extends Keyed {
	populateLoot(arg0: Random, arg1: LootContext): Collection
	fillInventory(arg0: Inventory, arg1: Random, arg2: LootContext): void
}
namespace BlockCookEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setResult(arg0: ItemStack): void
	function getSource(): ItemStack
	function getHandlers(): HandlerList
	function getResult(): ItemStack
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Fire extends Ageable, MultipleFacing {
}
declare class Vector implements Cloneable, ConfigurationSerializable {
	lengthSquared(): double
	distanceSquared(arg0: Vector): double
	checkFinite(): void
	deserialize(arg0: Map): Vector
	getMidpoint(arg0: Vector): Vector
	crossProduct(arg0: Vector): Vector
	getCrossProduct(arg0: Vector): Vector
	normalizeZeros(): Vector
	rotateAroundX(arg0: double): Vector
	rotateAroundY(arg0: double): Vector
	rotateAroundZ(arg0: double): Vector
	rotateAroundAxis(arg0: Vector, arg1: double): Vector
	rotateAroundNonUnitAxis(arg0: Vector, arg1: double): Vector
	toBlockVector(): BlockVector
	setX(arg0: float): Vector
	setX(arg0: double): Vector
	setX(arg0: int): Vector
	getBlockX(): int
	setY(arg0: float): Vector
	setY(arg0: int): Vector
	setY(arg0: double): Vector
	getBlockY(): int
	setZ(arg0: int): Vector
	setZ(arg0: float): Vector
	setZ(arg0: double): Vector
	getBlockZ(): int
	subtract(arg0: Vector): Vector
	serialize(): Map
	getX(): double
	getY(): double
	getZ(): double
	divide(arg0: Vector): Vector
	angle(arg0: Vector): float
	midpoint(arg0: Vector): Vector
	isInAABB(arg0: Vector, arg1: Vector): boolean
	isInSphere(arg0: Vector, arg1: double): boolean
	getEpsilon(): double
	toLocation(arg0: World): Location
	toLocation(arg0: World, arg1: float, arg2: float): Location
	getMinimum(arg0: Vector, arg1: Vector): Vector
	getMaximum(arg0: Vector, arg1: Vector): Vector
	getRandom(): Vector
	add(arg0: Vector): Vector
	equals(arg0: Object): boolean
	length(): double
	toString(): String
	hashCode(): int
	clone(): Object
	clone(): Vector
	dot(arg0: Vector): double
	copy(arg0: Vector): Vector
	normalize(): Vector
	zero(): Vector
	distance(arg0: Vector): double
	multiply(arg0: float): Vector
	multiply(arg0: Vector): Vector
	multiply(arg0: double): Vector
	multiply(arg0: int): Vector
	isNormalized(): boolean
}
namespace SpawnChangeEvent {
	function getHandlerList(): HandlerList
	function getPreviousLocation(): Location
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BlockCommandSender extends CommandSender {
	getBlock(): Block
}
declare interface ArmorStand extends LivingEntity {
	getLeggings(): ItemStack
	setChestplate(arg0: ItemStack): void
	setLeggings(arg0: ItemStack): void
	getChestplate(): ItemStack
	getBodyPose(): EulerAngle
	setBodyPose(arg0: EulerAngle): void
	getLeftArmPose(): EulerAngle
	setLeftArmPose(arg0: EulerAngle): void
	getRightArmPose(): EulerAngle
	setRightArmPose(arg0: EulerAngle): void
	getLeftLegPose(): EulerAngle
	setLeftLegPose(arg0: EulerAngle): void
	getRightLegPose(): EulerAngle
	setRightLegPose(arg0: EulerAngle): void
	getHeadPose(): EulerAngle
	setHeadPose(arg0: EulerAngle): void
	hasBasePlate(): boolean
	setBasePlate(arg0: boolean): void
	addEquipmentLock(arg0: EquipmentSlot, arg1: LockType): void
	removeEquipmentLock(arg0: EquipmentSlot, arg1: LockType): void
	hasEquipmentLock(arg0: EquipmentSlot, arg1: LockType): boolean
	getItemInHand(): ItemStack
	setItemInHand(arg0: ItemStack): void
	setVisible(arg0: boolean): void
	isVisible(): boolean
	getHelmet(): ItemStack
	setHelmet(arg0: ItemStack): void
	getBoots(): ItemStack
	setBoots(arg0: ItemStack): void
	hasArms(): boolean
	setArms(arg0: boolean): void
	isSmall(): boolean
	setSmall(arg0: boolean): void
	isMarker(): boolean
	setMarker(arg0: boolean): void
}
declare class Cauldron extends MaterialData {
	isFull(): boolean
	toString(): String
	clone(): MaterialData
	clone(): Cauldron
	clone(): Object
	isEmpty(): boolean
}
namespace EntityPortalEnterEvent {
	function getHandlerList(): HandlerList
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BrewingStandFuelEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getFuelPower(): int
	function setFuelPower(arg0: int): void
	function isConsuming(): boolean
	function setConsuming(arg0: boolean): void
	function getFuel(): ItemStack
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class HelpTopicComparator implements Comparator {
	topicNameComparatorInstance(): TopicNameComparator
	helpTopicComparatorInstance(): HelpTopicComparator
	compare(arg0: HelpTopic, arg1: HelpTopic): int
	compare(arg0: Object, arg1: Object): int
}
declare interface Raider extends Monster {
	getPatrolTarget(): Block
	setPatrolTarget(arg0: Block): void
	isPatrolLeader(): boolean
	setPatrolLeader(arg0: boolean): void
	isCanJoinRaid(): boolean
	setCanJoinRaid(arg0: boolean): void
}
declare class Torch extends SimpleAttachableMaterialData {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	clone(): MaterialData
	clone(): Torch
	clone(): Object
	clone(): SimpleAttachableMaterialData
}
declare interface AbstractSkeleton extends Monster {
	getSkeletonType(): SkeletonType
	setSkeletonType(arg0: SkeletonType): void
}
declare interface HelpMap {
	getHelpTopic(arg0: String): HelpTopic
	getHelpTopics(): Collection
	registerHelpTopicFactory(arg0: Class, arg1: HelpTopicFactory): void
	getIgnoredPlugins(): List
	addTopic(arg0: HelpTopic): void
	clear(): void
}
declare interface Jukebox extends TileState {
	stopPlaying(): void
	eject(): boolean
	getPlaying(): Material
	setPlaying(arg0: Material): void
	getRecord(): ItemStack
	setRecord(arg0: ItemStack): void
	isPlaying(): boolean
}
namespace PlayerBedEnterEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBedEnterResult(): BedEnterResult
	function getBed(): Block
	function useBed(): Result
	function setUseBed(arg0: Result): void
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Art extends Enum implements Keyed {
	getBlockWidth(): int
	getBlockHeight(): int
	getById(arg0: int): Art
	values(): Art[]
	valueOf(arg0: String): Art
	getKey(): NamespacedKey
	getId(): int
	getByName(arg0: String): Art
}
declare class Biome extends Enum implements Keyed {
	values(): Biome[]
	valueOf(arg0: String): Biome
	getKey(): NamespacedKey
}
declare interface AreaEffectCloud extends Entity {
	setBasePotionData(arg0: PotionData): void
	getBasePotionData(): PotionData
	hasCustomEffects(): boolean
	getCustomEffects(): List
	addCustomEffect(arg0: PotionEffect, arg1: boolean): boolean
	removeCustomEffect(arg0: PotionEffectType): boolean
	hasCustomEffect(arg0: PotionEffectType): boolean
	clearCustomEffects(): void
	getDuration(): int
	setDuration(arg0: int): void
	getWaitTime(): int
	setWaitTime(arg0: int): void
	getReapplicationDelay(): int
	setReapplicationDelay(arg0: int): void
	getDurationOnUse(): int
	setDurationOnUse(arg0: int): void
	getRadiusOnUse(): float
	setRadiusOnUse(arg0: float): void
	getRadiusPerTick(): float
	setRadiusPerTick(arg0: float): void
	getParticle(): Particle
	setParticle(arg0: Particle, arg1: Object): void
	setParticle(arg0: Particle): void
	getColor(): Color
	getRadius(): float
	setRadius(arg0: float): void
	setSource(arg0: ProjectileSource): void
	getSource(): ProjectileSource
	setColor(arg0: Color): void
}
declare interface WaterMob extends Creature {
}
declare class RemoveAttachmentRunnable implements Runnable {
	run(): void
}
namespace WeatherEvent {
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Campfire extends Directional, Lightable, Waterlogged {
	isSignalFire(): boolean
	setSignalFire(arg0: boolean): void
}
declare interface Breedable extends Ageable {
	setAgeLock(arg0: boolean): void
	getAgeLock(): boolean
	canBreed(): boolean
	setBreed(arg0: boolean): void
}
declare interface AdvancementProgress {
	awardCriteria(arg0: String): boolean
	revokeCriteria(arg0: String): boolean
	getDateAwarded(arg0: String): Date
	getRemainingCriteria(): Collection
	getAwardedCriteria(): Collection
	getAdvancement(): Advancement
	isDone(): boolean
}
declare class SpawnEgg extends MaterialData {
	getSpawnedType(): EntityType
	setSpawnedType(arg0: EntityType): void
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): SpawnEgg
}
declare interface TurtleEgg extends BlockData {
	getMinimumEggs(): int
	getMaximumEggs(): int
	getMaximumHatch(): int
	getEggs(): int
	setEggs(arg0: int): void
	getHatch(): int
	setHatch(arg0: int): void
}
declare interface Squid extends WaterMob {
}
namespace InventoryClickEvent {
	function getHandlerList(): HandlerList
	function getSlotType(): SlotType
	function getCurrentItem(): ItemStack
	function isRightClick(): boolean
	function isLeftClick(): boolean
	function isShiftClick(): boolean
	function setCurrentItem(arg0: ItemStack): void
	function getClickedInventory(): Inventory
	function getHotbarButton(): int
	function getCursor(): ItemStack
	function setCursor(arg0: ItemStack): void
	function getRawSlot(): int
	function getAction(): InventoryAction
	function getClick(): ClickType
	function getSlot(): int
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getWhoClicked(): HumanEntity
	function setResult(arg0: Result): void
	function getResult(): Result
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Sound extends Enum implements Keyed {
	values(): Sound[]
	valueOf(arg0: String): Sound
	getKey(): NamespacedKey
}
declare interface Guardian extends Monster {
	isElder(): boolean
	setElder(arg0: boolean): void
}
declare class DetectorRail extends ExtendedRails implements PressureSensor {
	isPressed(): boolean
	setPressed(arg0: boolean): void
	clone(): MaterialData
	clone(): Object
	clone(): Rails
	clone(): ExtendedRails
	clone(): DetectorRail
}
declare interface BukkitWorker {
	getTaskId(): int
	getThread(): Thread
	getOwner(): Plugin
}
namespace PlayerGameModeChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getNewGameMode(): GameMode
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Spigot {
	getConfig(): YamlConfiguration
	restart(): void
	broadcast(arg0: BaseComponent[]): void
	broadcast(arg0: BaseComponent): void
}
declare class BooleanPrompt extends ValidatingPrompt {
	isInputValid(arg0: ConversationContext, arg1: String): boolean
	acceptValidatedInput(arg0: ConversationContext, arg1: boolean): Prompt
	acceptValidatedInput(arg0: ConversationContext, arg1: String): Prompt
}
namespace PlayerItemConsumeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setItem(arg0: ItemStack): void
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface TropicalFish extends Fish {
	getPatternColor(): DyeColor
	setPatternColor(arg0: DyeColor): void
	getBodyColor(): DyeColor
	setBodyColor(arg0: DyeColor): void
	getPattern(): Pattern
	setPattern(arg0: Pattern): void
}
declare class PermissibleBase implements Permissible {
	recalculatePermissions(): void
	isPermissionSet(arg0: Permission): boolean
	isPermissionSet(arg0: String): boolean
	addAttachment(arg0: Plugin, arg1: String, arg2: boolean): PermissionAttachment
	addAttachment(arg0: Plugin): PermissionAttachment
	addAttachment(arg0: Plugin, arg1: String, arg2: boolean, arg3: int): PermissionAttachment
	addAttachment(arg0: Plugin, arg1: int): PermissionAttachment
	hasPermission(arg0: Permission): boolean
	hasPermission(arg0: String): boolean
	getEffectivePermissions(): Set
	removeAttachment(arg0: PermissionAttachment): void
	clearPermissions(): void
	calculateChildPermissions(arg0: Map, arg1: boolean, arg2: PermissionAttachment): void
	isOp(): boolean
	setOp(arg0: boolean): void
}
namespace EntityTargetEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getTarget(): Entity
	function setTarget(arg0: Entity): void
	function getReason(): TargetReason
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityInteractEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlock(): Block
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BlockFadeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getNewState(): BlockState
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace VillagerAcquireTradeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setRecipe(arg0: MerchantRecipe): void
	function getEntity(): AbstractVillager
	function getEntity(): Entity
	function getRecipe(): MerchantRecipe
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface NoteBlock extends Powerable {
	getInstrument(): Instrument
	setInstrument(arg0: Instrument): void
	getNote(): Note
	setNote(arg0: Note): void
}
namespace PlayerCommandPreprocessEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRecipients(): Set
	function setMessage(arg0: String): void
	function setPlayer(arg0: Player): void
	function getMessage(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class MerchantRecipe implements Recipe {
	getVillagerExperience(): int
	setVillagerExperience(arg0: int): void
	addIngredient(arg0: ItemStack): void
	removeIngredient(arg0: int): void
	setIngredients(arg0: List): void
	getIngredients(): List
	hasExperienceReward(): boolean
	setExperienceReward(arg0: boolean): void
	getPriceMultiplier(): float
	setPriceMultiplier(arg0: float): void
	getUses(): int
	setUses(arg0: int): void
	getMaxUses(): int
	setMaxUses(arg0: int): void
	getResult(): ItemStack
}
declare class Spigot {
	getPages(): List
	setPages(arg0: List): void
	setPages(arg0: BaseComponent[][]): void
	addPage(arg0: BaseComponent[][]): void
	getPage(arg0: int): BaseComponent[]
	setPage(arg0: int, arg1: BaseComponent[]): void
}
declare interface Listener {
}
declare interface ChunkData {
	getBlockData(arg0: int, arg1: int, arg2: int): BlockData
	getMaxHeight(): int
	getMinHeight(): int
	getTypeAndData(arg0: int, arg1: int, arg2: int): MaterialData
	getData(arg0: int, arg1: int, arg2: int): byte
	setBlock(arg0: int, arg1: int, arg2: int, arg3: MaterialData): void
	setBlock(arg0: int, arg1: int, arg2: int, arg3: BlockData): void
	setBlock(arg0: int, arg1: int, arg2: int, arg3: Material): void
	setRegion(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: MaterialData): void
	setRegion(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: BlockData): void
	setRegion(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: Material): void
	getType(arg0: int, arg1: int, arg2: int): Material
}
declare interface Snowable extends BlockData {
	setSnowy(arg0: boolean): void
	isSnowy(): boolean
}
namespace PlayerEditBookEvent {
	function getPreviousBookMeta(): BookMeta
	function getNewBookMeta(): BookMeta
	function setNewBookMeta(arg0: BookMeta): void
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isSigning(): boolean
	function setSigning(arg0: boolean): void
	function getSlot(): int
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace BroadcastMessageEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRecipients(): Set
	function setMessage(arg0: String): void
	function getMessage(): String
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface ExperienceOrb extends Entity {
	setExperience(arg0: int): void
	getExperience(): int
}
declare class Note {
	getToneByte(): byte
	sharped(): Note
	flat(arg0: int, arg1: Tone): Note
	sharp(arg0: int, arg1: Tone): Note
	natural(arg0: int, arg1: Tone): Note
	flattened(): Note
	getOctave(): int
	getTone(): Tone
	isSharped(): boolean
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	getId(): byte
}
declare class Comparator extends MaterialData implements Directional, Redstone {
	setFacingDirection(arg0: BlockFace): void
	setSubtractionMode(arg0: boolean): void
	isSubtractionMode(): boolean
	isBeingPowered(): boolean
	getFacing(): BlockFace
	isPowered(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Comparator
	clone(): MaterialData
}
namespace VehicleBlockCollisionEvent {
	function getHandlerList(): HandlerList
	function getBlock(): Block
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface RedstoneRail extends Powerable, Rail {
}
namespace VillagerReplenishTradeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function setRecipe(arg0: MerchantRecipe): void
	function getBonus(): int
	function setBonus(arg0: int): void
	function getEntity(): AbstractVillager
	function getEntity(): Entity
	function getRecipe(): MerchantRecipe
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface SculkSensor extends AnaloguePowerable, Waterlogged {
	getPhase(): Phase
	setPhase(arg0: Phase): void
}
namespace BlockPistonExtendEvent {
	function getHandlerList(): HandlerList
	function getBlocks(): List
	function getLength(): int
	function getHandlers(): HandlerList
	function getDirection(): BlockFace
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function isSticky(): boolean
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface DragonBattle {
	resetCrystals(): void
	getEnderDragon(): EnderDragon
	getEndPortalLocation(): Location
	generateEndPortal(arg0: boolean): boolean
	hasBeenPreviouslyKilled(): boolean
	initiateRespawn(): void
	getRespawnPhase(): RespawnPhase
	setRespawnPhase(arg0: RespawnPhase): boolean
	getBossBar(): BossBar
}
declare interface CraftingInventory extends Inventory {
	getMatrix(): ItemStack[]
	setMatrix(arg0: ItemStack[]): void
	getRecipe(): Recipe
	setResult(arg0: ItemStack): void
	getResult(): ItemStack
}
declare interface PointedDripstone extends Waterlogged {
	getVerticalDirection(): BlockFace
	setVerticalDirection(arg0: BlockFace): void
	getVerticalDirections(): Set
	getThickness(): Thickness
	setThickness(arg0: Thickness): void
}
declare class Ladder extends SimpleAttachableMaterialData {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	clone(): MaterialData
	clone(): Ladder
	clone(): Object
	clone(): SimpleAttachableMaterialData
}
declare interface EnderDragonPart extends ComplexEntityPart, Damageable {
	getParent(): EnderDragon
	getParent(): ComplexLivingEntity
}
declare class FileUtil {
	copy(arg0: File, arg1: File): boolean
}
namespace ItemSpawnEvent {
	function getEntity(): Entity
	function getEntity(): Item
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerUnleashEntityEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getPlayer(): Player
	function getHandlerList(): HandlerList
	function getReason(): UnleashReason
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace MapInitializeEvent {
	function getHandlerList(): HandlerList
	function getMap(): MapView
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Piglin extends PiglinAbstract, InventoryHolder {
	isAbleToHunt(): boolean
	setIsAbleToHunt(arg0: boolean): void
	addBarterMaterial(arg0: Material): boolean
	removeBarterMaterial(arg0: Material): boolean
	addMaterialOfInterest(arg0: Material): boolean
	removeMaterialOfInterest(arg0: Material): boolean
	getInterestList(): Set
	getBarterList(): Set
}
declare class MaterialData implements Cloneable {
	getItemType(): Material
	toItemStack(): ItemStack
	toItemStack(arg0: int): ItemStack
	setData(arg0: byte): void
	getData(): byte
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	clone(): Object
	clone(): MaterialData
}
declare class CommandPermissions {
	registerPermissions(arg0: Permission): Permission
}
declare interface Axolotl extends Animals {
	isPlayingDead(): boolean
	setPlayingDead(arg0: boolean): void
	setVariant(arg0: Variant): void
	getVariant(): Variant
}
declare interface MapCanvas {
	getBasePixel(arg0: int, arg1: int): byte
	getMapView(): MapView
	getCursors(): MapCursorCollection
	setCursors(arg0: MapCursorCollection): void
	setPixel(arg0: int, arg1: int, arg2: byte): void
	getPixel(arg0: int, arg1: int): byte
	drawText(arg0: int, arg1: int, arg2: MapFont, arg3: String): void
	drawImage(arg0: int, arg1: int, arg2: Image): void
}
namespace PrepareSmithingEvent {
	function getHandlerList(): HandlerList
	function getInventory(): SmithingInventory
	function getInventory(): Inventory
	function setResult(arg0: ItemStack): void
	function getHandlers(): HandlerList
	function getResult(): ItemStack
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface SpawnEggMeta extends ItemMeta {
	getSpawnedType(): EntityType
	setSpawnedType(arg0: EntityType): void
	clone(): ItemMeta
	clone(): Object
	clone(): SpawnEggMeta
}
declare interface ProjectileSource {
	launchProjectile(arg0: Class): Projectile
	launchProjectile(arg0: Class, arg1: Vector): Projectile
}
declare class Observer extends MaterialData implements Directional, Redstone {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	isPowered(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Observer
	clone(): MaterialData
}
declare class Mushroom extends MaterialData {
	getBlockTexture(): MushroomBlockTexture
	setBlockTexture(arg0: MushroomBlockTexture): void
	isFacePainted(arg0: BlockFace): boolean
	setFacePainted(arg0: BlockFace, arg1: boolean): void
	getPaintedFaces(): Set
	isStem(): boolean
	setStem(): void
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Mushroom
	clone(): MaterialData
}
declare interface PufferFish extends Fish {
	getPuffState(): int
	setPuffState(arg0: int): void
}
declare interface DragonFireball extends Fireball {
}
declare interface MapMeta extends ItemMeta {
	hasLocationName(): boolean
	getLocationName(): String
	setLocationName(arg0: String): void
	getColor(): Color
	hasColor(): boolean
	getMapView(): MapView
	hasMapId(): boolean
	getMapId(): int
	setMapId(arg0: int): void
	hasMapView(): boolean
	setMapView(arg0: MapView): void
	isScaling(): boolean
	setScaling(arg0: boolean): void
	clone(): Object
	clone(): MapMeta
	clone(): ItemMeta
	setColor(arg0: Color): void
}
declare class StructureType {
	getStructureTypes(): Map
	getMapIcon(): Type
	getName(): String
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	register(arg0: StructureType): StructureType
}
namespace InventoryDragEvent {
	function getHandlerList(): HandlerList
	function getNewItems(): Map
	function getRawSlots(): Set
	function getInventorySlots(): Set
	function getOldCursor(): ItemStack
	function getCursor(): ItemStack
	function setCursor(arg0: ItemStack): void
	function getType(): DragType
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getWhoClicked(): HumanEntity
	function setResult(arg0: Result): void
	function getResult(): Result
	function getInventory(): Inventory
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Fluid extends Enum implements Keyed {
	values(): Fluid[]
	valueOf(arg0: String): Fluid
	getKey(): NamespacedKey
}
declare interface ZombieVillager extends Zombie {
	getConversionTime(): int
	setConversionTime(arg0: int): void
	isConverting(): boolean
	getVillagerType(): Type
	setVillagerType(arg0: Type): void
	setVillagerProfession(arg0: Profession): void
	getVillagerProfession(): Profession
	getConversionPlayer(): OfflinePlayer
	setConversionPlayer(arg0: OfflinePlayer): void
}
namespace PlayerBucketFillEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getItemStack(): ItemStack
	function getBlockFace(): BlockFace
	function setItemStack(arg0: ItemStack): void
	function getBlockClicked(): Block
	function getBlock(): Block
	function getBucket(): Material
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Damageable {
	setDamage(arg0: int): void
	getDamage(): int
	hasDamage(): boolean
	clone(): Damageable
	clone(): Object
}
namespace FireworkExplodeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getEntity(): Firework
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class LongGrass extends MaterialData {
	setSpecies(arg0: GrassSpecies): void
	getSpecies(): GrassSpecies
	toString(): String
	clone(): Object
	clone(): MaterialData
	clone(): LongGrass
}
declare class Banner extends MaterialData implements Attachable {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	isWallBanner(): boolean
	getFacing(): BlockFace
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Banner
	clone(): MaterialData
}
declare class TripwireHook extends SimpleAttachableMaterialData implements Redstone {
	setFacingDirection(arg0: BlockFace): void
	getAttachedFace(): BlockFace
	isActivated(): boolean
	setActivated(arg0: boolean): void
	isConnected(): boolean
	setConnected(arg0: boolean): void
	isPowered(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): MaterialData
	clone(): SimpleAttachableMaterialData
	clone(): Object
	clone(): TripwireHook
}
declare class JavaPluginLoader implements PluginLoader {
	getPluginDescription(arg0: File): PluginDescriptionFile
	getPluginFileFilters(): Pattern[]
	getClassByName(arg0: String, arg1: boolean, arg2: PluginDescriptionFile): Class
	removeClass(arg0: Class): void
	createRegisteredListeners(arg0: Listener, arg1: Plugin): Map
	enablePlugin(arg0: Plugin): void
	disablePlugin(arg0: Plugin): void
	loadPlugin(arg0: File): Plugin
	setClass(arg0: String, arg1: Class): void
}
namespace PlayerUnregisterChannelEvent {
	function getHandlerList(): HandlerList
	function getChannel(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Repairable {
	getRepairCost(): int
	setRepairCost(arg0: int): void
	hasRepairCost(): boolean
	clone(): Repairable
	clone(): Object
}
declare interface PersistentDataType {
	getPrimitiveType(): Class
	getComplexType(): Class
	toPrimitive(arg0: Object, arg1: PersistentDataAdapterContext): Object
	fromPrimitive(arg0: Object, arg1: PersistentDataAdapterContext): Object
}
declare class PrimitivePersistentDataType implements PersistentDataType {
	getPrimitiveType(): Class
	getComplexType(): Class
	toPrimitive(arg0: Object, arg1: PersistentDataAdapterContext): Object
	fromPrimitive(arg0: Object, arg1: PersistentDataAdapterContext): Object
}
declare class Builder {
	lootingModifier(arg0: int): Builder
	lootedEntity(arg0: Entity): Builder
	luck(arg0: float): Builder
	killer(arg0: HumanEntity): Builder
	build(): LootContext
}
declare interface ProxiedCommandSender extends CommandSender {
	getCaller(): CommandSender
	getCallee(): CommandSender
}
declare interface SmithingInventory extends Inventory {
	getRecipe(): Recipe
	setResult(arg0: ItemStack): void
	getResult(): ItemStack
}
namespace PlayerHarvestBlockEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getHarvestedBlock(): Block
	function getItemsHarvested(): List
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Steerable extends Animals {
	getBoostTicks(): int
	setBoostTicks(arg0: int): void
	getCurrentBoostTicks(): int
	setCurrentBoostTicks(arg0: int): void
	getSteerMaterial(): Material
	hasSaddle(): boolean
	setSaddle(arg0: boolean): void
}
declare interface TropicalFishBucketMeta extends ItemMeta {
	getPatternColor(): DyeColor
	setPatternColor(arg0: DyeColor): void
	getBodyColor(): DyeColor
	setBodyColor(arg0: DyeColor): void
	getPattern(): Pattern
	setPattern(arg0: Pattern): void
	hasVariant(): boolean
	clone(): Object
	clone(): ItemMeta
	clone(): TropicalFishBucketMeta
}
declare interface VoxelShape {
	getBoundingBoxes(): Collection
	overlaps(arg0: BoundingBox): boolean
}
declare interface Jukebox extends BlockData {
	hasRecord(): boolean
}
declare class SimpleServicesManager implements ServicesManager {
	unregisterAll(arg0: Plugin): void
	getRegistration(arg0: Class): RegisteredServiceProvider
	getRegistrations(arg0: Class): List
	getRegistrations(arg0: Plugin): List
	getRegistrations(arg0: Class): Collection
	getKnownServices(): Collection
	getKnownServices(): Set
	isProvidedFor(arg0: Class): boolean
	load(arg0: Class): Object
	register(arg0: Class, arg1: Object, arg2: Plugin, arg3: ServicePriority): void
	unregister(arg0: Object): void
	unregister(arg0: Class, arg1: Object): void
}
declare interface CommandBlock extends TileState {
	getCommand(): String
	setCommand(arg0: String): void
	getName(): String
	setName(arg0: String): void
}
declare class EnchantmentWrapper extends Enchantment {
	getStartLevel(): int
	getMaxLevel(): int
	canEnchantItem(arg0: ItemStack): boolean
	getEnchantment(): Enchantment
	getItemTarget(): EnchantmentTarget
	conflictsWith(arg0: Enchantment): boolean
	isTreasure(): boolean
	isCursed(): boolean
	getName(): String
}
declare class BukkitRunnable implements Runnable {
	isCancelled(): boolean
	runTaskAsynchronously(arg0: Plugin): BukkitTask
	runTaskLater(arg0: Plugin, arg1: long): BukkitTask
	runTaskLaterAsynchronously(arg0: Plugin, arg1: long): BukkitTask
	runTaskTimer(arg0: Plugin, arg1: long, arg2: long): BukkitTask
	runTaskTimerAsynchronously(arg0: Plugin, arg1: long, arg2: long): BukkitTask
	checkScheduled(): void
	checkNotYetScheduled(): void
	cancel(): void
	getTaskId(): int
	runTask(arg0: Plugin): BukkitTask
	setupTask(arg0: BukkitTask): BukkitTask
}
namespace PlayerInteractEntityEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRightClicked(): Entity
	function getHand(): EquipmentSlot
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Shulker extends Golem, Colorable {
	getAttachedFace(): BlockFace
	setAttachedFace(arg0: BlockFace): void
	getPeek(): float
	setPeek(arg0: float): void
}
declare class WoodenStep extends Wood {
	setInverted(arg0: boolean): void
	isInverted(): boolean
	toString(): String
	clone(): MaterialData
	clone(): Object
	clone(): Wood
	clone(): WoodenStep
}
declare interface Levelled extends BlockData {
	getMaximumLevel(): int
	getLevel(): int
	setLevel(arg0: int): void
}
declare interface Creeper extends Monster {
	setMaxFuseTicks(arg0: int): void
	getMaxFuseTicks(): int
	setFuseTicks(arg0: int): void
	getFuseTicks(): int
	setExplosionRadius(arg0: int): void
	getExplosionRadius(): int
	isPowered(): boolean
	setPowered(arg0: boolean): void
	explode(): void
	ignite(): void
}
namespace ArrowBodyCountChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getOldAmount(): int
	function getNewAmount(): int
	function setNewAmount(arg0: int): void
	function getEntity(): Entity
	function getEntity(): LivingEntity
	function isReset(): boolean
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface CompassMeta extends ItemMeta {
	hasLodestone(): boolean
	getLodestone(): Location
	setLodestone(arg0: Location): void
	isLodestoneTracked(): boolean
	setLodestoneTracked(arg0: boolean): void
	clone(): CompassMeta
	clone(): ItemMeta
	clone(): Object
}
declare class RegisteredServiceProvider implements Comparable {
	getPlugin(): Plugin
	getService(): Class
	compareTo(arg0: RegisteredServiceProvider): int
	compareTo(arg0: Object): int
	getPriority(): ServicePriority
	getProvider(): Object
}
namespace HangingPlaceEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlockFace(): BlockFace
	function getBlock(): Block
	function getPlayer(): Player
	function getHandlers(): HandlerList
	function getEntity(): Hanging
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface PluginManager {
	getPermissionSubscriptions(arg0: String): Set
	addPermission(arg0: Permission): void
	getDefaultPermissions(arg0: boolean): Set
	subscribeToDefaultPerms(arg0: boolean, arg1: Permissible): void
	subscribeToPermission(arg0: String, arg1: Permissible): void
	unsubscribeFromPermission(arg0: String, arg1: Permissible): void
	enablePlugin(arg0: Plugin): void
	disablePlugin(arg0: Plugin): void
	registerInterface(arg0: Class): void
	isPluginEnabled(arg0: String): boolean
	isPluginEnabled(arg0: Plugin): boolean
	loadPlugins(arg0: File): Plugin[]
	disablePlugins(): void
	clearPlugins(): void
	registerEvents(arg0: Listener, arg1: Plugin): void
	registerEvent(arg0: Class, arg1: Listener, arg2: EventPriority, arg3: EventExecutor, arg4: Plugin): void
	registerEvent(arg0: Class, arg1: Listener, arg2: EventPriority, arg3: EventExecutor, arg4: Plugin, arg5: boolean): void
	removePermission(arg0: String): void
	removePermission(arg0: Permission): void
	useTimings(): boolean
	getPlugin(arg0: String): Plugin
	getPlugins(): Plugin[]
	callEvent(arg0: Event): void
	loadPlugin(arg0: File): Plugin
	unsubscribeFromDefaultPerms(arg0: boolean, arg1: Permissible): void
	recalculatePermissionDefaults(arg0: Permission): void
	getDefaultPermSubscriptions(arg0: boolean): Set
	getPermissions(): Set
	getPermission(arg0: String): Permission
}
declare interface LightningRod extends Directional, Powerable, Waterlogged {
}
declare interface GlassPane extends MultipleFacing, Waterlogged {
}
declare interface Evoker extends Spellcaster {
	getCurrentSpell(): Spell
	setCurrentSpell(arg0: Spell): void
}
declare interface ConsoleCommandSender extends CommandSender, Conversable {
}
declare interface SizedFireball extends Fireball {
	getDisplayItem(): ItemStack
	setDisplayItem(arg0: ItemStack): void
}
declare interface Beehive extends EntityBlockStorage {
	getFlower(): Location
	setFlower(arg0: Location): void
	isSedated(): boolean
}
declare class MemorySection implements ConfigurationSection {
	createSection(arg0: String): ConfigurationSection
	createSection(arg0: String, arg1: Map): ConfigurationSection
	getCurrentPath(): String
	getStringList(arg0: String): List
	getIntegerList(arg0: String): List
	getBooleanList(arg0: String): List
	getDoubleList(arg0: String): List
	getFloatList(arg0: String): List
	getLongList(arg0: String): List
	getByteList(arg0: String): List
	getCharacterList(arg0: String): List
	getShortList(arg0: String): List
	getSerializable(arg0: String, arg1: Class, arg2: ConfigurationSerializable): ConfigurationSerializable
	getSerializable(arg0: String, arg1: Class): ConfigurationSerializable
	getOfflinePlayer(arg0: String): OfflinePlayer
	getOfflinePlayer(arg0: String, arg1: OfflinePlayer): OfflinePlayer
	isOfflinePlayer(arg0: String): boolean
	getItemStack(arg0: String): ItemStack
	getItemStack(arg0: String, arg1: ItemStack): ItemStack
	isItemStack(arg0: String): boolean
	getConfigurationSection(arg0: String): ConfigurationSection
	isConfigurationSection(arg0: String): boolean
	getDefaultSection(): ConfigurationSection
	mapChildrenKeys(arg0: Set, arg1: ConfigurationSection, arg2: boolean): void
	mapChildrenValues(arg0: Map, arg1: ConfigurationSection, arg2: boolean): void
	isPrimitiveWrapper(arg0: Object): boolean
	getColor(arg0: String): Color
	getColor(arg0: String, arg1: Color): Color
	getValues(arg0: boolean): Map
	addDefault(arg0: String, arg1: Object): void
	isString(arg0: String): boolean
	isInt(arg0: String): boolean
	isBoolean(arg0: String): boolean
	isDouble(arg0: String): boolean
	isLong(arg0: String): boolean
	getList(arg0: String, arg1: List): List
	getList(arg0: String): List
	isList(arg0: String): boolean
	getMapList(arg0: String): List
	getVector(arg0: String, arg1: Vector): Vector
	getVector(arg0: String): Vector
	isVector(arg0: String): boolean
	isColor(arg0: String): boolean
	isLocation(arg0: String): boolean
	createPath(arg0: ConfigurationSection, arg1: String, arg2: ConfigurationSection): String
	createPath(arg0: ConfigurationSection, arg1: String): String
	getName(): String
	get(arg0: String): Object
	get(arg0: String, arg1: Object): Object
	toString(): String
	getBoolean(arg0: String, arg1: boolean): boolean
	getBoolean(arg0: String): boolean
	getInt(arg0: String): int
	getInt(arg0: String, arg1: int): int
	getLong(arg0: String, arg1: long): long
	getLong(arg0: String): long
	getDouble(arg0: String, arg1: double): double
	getDouble(arg0: String): double
	getDefault(arg0: String): Object
	contains(arg0: String, arg1: boolean): boolean
	contains(arg0: String): boolean
	getLocation(arg0: String, arg1: Location): Location
	getLocation(arg0: String): Location
	getParent(): ConfigurationSection
	set(arg0: String, arg1: Object): void
	isSet(arg0: String): boolean
	getRoot(): Configuration
	getObject(arg0: String, arg1: Class): Object
	getObject(arg0: String, arg1: Class, arg2: Object): Object
	getString(arg0: String): String
	getString(arg0: String, arg1: String): String
	getKeys(arg0: boolean): Set
}
declare class ShapelessRecipe implements Recipe, Keyed {
	addIngredient(arg0: Material, arg1: int): ShapelessRecipe
	addIngredient(arg0: int, arg1: MaterialData): ShapelessRecipe
	addIngredient(arg0: int, arg1: Material): ShapelessRecipe
	addIngredient(arg0: int, arg1: Material, arg2: int): ShapelessRecipe
	addIngredient(arg0: RecipeChoice): ShapelessRecipe
	addIngredient(arg0: MaterialData): ShapelessRecipe
	addIngredient(arg0: Material): ShapelessRecipe
	removeIngredient(arg0: int, arg1: Material): ShapelessRecipe
	removeIngredient(arg0: int, arg1: MaterialData): ShapelessRecipe
	removeIngredient(arg0: Material, arg1: int): ShapelessRecipe
	removeIngredient(arg0: int, arg1: Material, arg2: int): ShapelessRecipe
	removeIngredient(arg0: RecipeChoice): ShapelessRecipe
	removeIngredient(arg0: Material): ShapelessRecipe
	removeIngredient(arg0: MaterialData): ShapelessRecipe
	getIngredientList(): List
	getChoiceList(): List
	getGroup(): String
	setGroup(arg0: String): void
	getKey(): NamespacedKey
	getResult(): ItemStack
}
declare class SimpleCommandMap implements CommandMap {
	registerAll(arg0: String, arg1: List): void
	clearCommands(): void
	tabComplete(arg0: CommandSender, arg1: String, arg2: Location): List
	tabComplete(arg0: CommandSender, arg1: String): List
	getCommands(): Collection
	setDefaultCommands(): void
	setFallbackCommands(): void
	registerServerAliases(): void
	getCommand(arg0: String): Command
	dispatch(arg0: CommandSender, arg1: String): boolean
	register(arg0: String, arg1: Command, arg2: boolean, arg3: String): boolean
	register(arg0: String, arg1: Command): boolean
	register(arg0: String, arg1: String, arg2: Command): boolean
}
declare class TimedRegisteredListener extends RegisteredListener {
	getCommonSuperclass(arg0: Class, arg1: Class): Class
	getTotalTime(): long
	getEventClass(): Class
	hasMultiple(): boolean
	callEvent(arg0: Event): void
	reset(): void
	getCount(): int
}
declare interface BiomeGrid {
	getBiome(arg0: int, arg1: int): Biome
	getBiome(arg0: int, arg1: int, arg2: int): Biome
	setBiome(arg0: int, arg1: int, arg2: int, arg3: Biome): void
	setBiome(arg0: int, arg1: int, arg2: Biome): void
}
namespace PluginEnableEvent {
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function getPlugin(): Plugin
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class ConversationFactory {
	withModality(arg0: boolean): ConversationFactory
	withLocalEcho(arg0: boolean): ConversationFactory
	withTimeout(arg0: int): ConversationFactory
	withConversationCanceller(arg0: ConversationCanceller): ConversationFactory
	withFirstPrompt(arg0: Prompt): ConversationFactory
	withInitialSessionData(arg0: Map): ConversationFactory
	withEscapeSequence(arg0: String): ConversationFactory
	buildConversation(arg0: Conversable): Conversation
	withPrefix(arg0: ConversationPrefix): ConversationFactory
	thatExcludesNonPlayersWithMessage(arg0: String): ConversationFactory
	addConversationAbandonedListener(arg0: ConversationAbandonedListener): ConversationFactory
}
declare interface Recipe {
	getResult(): ItemStack
}
declare class MinecraftFont extends MapFont {
}
declare interface PigZombie extends Zombie {
	getConversionTime(): int
	setConversionTime(arg0: int): void
	isConverting(): boolean
	isAngry(): boolean
	setAngry(arg0: boolean): void
	getAnger(): int
	setAnger(arg0: int): void
}
namespace EntityToggleSwimEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isSwimming(): boolean
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface CommandBlock extends Directional {
	isConditional(): boolean
	setConditional(arg0: boolean): void
}
declare class EntityDestination implements Destination {
	getEntity(): Entity
}
declare interface Candle extends Lightable, Waterlogged {
	getMaximumCandles(): int
	getCandles(): int
	setCandles(arg0: int): void
}
namespace PlayerLeashEntityEvent {
	function getLeashHolder(): Entity
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getPlayer(): Player
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Sapling extends Wood {
	isInstantGrowable(): boolean
	setIsInstantGrowable(arg0: boolean): void
	toString(): String
	clone(): MaterialData
	clone(): Object
	clone(): Wood
	clone(): Sapling
}
declare class PluginsCommand extends BukkitCommand {
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[]): List
	getPluginList(): String
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
}
declare interface LivingEntity extends Attributable, Damageable, ProjectileSource {
	setMaximumAir(arg0: int): void
	getArrowCooldown(): int
	setSwimming(arg0: boolean): void
	setInvisible(arg0: boolean): void
	getMaximumNoDamageTicks(): int
	addPotionEffects(arg0: Collection): boolean
	getPotionEffect(arg0: PotionEffectType): PotionEffect
	getNoDamageTicks(): int
	isRiptiding(): boolean
	setCollidable(arg0: boolean): void
	hasLineOfSight(arg0: Entity): boolean
	swingOffHand(): void
	getActivePotionEffects(): Collection
	setArrowCooldown(arg0: int): void
	setMaximumNoDamageTicks(arg0: int): void
	isInvisible(): boolean
	setRemoveWhenFarAway(arg0: boolean): void
	isCollidable(): boolean
	setArrowsInBody(arg0: int): void
	addPotionEffect(arg0: PotionEffect, arg1: boolean): boolean
	addPotionEffect(arg0: PotionEffect): boolean
	setLastDamage(arg0: double): void
	hasPotionEffect(arg0: PotionEffectType): boolean
	setLeashHolder(arg0: Entity): boolean
	getEquipment(): EntityEquipment
	getLeashHolder(): Entity
	setNoDamageTicks(arg0: int): void
	getRemoveWhenFarAway(): boolean
	setCanPickupItems(arg0: boolean): void
	swingMainHand(): void
	getArrowsInBody(): int
	getCollidableExemptions(): Set
	getCanPickupItems(): boolean
	getCategory(): EntityCategory
	removePotionEffect(arg0: PotionEffectType): void
	getLastDamage(): double
	getEyeHeight(arg0: boolean): double
	getEyeHeight(): double
	getEyeLocation(): Location
	getLineOfSight(arg0: Set, arg1: int): List
	getTargetBlock(arg0: Set, arg1: int): Block
	getLastTwoTargetBlocks(arg0: Set, arg1: int): List
	getTargetBlockExact(arg0: int, arg1: FluidCollisionMode): Block
	getTargetBlockExact(arg0: int): Block
	rayTraceBlocks(arg0: double, arg1: FluidCollisionMode): RayTraceResult
	rayTraceBlocks(arg0: double): RayTraceResult
	getRemainingAir(): int
	setRemainingAir(arg0: int): void
	getMaximumAir(): int
	getKiller(): Player
	isLeashed(): boolean
	isGliding(): boolean
	setGliding(arg0: boolean): void
	isSwimming(): boolean
	isSleeping(): boolean
	isClimbing(): boolean
	setAI(arg0: boolean): void
	hasAI(): boolean
	attack(arg0: Entity): void
	getMemory(arg0: MemoryKey): Object
	setMemory(arg0: MemoryKey, arg1: Object): void
}
namespace EntityAirChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getAmount(): int
	function setAmount(arg0: int): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface RideableMinecart extends Minecart {
}
declare interface AmethystCluster extends Directional, Waterlogged {
}
declare interface Ambient extends Mob {
}
declare class Spigot extends Spigot {
	sendMessage(arg0: ChatMessageType, arg1: UUID, arg2: BaseComponent[]): void
	sendMessage(arg0: BaseComponent[]): void
	sendMessage(arg0: ChatMessageType, arg1: BaseComponent): void
	sendMessage(arg0: ChatMessageType, arg1: BaseComponent[]): void
	sendMessage(arg0: ChatMessageType, arg1: UUID, arg2: BaseComponent): void
	sendMessage(arg0: BaseComponent): void
	getRawAddress(): InetSocketAddress
	getCollidesWithEntities(): boolean
	setCollidesWithEntities(arg0: boolean): void
	getHiddenPlayers(): Set
	respawn(): void
}
namespace VehicleExitEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getExited(): LivingEntity
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace RaidEvent {
	function getRaid(): Raid
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface EnchantmentStorageMeta extends ItemMeta {
	hasStoredEnchants(): boolean
	hasStoredEnchant(arg0: Enchantment): boolean
	getStoredEnchantLevel(arg0: Enchantment): int
	getStoredEnchants(): Map
	addStoredEnchant(arg0: Enchantment, arg1: int, arg2: boolean): boolean
	removeStoredEnchant(arg0: Enchantment): boolean
	hasConflictingStoredEnchant(arg0: Enchantment): boolean
	clone(): Object
	clone(): ItemMeta
	clone(): EnchantmentStorageMeta
}
declare interface BookMeta extends ItemMeta {
	hasGeneration(): boolean
	getGeneration(): Generation
	setGeneration(arg0: Generation): void
	getPageCount(): int
	spigot(): Spigot
	getTitle(): String
	setTitle(arg0: String): boolean
	getPages(): List
	setPages(arg0: List): void
	setPages(arg0: String[]): void
	addPage(arg0: String[]): void
	getPage(arg0: int): String
	setPage(arg0: int, arg1: String): void
	getAuthor(): String
	setAuthor(arg0: String): void
	hasTitle(): boolean
	hasAuthor(): boolean
	hasPages(): boolean
	clone(): Object
	clone(): ItemMeta
	clone(): BookMeta
}
declare class Pattern implements ConfigurationSerializable {
	serialize(): Map
	getColor(): DyeColor
	getPattern(): PatternType
	equals(arg0: Object): boolean
	hashCode(): int
	getString(arg0: Map, arg1: Object): String
}
declare class ExactChoice implements RecipeChoice {
	getItemStack(): ItemStack
	getChoices(): List
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	clone(): RecipeChoice
	clone(): ExactChoice
	clone(): Object
	test(arg0: Object): boolean
	test(arg0: ItemStack): boolean
}
declare class ConversationContext {
	getAllSessionData(): Map
	getSessionData(arg0: Object): Object
	setSessionData(arg0: Object, arg1: Object): void
	getForWhom(): Conversable
	getPlugin(): Plugin
}
declare interface Bed extends Directional {
	getPart(): Part
	setPart(arg0: Part): void
	isOccupied(): boolean
}
namespace SpawnerSpawnEvent {
	function getSpawner(): CreatureSpawner
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerSwapHandItemsEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getMainHandItem(): ItemStack
	function setMainHandItem(arg0: ItemStack): void
	function getOffHandItem(): ItemStack
	function setOffHandItem(arg0: ItemStack): void
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Bed extends TileState, Colorable {
}
declare interface Furnace extends Container {
	getSnapshotInventory(): Inventory
	getSnapshotInventory(): FurnaceInventory
	getBurnTime(): short
	setBurnTime(arg0: short): void
	getInventory(): FurnaceInventory
	getInventory(): Inventory
	getCookTime(): short
	setCookTime(arg0: short): void
	getCookTimeTotal(): int
	setCookTimeTotal(arg0: int): void
}
declare interface LightningStrike extends Entity {
	spigot(): Spigot
	spigot(): Spigot
	spigot(): Spigot
	isEffect(): boolean
}
declare interface Dolphin extends WaterMob {
}
declare class ShapedRecipe implements Recipe, Keyed {
	setIngredient(arg0: char, arg1: MaterialData): ShapedRecipe
	setIngredient(arg0: char, arg1: Material, arg2: int): ShapedRecipe
	setIngredient(arg0: char, arg1: RecipeChoice): ShapedRecipe
	setIngredient(arg0: char, arg1: Material): ShapedRecipe
	getIngredientMap(): Map
	getChoiceMap(): Map
	getShape(): String[]
	getGroup(): String
	setGroup(arg0: String): void
	getKey(): NamespacedKey
	getResult(): ItemStack
	shape(arg0: String[]): ShapedRecipe
}
declare class GameEvent implements Keyed {
	getEvent(arg0: String): GameEvent
	getByKey(arg0: NamespacedKey): GameEvent
	values(): Collection
	getKey(): NamespacedKey
}
namespace AsyncPlayerChatEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRecipients(): Set
	function setMessage(arg0: String): void
	function getFormat(): String
	function setFormat(arg0: String): void
	function getMessage(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface UndefinedNullability extends Annotation {
	value(): String
}
namespace GenericGameEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntity(): Entity
	function getRadius(): int
	function setRadius(arg0: int): void
	function getEvent(): GameEvent
	function getLocation(): Location
	function getHandlers(): HandlerList
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class Attribute extends Enum implements Keyed {
	values(): Attribute[]
	valueOf(arg0: String): Attribute
	getKey(): NamespacedKey
}
declare interface SpawnerMinecart extends Minecart {
}
declare interface DaylightDetector extends AnaloguePowerable {
	setInverted(arg0: boolean): void
	isInverted(): boolean
}
declare interface TraderLlama extends Llama {
}
declare class HelpCommand extends BukkitCommand {
	tabComplete(arg0: CommandSender, arg1: String, arg2: String[]): List
	findPossibleMatches(arg0: String): HelpTopic
	damerauLevenshteinDistance(arg0: String, arg1: String): int
	execute(arg0: CommandSender, arg1: String, arg2: String[]): boolean
}
namespace EntityBlockFormEvent {
	function getEntity(): Entity
	function getHandlerList(): HandlerList
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getNewState(): BlockState
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PermissionAttachmentInfo {
	getPermissible(): Permissible
	getAttachment(): PermissionAttachment
	getValue(): boolean
	getPermission(): String
}
declare interface ItemTagAdapterContext {
	newTagContainer(): CustomItemTagContainer
}
declare class PotionEffect implements ConfigurationSerializable {
	getDuration(): int
	getEffectType(arg0: Map): PotionEffectType
	getAmplifier(): int
	hasParticles(): boolean
	serialize(): Map
	getColor(): Color
	getBool(arg0: Map, arg1: Object, arg2: boolean): boolean
	isAmbient(): boolean
	hasIcon(): boolean
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	getInt(arg0: Map, arg1: Object): int
	apply(arg0: LivingEntity): boolean
	getType(): PotionEffectType
}
namespace PlayerChatEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRecipients(): Set
	function setMessage(arg0: String): void
	function setPlayer(arg0: Player): void
	function getFormat(): String
	function setFormat(arg0: String): void
	function getMessage(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Fireball extends Projectile, Explosive {
	getDirection(): Vector
	setDirection(arg0: Vector): void
}
declare class FixedSetPrompt extends ValidatingPrompt {
	isInputValid(arg0: ConversationContext, arg1: String): boolean
	formatFixedSet(): String
}
declare interface AxolotlBucketMeta extends ItemMeta {
	setVariant(arg0: Variant): void
	hasVariant(): boolean
	clone(): Object
	clone(): ItemMeta
	clone(): AxolotlBucketMeta
	getVariant(): Variant
}
namespace BlockCanBuildEvent {
	function getBlockData(): BlockData
	function getHandlerList(): HandlerList
	function getMaterial(): Material
	function isBuildable(): boolean
	function setBuildable(arg0: boolean): void
	function getPlayer(): Player
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface RedstoneWallTorch extends Directional, Lightable {
}
namespace BlockFromToEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getFace(): BlockFace
	function getToBlock(): Block
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface TNT extends BlockData {
	setUnstable(arg0: boolean): void
	isUnstable(): boolean
}
namespace EntityPoseChangeEvent {
	function getHandlerList(): HandlerList
	function getPose(): Pose
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class LibraryLoader {
	createLoader(arg0: PluginDescriptionFile): ClassLoader
}
declare interface Slime extends Mob {
	getSize(): int
	setSize(arg0: int): void
}
declare interface TabCompleter {
	onTabComplete(arg0: CommandSender, arg1: Command, arg2: String, arg3: String[]): List
}
declare interface Animals extends Breedable {
	getBreedCause(): UUID
	setBreedCause(arg0: UUID): void
	getLoveModeTicks(): int
	setLoveModeTicks(arg0: int): void
	isBreedItem(arg0: Material): boolean
	isBreedItem(arg0: ItemStack): boolean
	isLoveMode(): boolean
}
namespace EntityPortalExitEvent {
	function getHandlerList(): HandlerList
	function getBefore(): Vector
	function getAfter(): Vector
	function setAfter(arg0: Vector): void
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getFrom(): Location
	function setFrom(arg0: Location): void
	function getTo(): Location
	function setTo(arg0: Location): void
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class TopicNameComparator implements Comparator {
	compare(arg0: String, arg1: String): int
	compare(arg0: Object, arg1: Object): int
}
declare interface CaveSpider extends Spider {
}
declare class ValidatingPrompt implements Prompt {
	blocksForInput(arg0: ConversationContext): boolean
	acceptInput(arg0: ConversationContext, arg1: String): Prompt
	isInputValid(arg0: ConversationContext, arg1: String): boolean
	acceptValidatedInput(arg0: ConversationContext, arg1: String): Prompt
	getFailedValidationText(arg0: ConversationContext, arg1: String): String
}
declare interface MultipleFacing extends BlockData {
	getAllowedFaces(): Set
	getFaces(): Set
	hasFace(arg0: BlockFace): boolean
	setFace(arg0: BlockFace, arg1: boolean): void
}
declare interface EnderCrystal extends Entity {
	isShowingBottom(): boolean
	setShowingBottom(arg0: boolean): void
	getBeamTarget(): Location
	setBeamTarget(arg0: Location): void
}
declare interface EventExecutor {
	execute(arg0: Listener, arg1: Event): void
}
declare class PluginMessageListenerRegistration {
	getListener(): PluginMessageListener
	isValid(): boolean
	getPlugin(): Plugin
	equals(arg0: Object): boolean
	hashCode(): int
	getChannel(): String
}
namespace PigZapEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLightning(): LightningStrike
	function getPigZombie(): PigZombie
	function getEntity(): Entity
	function getEntity(): Pig
	function getHandlers(): HandlerList
	function getTransformedEntity(): Entity
	function getTransformedEntities(): List
	function getTransformReason(): TransformReason
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface BlockProjectileSource extends ProjectileSource {
	getBlock(): Block
}
declare interface CommandSender extends Permissible {
	sendMessage(arg0: UUID, arg1: String[]): void
	sendMessage(arg0: UUID, arg1: String): void
	sendMessage(arg0: String[]): void
	sendMessage(arg0: String): void
	getServer(): Server
	spigot(): Spigot
	getName(): String
}
declare class Pumpkin extends MaterialData implements Directional {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	isLit(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	toString(): String
	clone(): Object
	clone(): Pumpkin
	clone(): MaterialData
}
namespace VillagerCareerChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getProfession(): Profession
	function setProfession(arg0: Profession): void
	function getEntity(): Villager
	function getEntity(): Entity
	function getReason(): ChangeReason
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface ChestedHorse extends AbstractHorse {
	isCarryingChest(): boolean
	setCarryingChest(arg0: boolean): void
}
declare class MapCursor {
	getDirection(): byte
	setDirection(arg0: byte): void
	setVisible(arg0: boolean): void
	isVisible(): boolean
	setX(arg0: byte): void
	setY(arg0: byte): void
	getX(): byte
	getY(): byte
	setType(arg0: Type): void
	setRawType(arg0: byte): void
	getCaption(): String
	setCaption(arg0: String): void
	getType(): Type
	getRawType(): byte
}
namespace PrepareAnvilEvent {
	function getHandlerList(): HandlerList
	function getInventory(): AnvilInventory
	function getInventory(): Inventory
	function setResult(arg0: ItemStack): void
	function getHandlers(): HandlerList
	function getResult(): ItemStack
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface KnowledgeBookMeta extends ItemMeta {
	getRecipes(): List
	setRecipes(arg0: List): void
	addRecipe(arg0: NamespacedKey[]): void
	hasRecipes(): boolean
	clone(): KnowledgeBookMeta
	clone(): ItemMeta
	clone(): Object
}
namespace BatToggleSleepEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isAwake(): boolean
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface PluginLoader {
	getPluginDescription(arg0: File): PluginDescriptionFile
	getPluginFileFilters(): Pattern[]
	createRegisteredListeners(arg0: Listener, arg1: Plugin): Map
	enablePlugin(arg0: Plugin): void
	disablePlugin(arg0: Plugin): void
	loadPlugin(arg0: File): Plugin
}
declare class HandlerList {
	registerAll(arg0: Collection): void
	unregisterAll(arg0: Listener): void
	unregisterAll(arg0: Plugin): void
	unregisterAll(): void
	getRegisteredListeners(): RegisteredListener[]
	getRegisteredListeners(arg0: Plugin): ArrayList
	getHandlerLists(): ArrayList
	bakeAll(): void
	bake(): void
	register(arg0: RegisteredListener): void
	unregister(arg0: Listener): void
	unregister(arg0: RegisteredListener): void
	unregister(arg0: Plugin): void
}
namespace VehicleEnterEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getEntered(): Entity
	function getHandlers(): HandlerList
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Tag extends Keyed {
	getValues(): Set
	isTagged(arg0: Keyed): boolean
}
namespace EntityToggleGlideEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function isGliding(): boolean
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Lootable {
	getLootTable(): LootTable
	setLootTable(arg0: LootTable): void
	getSeed(): long
	setSeed(arg0: long): void
}
declare interface SplashPotion extends ThrownPotion {
}
declare interface SeaPickle extends Waterlogged {
	getMinimumPickles(): int
	getMaximumPickles(): int
	getPickles(): int
	setPickles(arg0: int): void
}
namespace SignChangeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getLines(): String[]
	function getLine(arg0: int): String
	function setLine(arg0: int, arg1: String): void
	function getPlayer(): Player
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Hopper extends Container, Lootable {
}
namespace EntityChangeBlockEvent {
	function getBlockData(): BlockData
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlock(): Block
	function getTo(): Material
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class NotPlayerMessagePrompt extends MessagePrompt {
	getPromptText(arg0: ConversationContext): String
	getNextPrompt(arg0: ConversationContext): Prompt
}
declare interface Keyed {
	getKey(): NamespacedKey
}
declare interface Banner extends TileState {
	getBaseColor(): DyeColor
	setBaseColor(arg0: DyeColor): void
	getPatterns(): List
	setPatterns(arg0: List): void
	removePattern(arg0: int): Pattern
	numberOfPatterns(): int
	addPattern(arg0: Pattern): void
	getPattern(arg0: int): Pattern
	setPattern(arg0: int, arg1: Pattern): void
}
namespace ChunkLoadEvent {
	function getHandlerList(): HandlerList
	function isNewChunk(): boolean
	function getHandlers(): HandlerList
	function getChunk(): Chunk
	function getWorld(): World
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Attachable extends Directional {
	getAttachedFace(): BlockFace
}
declare interface Ladder extends Directional, Waterlogged {
}
declare class InactivityConversationCanceller implements ConversationCanceller {
	setConversation(arg0: Conversation): void
	cancelBasedOnInput(arg0: ConversationContext, arg1: String): boolean
	access$1(arg0: InactivityConversationCanceller): void
	cancelling(arg0: Conversation): void
	startTimer(): void
	stopTimer(): void
	clone(): ConversationCanceller
	clone(): Object
}
declare class CookingRecipe implements Recipe, Keyed {
	setExperience(arg0: float): void
	getExperience(): float
	setInputChoice(arg0: RecipeChoice): CookingRecipe
	getInputChoice(): RecipeChoice
	setCookingTime(arg0: int): void
	getCookingTime(): int
	getGroup(): String
	setGroup(arg0: String): void
	getKey(): NamespacedKey
	setInput(arg0: Material): CookingRecipe
	getInput(): ItemStack
	getResult(): ItemStack
}
declare interface Skeleton extends AbstractSkeleton {
	getConversionTime(): int
	setConversionTime(arg0: int): void
	isConverting(): boolean
}
namespace EntityTeleportEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getFrom(): Location
	function setFrom(arg0: Location): void
	function getTo(): Location
	function setTo(arg0: Location): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityRegainHealthEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getRegainReason(): RegainReason
	function getAmount(): double
	function setAmount(arg0: double): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class NetherWarts extends MaterialData {
	$SWITCH_TABLE$org$bukkit$NetherWartsState(): int[]
	toString(): String
	clone(): MaterialData
	clone(): Object
	clone(): NetherWarts
	getState(): NetherWartsState
	setState(arg0: NetherWartsState): void
}
declare interface Bat extends Ambient {
	setAwake(arg0: boolean): void
	isAwake(): boolean
}
declare interface Ravager extends Raider {
}
declare interface Slab extends Waterlogged {
	setType(arg0: Type): void
	getType(): Type
}
declare interface EntityBlockStorage extends TileState {
	getEntityCount(): int
	getMaxEntities(): int
	setMaxEntities(arg0: int): void
	releaseEntities(): List
	isFull(): boolean
	addEntity(arg0: Entity): void
}
declare interface Repeater extends Directional, Powerable {
	getMinimumDelay(): int
	getMaximumDelay(): int
	setDelay(arg0: int): void
	getDelay(): int
	setLocked(arg0: boolean): void
	isLocked(): boolean
}
declare interface Firework extends Projectile {
	getFireworkMeta(): FireworkMeta
	setFireworkMeta(arg0: FireworkMeta): void
	isShotAtAngle(): boolean
	setShotAtAngle(arg0: boolean): void
	detonate(): void
}
declare class AttributeModifier implements ConfigurationSerializable {
	getUniqueId(): UUID
	deserialize(arg0: Map): AttributeModifier
	getOperation(): Operation
	serialize(): Map
	getAmount(): double
	getName(): String
	equals(arg0: Object): boolean
	toString(): String
	hashCode(): int
	getSlot(): EquipmentSlot
}
declare interface KeyedBossBar extends BossBar, Keyed {
}
declare class PistonBaseMaterial extends MaterialData implements Directional, Redstone {
	setFacingDirection(arg0: BlockFace): void
	getFacing(): BlockFace
	isPowered(): boolean
	setPowered(arg0: boolean): void
	isSticky(): boolean
	$SWITCH_TABLE$org$bukkit$block$BlockFace(): int[]
	clone(): MaterialData
	clone(): Object
	clone(): PistonBaseMaterial
}
declare interface Marker extends Entity {
}
namespace TradeSelectEvent {
	function getHandlerList(): HandlerList
	function getInventory(): MerchantInventory
	function getInventory(): Inventory
	function getMerchant(): Merchant
	function getIndex(): int
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getWhoClicked(): HumanEntity
	function setResult(arg0: Result): void
	function getResult(): Result
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface AttributeInstance {
	getBaseValue(): double
	setBaseValue(arg0: double): void
	addModifier(arg0: AttributeModifier): void
	removeModifier(arg0: AttributeModifier): void
	getModifiers(): Collection
	getValue(): double
	getDefaultValue(): double
	getAttribute(): Attribute
}
declare interface Projectile extends Entity {
	getShooter(): ProjectileSource
	setShooter(arg0: ProjectileSource): void
	doesBounce(): boolean
	setBounce(arg0: boolean): void
}
declare interface Score {
	getScoreboard(): Scoreboard
	getObjective(): Objective
	getPlayer(): OfflinePlayer
	getScore(): int
	setScore(arg0: int): void
	isScoreSet(): boolean
	getEntry(): String
}
declare interface Inventory extends Iterable {
	containsAtLeast(arg0: ItemStack, arg1: int): boolean
	getContents(): ItemStack[]
	setContents(arg0: ItemStack[]): void
	setMaxStackSize(arg0: int): void
	getMaxStackSize(): int
	getStorageContents(): ItemStack[]
	setStorageContents(arg0: ItemStack[]): void
	addItem(arg0: ItemStack[]): HashMap
	removeItem(arg0: ItemStack[]): HashMap
	getHolder(): InventoryHolder
	firstEmpty(): int
	getViewers(): List
	setItem(arg0: int, arg1: ItemStack): void
	remove(arg0: Material): void
	remove(arg0: ItemStack): void
	clear(): void
	clear(arg0: int): void
	isEmpty(): boolean
	iterator(): Iterator
	iterator(): ListIterator
	iterator(arg0: int): ListIterator
	contains(arg0: ItemStack, arg1: int): boolean
	contains(arg0: Material): boolean
	contains(arg0: ItemStack): boolean
	contains(arg0: Material, arg1: int): boolean
	first(arg0: Material): int
	first(arg0: ItemStack): int
	getLocation(): Location
	getType(): InventoryType
	getSize(): int
	all(arg0: Material): HashMap
	all(arg0: ItemStack): HashMap
	getItem(arg0: int): ItemStack
}
namespace PlayerRiptideEvent {
	function getHandlerList(): HandlerList
	function getItem(): ItemStack
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Bell extends TileState {
}
declare interface PlayerInventory extends Inventory {
	getArmorContents(): ItemStack[]
	setItemInOffHand(arg0: ItemStack): void
	setArmorContents(arg0: ItemStack[]): void
	getLeggings(): ItemStack
	setChestplate(arg0: ItemStack): void
	getItemInOffHand(): ItemStack
	setLeggings(arg0: ItemStack): void
	setItemInMainHand(arg0: ItemStack): void
	getItemInMainHand(): ItemStack
	getChestplate(): ItemStack
	getItemInHand(): ItemStack
	setItemInHand(arg0: ItemStack): void
	getExtraContents(): ItemStack[]
	setExtraContents(arg0: ItemStack[]): void
	getHeldItemSlot(): int
	setHeldItemSlot(arg0: int): void
	getHolder(): HumanEntity
	getHolder(): InventoryHolder
	getHelmet(): ItemStack
	setHelmet(arg0: ItemStack): void
	getBoots(): ItemStack
	setBoots(arg0: ItemStack): void
	setItem(arg0: int, arg1: ItemStack): void
	setItem(arg0: EquipmentSlot, arg1: ItemStack): void
	getItem(arg0: EquipmentSlot): ItemStack
}
declare interface Creature extends Mob {
}
declare class SimplexNoiseGenerator extends PerlinNoiseGenerator {
	getNoise(arg0: double, arg1: double): double
	getNoise(arg0: double, arg1: double, arg2: double, arg3: double): double
	getNoise(arg0: double, arg1: double, arg2: double): double
	getNoise(arg0: double): double
	noise(arg0: double, arg1: double, arg2: double, arg3: double): double
	noise(arg0: double, arg1: double): double
	noise(arg0: double, arg1: double, arg2: double): double
	getInstance(): SimplexNoiseGenerator
	dot(arg0: int[], arg1: double, arg2: double, arg3: double, arg4: double): double
	dot(arg0: int[], arg1: double, arg2: double): double
	dot(arg0: int[], arg1: double, arg2: double, arg3: double): double
}
declare interface Ocelot extends Animals {
	setTrusting(arg0: boolean): void
	getCatType(): Type
	setCatType(arg0: Type): void
	isTrusting(): boolean
}
declare interface Comparator extends TileState {
}
namespace BlockEvent {
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class PrimitiveTagType implements ItemTagType {
	getPrimitiveType(): Class
	getComplexType(): Class
	toPrimitive(arg0: Object, arg1: ItemTagAdapterContext): Object
	fromPrimitive(arg0: Object, arg1: ItemTagAdapterContext): Object
}
declare class RedstoneTorch extends Torch implements Redstone {
	isPowered(): boolean
	toString(): String
	clone(): SimpleAttachableMaterialData
	clone(): MaterialData
	clone(): Object
	clone(): Torch
	clone(): RedstoneTorch
}
namespace SmithItemEvent {
	function getInventory(): Inventory
	function getInventory(): SmithingInventory
	function getHandlerList(): HandlerList
	function getSlotType(): SlotType
	function getCurrentItem(): ItemStack
	function isRightClick(): boolean
	function isLeftClick(): boolean
	function isShiftClick(): boolean
	function setCurrentItem(arg0: ItemStack): void
	function getClickedInventory(): Inventory
	function getHotbarButton(): int
	function getCursor(): ItemStack
	function setCursor(arg0: ItemStack): void
	function getRawSlot(): int
	function getAction(): InventoryAction
	function getClick(): ClickType
	function getSlot(): int
	function getHandlers(): HandlerList
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getWhoClicked(): HumanEntity
	function setResult(arg0: Result): void
	function getResult(): Result
	function getViewers(): List
	function getView(): InventoryView
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface CoralWallFan extends Directional, Waterlogged {
}
declare class JavaPlugin extends PluginBase {
	onTabComplete(arg0: CommandSender, arg1: Command, arg2: String, arg3: String[]): List
	getDescription(): PluginDescriptionFile
	getDataFolder(): File
	saveDefaultConfig(): void
	saveResource(arg0: String, arg1: boolean): void
	reloadConfig(): void
	getPluginLoader(): PluginLoader
	setNaggable(arg0: boolean): void
	getDefaultWorldGenerator(arg0: String, arg1: String): ChunkGenerator
	getTextResource(arg0: String): Reader
	getProvidingPlugin(arg0: Class): JavaPlugin
	getConfig(): FileConfiguration
	getCommand(arg0: String): PluginCommand
	getServer(): Server
	onCommand(arg0: CommandSender, arg1: Command, arg2: String, arg3: String[]): boolean
	getPlugin(arg0: Class): JavaPlugin
	saveConfig(): void
	onDisable(): void
	onLoad(): void
	onEnable(): void
	isNaggable(): boolean
	isEnabled(): boolean
	setEnabled(arg0: boolean): void
	toString(): String
	getClassLoader(): ClassLoader
	getResource(arg0: String): InputStream
	init(arg0: PluginLoader, arg1: Server, arg2: PluginDescriptionFile, arg3: File, arg4: File, arg5: ClassLoader): void
	getLogger(): Logger
	getFile(): File
}
declare interface Snowman extends Golem {
	isDerp(): boolean
	setDerp(arg0: boolean): void
}
namespace SpongeAbsorbEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getBlocks(): List
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace NotePlayEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getInstrument(): Instrument
	function setInstrument(arg0: Instrument): void
	function getNote(): Note
	function setNote(arg0: Note): void
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface HorseInventory extends AbstractHorseInventory {
	getArmor(): ItemStack
	setArmor(arg0: ItemStack): void
}
namespace EntityCombustByEntityEvent {
	function getCombuster(): Entity
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getDuration(): int
	function setDuration(arg0: int): void
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace VehicleCollisionEvent {
	function getVehicle(): Vehicle
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace PlayerChannelEvent {
	function getHandlerList(): HandlerList
	function getChannel(): String
	function getHandlers(): HandlerList
	function getPlayer(): Player
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Bee extends Animals {
	setHasNectar(arg0: boolean): void
	setHasStung(arg0: boolean): void
	getCannotEnterHiveTicks(): int
	setCannotEnterHiveTicks(arg0: int): void
	getHive(): Location
	setHive(arg0: Location): void
	hasNectar(): boolean
	hasStung(): boolean
	getFlower(): Location
	setFlower(arg0: Location): void
	getAnger(): int
	setAnger(arg0: int): void
}
declare interface Configuration extends ConfigurationSection {
	getDefaults(): Configuration
	addDefaults(arg0: Configuration): void
	addDefaults(arg0: Map): void
	setDefaults(arg0: Configuration): void
	addDefault(arg0: String, arg1: Object): void
	options(): ConfigurationOptions
}
declare interface Cancellable {
	isCancelled(): boolean
	setCancelled(arg0: boolean): void
}
declare interface Barrel extends Container, Lootable, Lidded {
}
declare interface Switch extends Directional, FaceAttachable, Powerable {
	getFace(): Face
	setFace(arg0: Face): void
}
namespace ServerEvent {
	function getEventName(): String
	function isAsynchronous(): boolean
	function getHandlers(): HandlerList
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class SimplePluginManager implements PluginManager {
	getPermissionSubscriptions(arg0: String): Set
	addPermission(arg0: Permission, arg1: boolean): void
	addPermission(arg0: Permission): void
	getDefaultPermissions(arg0: boolean): Set
	subscribeToDefaultPerms(arg0: boolean, arg1: Permissible): void
	subscribeToPermission(arg0: String, arg1: Permissible): void
	unsubscribeFromPermission(arg0: String, arg1: Permissible): void
	isTransitiveDepend(arg0: PluginDescriptionFile, arg1: PluginDescriptionFile): boolean
	enablePlugin(arg0: Plugin): void
	disablePlugin(arg0: Plugin): void
	registerInterface(arg0: Class): void
	isPluginEnabled(arg0: Plugin): boolean
	isPluginEnabled(arg0: String): boolean
	loadPlugins(arg0: File): Plugin[]
	disablePlugins(): void
	clearPlugins(): void
	registerEvents(arg0: Listener, arg1: Plugin): void
	registerEvent(arg0: Class, arg1: Listener, arg2: EventPriority, arg3: EventExecutor, arg4: Plugin, arg5: boolean): void
	registerEvent(arg0: Class, arg1: Listener, arg2: EventPriority, arg3: EventExecutor, arg4: Plugin): void
	removePermission(arg0: String): void
	removePermission(arg0: Permission): void
	checkUpdate(arg0: File): void
	getRegistrationClass(arg0: Class): Class
	getEventListeners(arg0: Class): HandlerList
	calculatePermissionDefault(arg0: Permission, arg1: boolean): void
	dirtyPermissibles(): void
	dirtyPermissibles(arg0: boolean): void
	useTimings(arg0: boolean): void
	useTimings(): boolean
	getPlugin(arg0: String): Plugin
	getPlugins(): Plugin[]
	callEvent(arg0: Event): void
	fireEvent(arg0: Event): void
	loadPlugin(arg0: File): Plugin
	unsubscribeFromDefaultPerms(arg0: boolean, arg1: Permissible): void
	recalculatePermissionDefaults(arg0: Permission): void
	getDefaultPermSubscriptions(arg0: boolean): Set
	getPermissions(): Set
	getPermission(arg0: String): Permission
}
declare interface ComplexLivingEntity extends LivingEntity {
	getParts(): Set
}
declare interface Openable extends BlockData {
	setOpen(arg0: boolean): void
	isOpen(): boolean
}
namespace EntityTransformEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getTransformedEntity(): Entity
	function getTransformedEntities(): List
	function getTransformReason(): TransformReason
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class FileConfiguration extends MemoryConfiguration {
	saveToString(): String
	buildHeader(): String
	loadFromString(arg0: String): void
	load(arg0: String): void
	load(arg0: Reader): void
	load(arg0: File): void
	save(arg0: File): void
	save(arg0: String): void
	options(): ConfigurationOptions
	options(): MemoryConfigurationOptions
	options(): FileConfigurationOptions
}
namespace InventoryMoveItemEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getDestination(): Inventory
	function getInitiator(): Inventory
	function setItem(arg0: ItemStack): void
	function getItem(): ItemStack
	function getSource(): Inventory
	function getHandlers(): HandlerList
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare class CharacterSprite {
	getHeight(): int
	getWidth(): int
	get(arg0: int, arg1: int): boolean
}
declare interface Comparator extends Directional, Powerable {
	getMode(): Mode
	setMode(arg0: Mode): void
}
declare interface Chest extends Container, Lootable, Lidded {
	getBlockInventory(): Inventory
}
namespace BlockDamageEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getItemInHand(): ItemStack
	function getInstaBreak(): boolean
	function setInstaBreak(arg0: boolean): void
	function getPlayer(): Player
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
namespace EntityDamageEvent {
	function isApplicable(arg0: DamageModifier): boolean
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getOriginalDamage(arg0: DamageModifier): double
	function getFinalDamage(): double
	function setDamage(arg0: double): void
	function setDamage(arg0: DamageModifier, arg1: double): void
	function getDamage(): double
	function getDamage(arg0: DamageModifier): double
	function getCause(): DamageCause
	function getHandlers(): HandlerList
	function getEntityType(): EntityType
	function getEntity(): Entity
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Permissible extends ServerOperator {
	recalculatePermissions(): void
	isPermissionSet(arg0: String): boolean
	isPermissionSet(arg0: Permission): boolean
	addAttachment(arg0: Plugin): PermissionAttachment
	addAttachment(arg0: Plugin, arg1: String, arg2: boolean, arg3: int): PermissionAttachment
	addAttachment(arg0: Plugin, arg1: int): PermissionAttachment
	addAttachment(arg0: Plugin, arg1: String, arg2: boolean): PermissionAttachment
	hasPermission(arg0: Permission): boolean
	hasPermission(arg0: String): boolean
	getEffectivePermissions(): Set
	removeAttachment(arg0: PermissionAttachment): void
}
namespace BlockFertilizeEvent {
	function isCancelled(): boolean
	function setCancelled(arg0: boolean): void
	function getHandlerList(): HandlerList
	function getPlayer(): Player
	function getBlocks(): List
	function getHandlers(): HandlerList
	function getBlock(): Block
	function getEventName(): String
	function isAsynchronous(): boolean
	function wait(arg0: long, arg1: int): void
	function wait(): void
	function wait(arg0: long): void
	function equals(arg0: Object): boolean
	function toString(): String
	function hashCode(): int
	function getClass(): Class
	function notify(): void
	function notifyAll(): void
}
declare interface Husk extends Zombie {
	getConversionTime(): int
	setConversionTime(arg0: int): void
	isConverting(): boolean
}
declare interface Scaffolding extends Waterlogged {
	getDistance(): int
	setDistance(arg0: int): void
	getMaximumDistance(): int
	isBottom(): boolean
	setBottom(arg0: boolean): void
}
declare interface Fence extends MultipleFacing, Waterlogged {
}
declare interface TNTPrimed extends Explosive {
	setFuseTicks(arg0: int): void
	getFuseTicks(): int
	setSource(arg0: Entity): void
	getSource(): Entity
}
declare interface ThrownExpBottle extends ThrowableProjectile {
}

type ListenerFunction<Type> = (event: Type) => void
type CommandFunction = (player: Player, args: any) => void

declare namespace blaze {
    function onEvent<Type>(event: Type, listener: ListenerFunction<Type>): void
    function onCommand(commandName: string, listener: CommandFunction): void
}